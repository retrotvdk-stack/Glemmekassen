<!DOCTYPE html>
<html lang="da">
<script src="https://www.youtube.com/iframe_api"></script>
<script type="text/javascript" id="www-widgetapi-script"
    src="https://www.youtube.com/s/player/4e51e895/www-widgetapi.vflset/www-widgetapi.js" async=""></script>

<head>
    <meta charset="UTF-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Retro Cartoon TV</title>

    <script type="text/javascript" id="www-widgetapi-script"
        src="https://www.youtube.com/s/player/4e51e895/www-widgetapi.vflset/www-widgetapi.js" async=""></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <script async="" src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
    <script>
        window.__onGCastApiAvailable = function (isAvailable) {
            console.log("Google Cast API Available:", isAvailable);
            if (isAvailable) {
                initializeCastApi();
            }
        };

        function initializeCastApi() {
            console.log("Initializing Cast API...");
            try {
                cast.framework.CastContext.getInstance().setOptions({
                    receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
                    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
                });
                console.log("Cast API Initialized successfully.");
            } catch (e) {
                console.error("Cast initialization error:", e);
            }
        }

        function requestCastSession() {
            // 1. Check protocol
            if (window.location.protocol === 'file:') {
                if (typeof updateOSD === 'function') updateOSD("VIRKER IKKE PÅ FILE://", true);
                const overlay = document.getElementById('error153Overlay');
                if (overlay) overlay.style.display = 'flex';
                return;
            }

            // 2. Check browser support (Chrome/Edge required for native Cast SDK)
            const isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
            const isEdge = /Edg/.test(navigator.userAgent);
            if (!isChrome && !isEdge) {
                if (typeof updateOSD === 'function') updateOSD("BRUG CHROME ELLER EDGE", false);
                return;
            }

            try {
                const context = cast.framework.CastContext.getInstance();
                if (context) {
                    context.requestSession();
                } else {
                    throw new Error("Cast Context not found");
                }
            } catch (e) {
                console.warn("Chromecast is not available or could not be triggered:", e);
                if (typeof updateOSD === 'function') {
                    updateOSD("CHROMECAST IKKE KLAR", false);
                }
            }
        }
    </script>
    <!-- Google Cast SDK -->
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
    <script src="//www.gstatic.com/cast/sdk/libs/sender/1.0/cast_framework.js"></script>
    <script src="//www.gstatic.com/eureka/clank/144/cast_sender.js"></script>
    <script src="//www.gstatic.com/cast/sdk/libs/sender/1.0/cast_framework.js"></script>
    <script src="//www.gstatic.com/eureka/clank/144/cast_sender.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow-y: auto;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            /* Retro Wallpaper Pattern */
            background-color: #f0e6d2;
            background-image:
                linear-gradient(90deg, transparent 50%, rgba(255, 255, 255, .5) 50%);
            background-size: 50px 50px;
            font-family: 'Courier New', monospace;
        }

        .tv {
            width: 800px;
            height: 480px;
            /* Increased height proportionally */
            position: relative;
            padding: 20px;
            display: flex;
            flex-direction: row;
            border-radius: 24px;
            background: transparent;
            border: none;
            box-shadow: none;
            z-index: 0;
            max-height: 90vh;
            /* Final height constraint */
            max-width: 95vw;
            /* Final width constraint */
        }

        /* Background on pseudo-element to allow legs to be behind it */
        .tv::before {
            content: "";
            position: absolute;
            inset: 0;
            background: #5d4037;
            background-image: linear-gradient(90deg, #4e342e 0%, #6d4c41 20%, #8d6e63 50%, #6d4c41 80%, #4e342e 100%);
            border-radius: 24px;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.6);
            border: 8px solid #3e2723;
            z-index: -5;
            /* Behind content but in front of legs (-10) */
        }

        .monitor-encasement {
            flex: 4;
            background: #111;
            border-radius: 24px;
            padding: 15px;
            box-shadow: inset 0 0 20px #000;
            border-bottom: 2px solid #333;
            display: flex;
            flex-direction: column;
        }

        .screen-bezel {
            width: 100%;
            height: 100%;
            background: #000;
            border-radius: 20px;
            overflow: hidden;
            position: relative;
            border: 4px solid #222;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }

        .screen {
            width: 100%;
            height: 100%;
            background: #050505;
            position: relative;
        }

        .filter-layer {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        #staticVideo,
        #powerOffVideo {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
            z-index: 5;
        }

        #player {
            width: 100% !important;
            height: 100% !important;
            max-width: 100%;
            max-height: 100%;
            overflow: hidden;
            pointer-events: none;
            position: relative;
        }

        /* Apply object-fit only to actual media elements, not wrapper divs */
        #player iframe,
        #player video {
            width: 100% !important;
            height: 100% !important;
            max-width: 100% !important;
            max-height: 100% !important;
            min-height: auto !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            object-fit: contain !important;
        }

        /* Wrapper divs need positioning without object-fit */
        #player .dailymotion-player-wrapper,
        #player .dailymotion-player,
        #player div {
            width: 100% !important;
            height: 100% !important;
            max-width: 100% !important;
            max-height: 100% !important;
            min-height: auto !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
        }


        .label,
        .mute-icon,
        .volume-number {
            position: absolute;
            opacity: 0;
            transition: .3s;
            z-index: 10;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        .label {
            top: 15px;
            left: 20px;
            color: #0f0;
            font-size: 18px;
        }

        .mute-icon {
            top: 15px;
            right: 20px;
            color: #f00;
            font-size: 18px;
        }

        .volume-bar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 240px;
            height: 12px;
            background: #444;
            border-radius: 6px;
            opacity: 0;
            transition: .3s;
            z-index: 10;
            border: 1px solid #666;
        }

        .volume-bar {
            height: 100%;
            background: #0f0;
            width: 0%;
            border-radius: 5px;
        }

        .volume-number {
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            color: #0f0;
        }

        .side-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding-left: 25px;
            justify-content: flex-start;
        }

        .brand-plate {
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            color: #deb887;
            font-size: 20px;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 1px 1px #000;
            border: 2px solid #3e2723;
            padding: 5px;
            background: #4e342e;
            box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.5);
        }

        .speaker-grille {
            flex: 1;
            background: repeating-linear-gradient(0deg,
                    #2a1b15,
                    #2a1b15 6px,
                    #1a100c 6px,
                    #1a100c 10px);
            border-radius: 8px;
            margin-bottom: 25px;
            box-shadow: inset 0 0 15px #000;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .controls-area {
            background: #4a3b32;
            padding: 15px;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            gap: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-row {
            display: flex;
            gap: 10px;
            justify-content: space-between;
        }

        button {
            flex: 1;
            height: 44px;
            background: #222;
            border: none;
            border-radius: 4px;
            color: #aaa;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 0 #000;
            transition: transform 0.1s, box-shadow 0.1s;
            font-size: 12px;
            text-transform: uppercase;
            border-top: 1px solid #444;
        }

        button:active {
            transform: translateY(3px);
            box-shadow: 0 1px 0 #000;
        }

        button.power-btn {
            background: #800;
            color: #ffcccc;
            border-top: 1px solid #a00;
        }

        button.power-btn:active {
            background: #600;
        }

        /* Banned Item Style */
        .program-item.banned {
            text-decoration: line-through;
            color: #999;
            position: relative;
        }

        .program-item.banned::after {
            content: '❌';
            position: absolute;
            right: 10px;
            color: red;
            font-size: 14px;
        }

        .program-item.now-playing {
            background: #ffe0b2;
            font-weight: bold;
            border-left: 4px solid #ff9800;
        }

        .program-item.up-next {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
        }

        .status-badge {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            margin-right: 5px;
            display: inline-block;
            width: 45px;
        }

        .program-item.ad-break {
            background: #eee;
            color: #555;
            font-style: italic;
            cursor: default;
        }

        .program-item.ad-break:hover {
            background: #eee;
        }

        /* --- LAYOUT & TV GUIDE --- */
        #main-layout {
            position: relative;
            display: flex;
            flex-direction: row;
            /* Desktop: side by side */
            align-items: center;
            justify-content: center;
            width: 100%;
            flex: 1;
            box-sizing: border-box;
            gap: 60px;
            /* Gap to keep guide away from TV */
            padding: 20px;
            transition: gap 0.3s ease;
        }

        .footer-disclaimer {
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            font-size: 11px;
            color: #7d6c5a;
            padding: 15px 20px;
            margin: 30px 0 0 0;
            background-color: #f0e6d2;
            border-top: 2px solid #d3d3d3;
            transition: margin 0.3s ease;
        }

        /* Move footer down when guide is collapsed to avoid overlapping TV legs */
        body:has(.tv-guide.collapsed) .footer-disclaimer {
            margin-top: 100px;
        }

        #main-layout.guide-collapsed {
            gap: 0px;
            /* TV centers naturally without margin when sidebar is absolute */
        }

        .tv-guide {
            width: 300px;
            height: 480px;
            background: #fdfbf7;
            border: 1px solid #d3d3d3;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.2);
            padding: 20px;
            font-family: 'Times New Roman', serif;
            color: #333;
            overflow-y: auto;
            border-radius: 2px;
            position: relative;
            z-index: 100;

            /* Logo Watermark */
            background-image: url('logo.png');
            background-repeat: no-repeat;
            background-position: center center;
            background-size: 200px;
            background-blend-mode: multiply;
        }

        /* Hide logo when TV is ON */
        body.tv-on .tv-guide {
            background-image: none;
        }

        /* Magasinryg effekt - hidden on mobile */
        @media (min-width: 769px) {
            .tv-guide::before {
                content: '';
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                width: 4px;
                background: #aaa;
                /* Binding */
            }
        }

        @media (max-width: 768px) {
            .tv-guide {
                position: relative;
                width: 90%;
                max-width: 500px;
                margin: 0 auto;
                margin-top: 20px;
                /* Add spacing to avoid TV legs */
                height: auto;
                max-height: 400px;
                border: none;
            }

            .guide-toggle {
                display: none !important;
            }

            /* Prevent guide from ever collapsing on mobile */
            .tv-guide.collapsed {
                width: 100% !important;
                padding: 15px !important;
                position: static !important;
            }

            .tv-guide.collapsed .guide-header h2,
            .tv-guide.collapsed #guide-content,
            .tv-guide.collapsed #week-display {
                display: block !important;
            }

            .tv-guide.collapsed .guide-header h2 {
                display: block !important;
            }
        }

        .guide-header {
            text-align: center;
            border-bottom: 2px solid #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
        }

        .guide-header h2 {
            margin: 0;
            text-transform: uppercase;
            font-size: 24px;
            letter-spacing: 1px;
        }

        .guide-header span {
            font-size: 12px;
            color: #666;
            font-style: italic;
        }

        .channel-block {
            margin-bottom: 20px;
        }

        .channel-title {
            font-weight: bold;
            background: #eee;
            padding: 4px 8px;
            margin-bottom: 5px;
            border-bottom: 1px solid #ccc;
            font-size: 14px;
            text-transform: uppercase;
        }

        .program-slot {
            display: flex;
            align-items: center;
            border-bottom: 1px dotted #e0e0e0;
            min-height: 28px;
        }

        .program-badge {
            width: 50px;
            font-size: 10px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .program-content {
            flex-grow: 1;
            font-size: 13px;
            padding: 4px 8px;
            cursor: pointer;
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }

        .program-content:hover {
            background: #fff8e1;
            font-weight: bold;
        }

        .program-content.banning-anim {
            opacity: 0;
            transform: translateX(20px);
            pointer-events: none;
        }

        .program-content.ad-break {
            background: #eee;
            color: #555;
            font-style: italic;
            cursor: default;
        }

        /* Scrollbar styling for retro feel */
        .tv-guide::-webkit-scrollbar {
            width: 8px;
        }

        .tv-guide::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .tv-guide::-webkit-scrollbar-thumb {
            background: #ccc;
        }

        .tv-guide::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        /* GUIDE TOGGLE BUTTON */
        .guide-toggle {
            background: transparent;
            border: none;
            font-size: 18px;
            cursor: pointer;
            position: absolute;
            right: 15px;
            top: 12px;
            padding: 5px;
            transition: transform 0.3s ease;
            color: #333;
        }

        .guide-toggle:hover {
            color: #000;
        }

        /* COLLAPSED GUIDE STATE */
        .tv-guide.collapsed {
            width: 40px;
            padding: 20px 5px;
            overflow: hidden;
            position: relative;
            background-image: none;
            /* Hide logo when collapsed */
        }

        .tv-guide.collapsed .guide-header h2,
        .tv-guide.collapsed #guide-content,
        .tv-guide.collapsed #week-display {
            display: none;
        }

        .tv-guide.collapsed .guide-header {
            border-bottom: none;
        }

        /* Hide border when TV is off (no content) */
        .tv-guide:has(#guide-content:empty) .guide-header {
            border-bottom: none;
        }

        .tv-guide.collapsed .guide-toggle {
            right: 50%;
            transform: translateX(50%) rotate(180deg);
            top: 50%;
            margin-top: -12px;
        }

        /* SMOOTH TRANSITIONS */
        .tv-guide {
            transition: width 0.3s ease, padding 0.3s ease;
        }

        /* TV expansion removed - TV stays same size when guide collapses */






        /* LEGS STYLES */
        .leg {
            position: absolute;
            bottom: -25px;
            width: 25px;
            height: 40px;
            background: linear-gradient(to bottom, #4e342e, #281a16);
            border: 3px solid #1a100c;
            border-top: none;
            box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.5);
            box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.5);
            z-index: -10;
            /* Behind .tv::before (-5) */
        }

        .leg.left {
            left: 80px;
            transform: skewX(15deg);
            border-radius: 0 0 5px 15px;
        }

        .leg.right {
            right: 80px;
            transform: skewX(-15deg);
            border-radius: 0 0 15px 5px;
        }

        /* Range Slider Styling */
        .retro-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #222;
            outline: none;
            border-radius: 4px;
            border-bottom: 1px solid #555;
            box-shadow: inset 0 1px 3px #000;
            appearance: none;
        }

        .retro-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 20px;
            background: #555;
            cursor: pointer;
            border: 1px solid #777;
            border-radius: 2px;
            box-shadow: 0 2px 2px #000;
        }

        .retro-slider::-moz-range-thumb {
            width: 14px;
            height: 20px;
            background: #555;
            cursor: pointer;
            border: 1px solid #777;
            border-radius: 2px;
            box-shadow: 0 2px 2px #000;
        }

        /* TOGGLE SWITCH - RETRO MECHANICAL STYLE */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding-top: 5px;
            border-top: 1px solid rgba(0, 0, 0, 0.2);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            cursor: pointer;
            z-index: 2;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 50%, #1a1a1a 100%);
            transition: .3s;
            border-radius: 3px;
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.8), 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid #2a2a2a;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 1px;
            background: linear-gradient(135deg, #666 0%, #444 50%, #333 100%);
            transition: .3s;
            border-radius: 2px;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border: 1px solid #555;
            /* Ridged texture effect */
            background-image: repeating-linear-gradient(90deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 0, 0, 0.3) 2px,
                    rgba(0, 0, 0, 0.3) 3px);
        }

        input:checked+.slider {
            background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 50%, #1a1a1a 100%);
        }

        input:checked+.slider:before {
            transform: translateX(14px);
        }

        .ad-led {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #333;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
            transition: background-color 0.3s, box-shadow 0.3s;
            margin-left: 5px;
        }

        .ad-led.on-green {
            background-color: #4caf50;
            box-shadow: 0 0 5px #4caf50;
        }

        .ad-led.on-red {
            background-color: #f44336;
            box-shadow: 0 0 5px #f44336;
        }

        .toggle-label {
            font-size: 8px;
            color: #888;
            text-transform: uppercase;
            font-weight: bold;
        }

        /* Series Filter Menu Styles */
        .series-filter-menu {
            width: 90%;
            max-width: 900px;
            margin: 30px auto;
            background: #fdfbf7;
            border: 2px solid #d3d3d3;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.2);
            padding: 20px;
            font-family: 'Times New Roman', serif;
            color: #333;
            border-radius: 4px;
        }

        .filter-header {
            text-align: center;
            border-bottom: 2px solid #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
        }

        .filter-header h2 {
            margin: 0;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .filter-header p {
            margin: 5px 0 0 0;
            font-size: 12px;
            color: #666;
            font-style: italic;
        }

        .filter-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 16px;
            background: #4a3b32;
            color: #deb887;
            border: 1px solid #3e2723;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-transform: uppercase;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }

        .filter-btn:hover {
            background: #5d4037;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .filter-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .filter-channels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }

        .filter-channel-block {
            background: #fff;
            border: 1px solid #d3d3d3;
            border-radius: 4px;
            overflow: hidden;
        }

        .filter-channel-header {
            background: #eee;
            padding: 10px;
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ccc;
            user-select: none;
        }

        .filter-channel-header:hover {
            background: #e0e0e0;
        }

        .filter-channel-arrow {
            transition: transform 0.3s;
            font-size: 12px;
        }

        .filter-channel-block.collapsed .filter-channel-arrow {
            transform: rotate(-90deg);
        }

        .filter-series-list {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            transition: max-height 0.3s ease;
        }

        .filter-channel-block.collapsed .filter-series-list {
            max-height: 0;
            padding: 0;
            overflow: hidden;
        }

        .filter-series-item {
            display: flex;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px dotted #e0e0e0;
        }

        .filter-series-item:last-child {
            border-bottom: none;
        }

        .filter-series-item label {
            display: flex;
            align-items: center;
            cursor: pointer;
            flex: 1;
            font-size: 13px;
        }

        .filter-series-item input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .filter-series-item label:hover {
            background: #fff8e1;
        }

        @media (max-width: 768px) {
            .series-filter-menu {
                width: 95%;
                padding: 15px;
                margin: 20px auto;
            }

            .filter-channels {
                grid-template-columns: 1fr;
            }

            .filter-header h2 {
                font-size: 20px;
            }
        }


        /* Support Link / Coffee Badge (Sidebar Placement) */
        .guide-sidebar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            height: 480px;
            /* High enough to align with TV */
            justify-content: flex-start;
            transition: opacity 0.3s ease, transform 0.3s ease, position 0s ease 0.3s;
        }

        /* Position sidebar absolutely when guide is collapsed so TV can center */
        .guide-sidebar:has(.tv-guide.collapsed) {
            position: absolute;
            right: -70px;
            /* Place at very edge of screen, slightly beyond */
            top: 50%;
            transform: translateY(-50%);
            z-index: 1;
            /* Lower than TV so it doesn't overlap */
        }

        /* Hide container when tv-guide is collapsed (Desktop only) */
        .tv-guide.collapsed+.footer-buttons-container {
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px);
        }

        .footer-buttons-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 300px;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .coffee-link {
            text-decoration: none;
            width: 100%;
            transition: transform 0.2s ease;
            display: block;
        }

        .coffee-plate {
            background: #f4c430;
            color: #3e2723;
            text-align: center;
            font-weight: bold;
            font-size: 11px;
            padding: 12px 18px;
            border-radius: 4px;
            border: 3px solid #5d4037;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transform: rotate(-1deg);
        }

        .coffee-plate:hover {
            background: #ffdb58;
            transform: rotate(0deg) scale(1.05);
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.3);
        }

        /* DOWNLOAD CODE BUTTON */
        .download-link {
            text-decoration: none;
            width: 100%;
            transition: transform 0.2s ease;
            display: block;
        }

        .download-plate {
            background: #1976d2;
            color: #ffffff;
            text-align: center;
            font-weight: bold;
            font-size: 11px;
            padding: 12px 18px;
            border-radius: 4px;
            border: 3px solid #0d47a1;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transform: rotate(1deg);
        }

        .download-plate:hover {
            background: #2196f3;
            transform: rotate(0deg) scale(1.05);
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.3);
        }

        .coffee-plate:active {
            transform: scale(0.95);
        }

        /* ANTENNA STYLES */
        .antenna-container {
            position: absolute;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 80px;
            z-index: -20;
            /* Behind TV */
            pointer-events: auto;
            cursor: pointer;
        }

        .antenna-base {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 30px;
            background: radial-gradient(circle at 30% 30%, #a0a0a0, #404040);
            border-radius: 30px 30px 5px 5px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
            border: 2px solid #2a2a2a;
            z-index: 1;
        }

        .antenna-rod {
            position: absolute;
            bottom: 5px;
            left: 50%;
            width: 4px;
            height: 250px;
            background: linear-gradient(90deg, #d0d0d0, #f8f8f8, #a0a0a0);
            border-radius: 2px;
            transform-origin: bottom center;
            border: 1px solid #666;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        }

        .antenna-rod.left {
            transform: translateX(-50%) rotate(-35deg);
        }

        .antenna-rod.right {
            transform: translateX(-50%) rotate(35deg);
        }

        /* Telescopic segments visual trick */
        .antenna-rod::before {
            content: "";
            position: absolute;
            top: 30%;
            left: -2px;
            width: 6px;
            height: 10px;
            background: radial-gradient(circle, #e0e0e0, #808080);
            border: 1px solid #444;
            border-radius: 2px;
        }

        .antenna-rod::after {
            content: "";
            position: absolute;
            top: 60%;
            left: -2px;
            width: 6px;
            height: 10px;
            background: radial-gradient(circle, #e0e0e0, #808080);
            border: 1px solid #444;
            border-radius: 2px;
        }

        .antenna-tip {
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ff0000, #800000);
            border: 1px solid #400000;
            box-shadow: 0 0 2px #000;
        }


        /* iOS Tap to Start Overlay - DISABLED */
        #iosOverlay {
            display: none !important;
        }

        /* ========================================
       RESPONSIVE MOBILE STYLING
       ======================================== */

        /* iPad and smaller tablets (landscape) - HORIZONTAL GUIDE */
        @media screen and (max-width: 1024px) {
            body {
                padding: 10px;
            }

            #main-layout {
                flex-direction: column;
            }
        }

        /* Mobile/iOS - Vertical layout with guide BELOW TV */
        @media screen and (max-width: 768px) {
            #main-layout {
                flex-direction: column;
                /* Stack vertically instead of side by side */
                gap: 0;
                height: auto;
                min-height: 100vh;
                padding: 10px;
            }

            .tv {
                transform: scale(1);
                /* No scaling on mobile */
                margin: 0 auto 20px auto;
                /* Center and add bottom margin */
            }

            .tv-guide {
                position: static !important;
                /* Override any absolute positioning */
                width: 100%;
                max-width: 600px;
                /* Match TV width approximately */
                margin: 0 auto;
                /* Center the guide */
                height: auto;
                min-height: 200px;
                padding: 15px;
                display: block;
                /* Use block layout for guide on mobile */
                visibility: visible;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            .tv-guide.collapsed {
                /* Disable collapse on mobile */
                width: 100%;
                height: auto;
                padding: 15px;
                overflow: visible;
            }

            .guide-sidebar {
                position: static !important;
                /* Keep sidebar in flow on mobile */
                width: 100%;
            }

            .guide-sidebar:has(.tv-guide.collapsed) {
                position: static !important;
                /* Override absolute positioning */
                right: auto;
                top: auto;
                transform: none;
            }

            .guide-header {
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 10px 15px;
                border-bottom: 2px solid #333;
                margin-bottom: 10px;
            }

            .guide-header h2 {
                font-size: 18px;
                margin: 0;
            }

            .guide-toggle {
                display: none;
                /* Hide collapse button on mobile */
            }

            .footer-buttons-container {
                flex-direction: row !important;
                justify-content: center !important;
                gap: 10px !important;
                max-width: 100% !important;
                margin: 15px auto 0 auto;
            }

            .coffee-link,
            .download-link {
                flex: 1;
                max-width: 200px;
            }

            .coffee-plate,
            .download-plate {
                font-size: 10px !important;
                padding: 10px 10px !important;
                white-space: nowrap;
            }

            #guide-content {
                display: block !important;
                /* ALWAYS show guide content on mobile - override collapsed state */
                overflow-y: auto;
                overflow-x: hidden;
                height: auto;
                max-height: 400px;
                -webkit-overflow-scrolling: touch;
                visibility: visible !important;
            }

            /* Override collapsed hiding on mobile - guide should ALWAYS be visible */
            .tv-guide.collapsed #guide-content,
            .tv-guide.collapsed .guide-header h2,
            .tv-guide.collapsed #week-display {
                display: block !important;
                visibility: visible !important;
            }

            .channel-block {
                width: 100%;
                margin-bottom: 15px;
                display: block !important;
                visibility: visible !important;
            }

            .program-slot {
                display: block !important;
                /* Make sure program slots are visible */
                visibility: visible !important;
            }

            .channel-title {
                display: block !important;
                visibility: visible !important;
            }

            .program-content {
                display: block !important;
                visibility: visible !important;
            }

            /* Coffee button - always visible on mobile */
            .coffee-link {
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
                pointer-events: auto !important;
                margin: 20px auto;
                max-width: 300px;
            }

            .tv-guide.collapsed+.coffee-link {
                opacity: 1 !important;
                pointer-events: auto !important;
                transform: none !important;
            }

            /* Disclaimer on mobile */
            .disclaimer {
                order: 999;
                margin-top: 20px;
            }
        }

        /* iPhone and smaller devices - just scale TV smaller */
        @media screen and (max-width: 430px) {
            .tv {
                transform: scale(0.75);
                /* Scale down TV for small screens */
            }

        }

        /* Very small phones (iPhone SE, etc.) - scale even smaller */
        @media screen and (max-width: 375px) {
            .tv {
                transform: scale(0.6);
                /* Smaller scale for tiny screens */
            }
        }

        /* Fullscreen Controls */
        /* Fullscreen Controls */
        /* Fullscreen Controls */
        .fs-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #4a3b32;
            padding: 12px 20px;
            border-radius: 12px;
            border: 2px solid #3e2723;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: stretch;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8), inset 0 0 10px rgba(0, 0, 0, 0.5);
            width: auto;
            min-width: 650px;
        }

        .fs-controls.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .fs-controls .control-row {
            display: flex;
            gap: 15px;
            justify-content: space-between;
            align-items: center;
        }

        .fs-controls button {
            flex: 1;
            height: 38px;
            background: #222;
            border: none;
            border-radius: 4px;
            color: #aaa;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 0 #000;
            transition: transform 0.1s, box-shadow 0.1s;
            font-size: 10px;
            text-transform: uppercase;
            border-top: 1px solid #444;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
        }

        .fs-controls button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #000;
        }

        .fs-controls button.power-btn {
            background: #800;
            color: #ffcccc;
            border-top: 1px solid #a00;
            flex: 0.8;
        }

        .fs-controls .fs-exit-btn {
            background: #5d1010;
            color: #ffcccc;
            border-top: 1px solid #800;
            flex: 0.8;
        }

        .fs-controls .toggle-label {
            font-size: 8px;
            color: #ccc;
            text-transform: uppercase;
            font-weight: bold;
        }

        .fs-controls .brightness-label {
            font-size: 8px;
            color: #ccc;
            text-transform: uppercase;
            font-weight: bold;
            min-width: 35px;
        }

        .fs-controls .setting-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        /* Error 153 Overlay */
        #error153Overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            display: none;
            /* Shown via JS */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        .error-box {
            background: #800;
            border: 4px double #ffcccc;
            padding: 25px;
            max-width: 450px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 1);
            position: relative;
        }

        .error-box h2 {
            margin-top: 0;
            color: #ffcccc;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 2px solid #ffcccc;
            padding-bottom: 10px;
        }

        .error-box p {
            line-height: 1.6;
            font-size: 14px;
        }

        .error-box .code-snippet {
            background: #000;
            color: #0f0;
            padding: 10px;
            margin: 15px 0;
            font-size: 13px;
            border: 1px solid #333;
        }

        .error-box .close-btn {
            margin-top: 15px;
            background: #3e2723;
            color: #deb887;
            border: 2px solid #3e2723;
            padding: 8px 20px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
        }

        .error-box .close-btn:hover {
            background: #4e342e;
            color: #fff;
        }

        /* Volume in Fullscreen - Move to Top */
        .screen:fullscreen .volume-bar-container,
        .screen:-webkit-full-screen .volume-bar-container,
        .screen:-moz-full-screen .volume-bar-container,
        .screen:-ms-fullscreen .volume-bar-container {
            top: 40px;
            bottom: auto;
        }

        .screen:fullscreen .volume-number,
        .screen:-webkit-full-screen .volume-number,
        .screen:-moz-full-screen .volume-number,
        .screen:-ms-fullscreen .volume-number {
            top: 55px;
            bottom: auto;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
    </style>
    <link rel="preload" as="script" href="https://static1.dmcdn.net/playerv5/dmp.infopack.38f7d10521bffda30771.js">
    <link rel="preload" as="script" href="https://static1.dmcdn.net/playerv5/dmp.photon_vendor.4508c08b2e25df3965bc.js">
    <link rel="preload" as="script" href="https://static1.dmcdn.net/playerv5/dmp.photon_boot.e224859e81f0c56c30ec.js">
    <link rel="preload" as="script" href="https://static1.dmcdn.net/playerv5/dmp.photon_app.44149f7b74bf966665ab.js">
    <link rel="preload" as="script" href="https://static1.dmcdn.net/playerv5/dmp.photon_player.ba6bb73a53bbba38856b.js">
    <link rel="preload" as="script" href="https://static1.dmcdn.net/playerv5/dmp.infopack.38f7d10521bffda30771.js">
    <link rel="preload" as="script" href="https://static1.dmcdn.net/playerv5/dmp.photon_vendor.4508c08b2e25df3965bc.js">
    <link rel="preload" as="script" href="https://static1.dmcdn.net/playerv5/dmp.photon_boot.e224859e81f0c56c30ec.js">
    <link rel="preload" as="script" href="https://static1.dmcdn.net/playerv5/dmp.photon_app.44149f7b74bf966665ab.js">
    <link rel="preload" as="script" href="https://static1.dmcdn.net/playerv5/dmp.photon_player.ba6bb73a53bbba38856b.js">
</head>

<body>



    <div id="main-layout">
        <div class="tv" id="tv">

            <!-- Antenna -->
            <div class="antenna-container" onclick="antennaFumble()" title="Justér antenne">
                <div class="antenna-rod left">
                    <div class="antenna-tip"></div>
                </div>
                <div class="antenna-rod right">
                    <div class="antenna-tip"></div>
                </div>
                <div class="antenna-base"></div>
            </div>

            <!-- Legs visual -->
            <div class="leg left"></div>
            <div class="leg right"></div>


            <div class="monitor-encasement">
                <div class="screen-bezel">
                    <div class="screen">
                        <div id="error153Overlay">
                            <div class="error-box">
                                <h2>System Fejl 153</h2>
                                <p>YouTube blokerer afspilning via <strong>file://</strong> protokollen.</p>
                                <p>Du skal køre appen gennem en <strong>lokal server</strong> for at se videoerne.</p>
                                <div class="code-snippet">
                                    1. Dobbeltklik på: <strong>start_tv.command</strong><br>
                                    2. Gå til: <strong>http://localhost:8000</strong>
                                </div>
                                <button class="close-btn"
                                    onclick="document.getElementById('error153Overlay').style.display='none'">Skjul
                                    advarsel</button>
                            </div>
                        </div>
                        <div class="filter-layer" id="filterLayer">
                            <video id="staticVideo" loop="" muted="" playsinline="" webkit-playsinline="true"
                                src="https://cdn.pixabay.com/video/2018/04/20/15708-266043570_large.mp4"></video>
                            <video id="powerOffVideo" muted="" playsinline="" webkit-playsinline="true"
                                src="https://cdn.pixabay.com/video/2019/09/25/27228-362518551_large.mp4"></video>
                            <div id="player"></div>
                        </div>
                        <div class="label" id="label" style="opacity: 0;">TV slukket</div>
                        <div class="mute-icon" id="muteIcon">MUTE</div>
                        <div class="volume-bar-container" id="volumeContainer">
                            <div class="volume-bar" id="volumeBar"></div>
                        </div>
                        <div class="volume-number" id="volumeNumber">50</div>

                        <!-- Fullscreen Controls Overlay (Auto-hide) -->
                        <div class="fs-controls" id="fsControls">
                            <!-- Primary Buttons Row -->
                            <div class="control-row">
                                <button class="power-btn" onclick="power()" aria-label="Power">POWER</button>
                                <button onclick="chDown()" aria-label="CH-">CH -</button>
                                <button onclick="chUp()" aria-label="CH+">CH +</button>
                                <button onclick="volDown()" aria-label="VOL-">VOL -</button>
                                <button onclick="volUp()" aria-label="VOL+">VOL +</button>
                                <button onclick="muteToggle()" aria-label="Mute">MUTE</button>
                                <button onclick="requestCastSession()" id="fsCastBtn"
                                    aria-label="Chromecast">CAST</button>
                                <button onclick="toggleFullscreen()" aria-label="Exit Fullscreen"
                                    class="fs-exit-btn">EXIT FS</button>
                            </div>

                            <!-- Settings Row -->
                            <div class="control-row" style="border-top: 1px solid rgba(0,0,0,0.1); padding-top: 8px;">
                                <div class="setting-group">
                                    <div class="brightness-label">Farve</div>
                                    <input type="range" id="fsSaturationSlider" min="0" max="200" value="100"
                                        class="retro-slider"
                                        oninput="setSaturation(this.value); document.getElementById('saturationSlider').value = this.value;">
                                </div>

                                <div class="setting-group">
                                    <div class="brightness-label">Lys</div>
                                    <input type="range" id="fsBrightnessSlider" min="20" max="150" value="100"
                                        class="retro-slider"
                                        oninput="setBrightness(this.value); document.getElementById('brightnessSlider').value = this.value;">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="side-panel">
                <div class="brand-plate">RETROKYLLINGEN</div>
                <div class="speaker-grille"></div>
                <div class="controls-area">
                    <button class="power-btn" onclick="power()" aria-label="Power">POWER</button>
                    <div class="control-row">
                        <button onclick="chDown()" aria-label="CH-">CH -</button>
                        <button onclick="chUp()" aria-label="CH+">CH +</button>
                    </div>
                    <div class="control-row">
                        <button onclick="volDown()" aria-label="VOL-">VOL -</button>
                        <button onclick="volUp()" aria-label="VOL+">VOL +</button>
                    </div>
                    <div class="control-row" style="justify-content: center; align-items: center; padding-top: 5px;">
                        <!-- Color Slider -->
                        <div class="brightness-label"
                            style="font-size: 8px; color:#888; text-transform:uppercase; margin-right:5px; font-weight:bold;">
                            Farve
                        </div>
                        <input type="range" id="saturationSlider" min="0" max="200" value="100" class="retro-slider"
                            oninput="setSaturation(this.value)">
                    </div>
                    <div class="control-row" style="justify-content: center; align-items: center; padding-top: 5px;">
                        <!-- Brightness Slider -->
                        <div class="brightness-label"
                            style="font-size: 8px; color:#888; text-transform:uppercase; margin-right:5px; font-weight:bold;">
                            Lys
                        </div>
                        <input type="range" id="brightnessSlider" min="20" max="150" value="100" class="retro-slider"
                            oninput="setBrightness(this.value)">
                    </div>
                    <div class="toggle-container">
                        <span class="toggle-label">Reklamer FRA</span>
                        <label class="switch">
                            <input type="checkbox" id="adToggle" checked="" onchange="toggleAds(this.checked)">
                            <span class="slider"></span>
                        </label>
                        <span class="toggle-label">TIL</span>
                        <div id="adLed" class="ad-led"></div>
                    </div>
                    <div class="control-row">
                        <button onclick="muteToggle()" aria-label="Mute" style="flex: 0.5">MUTE</button>
                        <button onclick="toggleFullscreen()" aria-label="Fullscreen" style="flex: 0.5; padding: 8px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z">
                                </path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- TV GUIDE SIDEBAR COLUMN -->
        <div class="guide-sidebar">
            <div class="tv-guide" id="tvGuide">
                <div class="guide-header">
                    <h2>TV Oversigt</h2>
                    <button class="guide-toggle" onclick="toggleGuide()" aria-label="Toggle guide">◀</button>
                </div>
                <div id="guide-content"></div>
            </div>

            <!-- Combined Footer Buttons -->
            <div class="footer-buttons-container">
                <!-- Support Link -->
                <a href="https://buymeacoffee.com/retrokyllingen.dk?new=1" target="_blank" class="coffee-link">
                    <div class="coffee-plate">
                        <span style="font-size: 18px;">☕</span> KØB MIG EN KAFFE
                    </div>
                </a>

                <!-- Download Source Button -->
                <a href="javascript:void(0)" onclick="downloadSource()" class="download-link">
                    <div class="download-plate">
                        <span style="font-size: 18px; margin-right: 8px;">💾</span> DOWNLOAD KODE
                    </div>
                </a>
            </div>
        </div>

    </div>

    <!-- Series Filter Menu -->
    <div class="series-filter-menu" id="seriesFilterMenu">
        <div class="filter-header">
            <h2>Serie Filter</h2>
        </div>

        <div class="filter-controls">
            <button class="filter-btn" onclick="selectAllSeries()">Vælg Alle</button>
            <button class="filter-btn" onclick="deselectAllSeries()">Fravælg Alle</button>
            <button class="filter-btn" onclick="expandAllChannels()">Udvid Alle</button>
            <button class="filter-btn" onclick="collapseAllChannels()">Kollaps Alle</button>
        </div>

        <div class="filter-channels" id="filterChannels">
            <!-- Channel blocks will be generated here by JavaScript -->
        </div>
    </div>

    <script>
        // Force disclaimer to bottom of page
        document.addEventListener('DOMContentLoaded', () => {
            const footer = document.querySelector('.footer-container');
            if (footer) {
                document.body.appendChild(footer);
            }
        });
    </script>

    <script>
        // Setup OSD Hover Logic
        document.addEventListener('DOMContentLoaded', () => {
            const tv = document.getElementById('tv');
            const label = document.getElementById('label');

            label.style.opacity = 0; // Ensure it starts hidden

            tv.addEventListener('mouseenter', () => {
                if (on) {
                    // If a sticky OSD (like Reklamer) is already showing, don't overwrite it immediately
                    if (!label.sticky) {
                        label.innerText = `${channels[current].name}`;
                        label.style.opacity = 1;
                    }
                }
            });

            tv.addEventListener('mouseleave', () => {
                label.style.opacity = 0;
            });
        });
    </script>

    <audio id="clickSound" preload="auto"
        src="https://orangefreesounds.com/wp-content/uploads/2017/01/Button-click-sound.mp3"></audio>

    <audio id="staticSound" preload="auto">
        <source src="https://www.orangefreesounds.com/wp-content/uploads/2014/11/Static-sound-effect.mp3"
            type="audio/mpeg">
    </audio>

    <audio id="powerOffSound" preload="auto"
        src="https://www.orangefreesounds.com/wp-content/uploads/2022/03/Tv-turn-off-sound-effect.mp3"></audio>

    <audio id="toggleSound" preload="auto"
        src="https://www.orangefreesounds.com/wp-content/uploads/2017/01/Button-click-sound.mp3"></audio>

    <!-- Chicken sounds for logo easter egg - plays random sound on click -->
    <audio id="chickenSound1" preload="auto" src="chicken.mp3"></audio>
    <audio id="chickenSound2" preload="auto" src="chicken2.mp3"></audio>
    <audio id="chickenSound3" preload="auto" src="chicken3.mp3"></audio>

    <!-- YouTube API loaded asynchronously in JS to ensure callback is ready -->
    <!-- <script src="https://www.youtube.com/iframe_api"></script> -->
    <script src="https://geo.dailymotion.com/libs/player/x7zes.js"></script>

    <script>
        const channels = [
            {
                name: "RK1",
                series: {
                    "Duck Dodgers": ["https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E01.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E02.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E03.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E04.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E05.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E06.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E07.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E08.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E09.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E10.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E11.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E12.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E13.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E14.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E15.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E16.mp4", "https://ia601406.us.archive.org/31/items/duck-dodgers_dansk_tale/S01E17.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E18.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E19.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E20.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E21.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E22.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S01E23.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E01.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E02.mp4", "https://ia801406.us.archive.org/31/items/duck-dodgers_dansk_tale/S02E03.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E04.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E05.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E06.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E07.mp4", "https://ia801406.us.archive.org/31/items/duck-dodgers_dansk_tale/S02E08.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E09.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E10.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E11.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E12.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E13.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E14.mp4", "https://ia801406.us.archive.org/31/items/duck-dodgers_dansk_tale/S02E15.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E16.mp4", "https://ia601406.us.archive.org/31/items/duck-dodgers_dansk_tale/S02E17.mp4", "https://ia801406.us.archive.org/31/items/duck-dodgers_dansk_tale/S02E18.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E19.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E20.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E21.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S02E22.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E01.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E02.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E03.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E04.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E05.mp4", "https://ia801406.us.archive.org/31/items/duck-dodgers_dansk_tale/S03E06.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E07.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E08.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E09.mp4", "https://ia601406.us.archive.org/31/items/duck-dodgers_dansk_tale/S03E10.mp4", "https://ia601406.us.archive.org/31/items/duck-dodgers_dansk_tale/S03E11.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E12.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E13.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E14.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E15.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E16.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E17.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E18.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E19.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E20.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E21.mp4", "https://dn710105.ca.archive.org/0/items/duck-dodgers_dansk_tale/S03E22.mp4"],
                    "X-men Evolution": ["https://ia600700.us.archive.org/15/items/x-men-evolution_202503/S02E01.mp4", "https://ia800700.us.archive.org/15/items/x-men-evolution_202503/S02E02.mp4", "https://ia600700.us.archive.org/15/items/x-men-evolution_202503/S02E03.mp4", "https://ia800700.us.archive.org/15/items/x-men-evolution_202503/S02E04.mp4", "https://ia800700.us.archive.org/15/items/x-men-evolution_202503/S02E05.mp4"],
                    "Ozzy og Drix": ["https://dn710008.ca.archive.org/0/items/ozzy-og-drix-dansk-tale/S02E01.mp4", "https://dn710008.ca.archive.org/0/items/ozzy-og-drix-dansk-tale/S02E02.mp4", "https://dn710008.ca.archive.org/0/items/ozzy-og-drix-dansk-tale/S02E03.mp4", "https://dn710008.ca.archive.org/0/items/ozzy-og-drix-dansk-tale/S02E04.mp4", "https://ia904502.us.archive.org/24/items/ozzy-og-drix-dansk-tale/S02E05.mp4", "https://dn710008.ca.archive.org/0/items/ozzy-og-drix-dansk-tale/S02E06.mp4", "https://dn710008.ca.archive.org/0/items/ozzy-og-drix-dansk-tale/S02E07.mp4", "https://dn710008.ca.archive.org/0/items/ozzy-og-drix-dansk-tale/S02E08.mp4", "https://dn710008.ca.archive.org/0/items/ozzy-og-drix-dansk-tale/S02E09.mp4", "https://dn710008.ca.archive.org/0/items/ozzy-og-drix-dansk-tale/S02E10.mp4", "https://ia804502.us.archive.org/24/items/ozzy-og-drix-dansk-tale/S02E12.mp4", "https://dn710008.ca.archive.org/0/items/ozzy-og-drix-dansk-tale/S02E13.mp4"],
                    "Gumball": ["rgzMFMuwG4U", "Mqy8yRoOQUs", "SQO_yx8JgSc", "vJVzWTljIE0", "vJVzWTljIE0", "o8_obLCFirA", "eNrBPeuHjW0", "W0jLfERwz0s", "Wxzc3TAHxLc", "8fYM3eNeX_0", "UgJ-R16WAP0", "4JlZ5H4UQ5M", "bqLFaGRUn0g", "kf1kP3kZx-E", "wYP0eIL5qjs", "82zVA5NuShA", "k4ZSFiVy8gw", "ehmQKuEC57I", "a6_gqAX9joE", "0G268GsDQFY", "zVHJHtrNtxc", "bNhJ_mFFnIA", "xAzRDrumRS0", "jey31OpIzMg", "OJhFteSbK90", "EP3R9jj9Bys", "v2YauFt2PAY", "JGr0rqbgCXU", "MwWSqLGNtRc", "sW-OgvgZq9w", "ep0UtOd4EOM", "0FPxHAHs-CM", "nocl9fXRXRA", "Cv5L_UbkvIg", "By-RYoxlB14", "uVphCkYhx9Y", "96G2vpD14lA", "3C7sS7UfdVU", "dl7KKdxnhmc", "81irljSQHQ4", "5t7zdwlBVh4", "jKcjBNYCVn8", "GBN6lMBFJRg", "WGASrCagF30", "pEGVefO_JfQ", "UQdgp-zQWfc", "ABTUQCbNx7c", "jvUijjtWuJI", "8spwZHva08s", "QD2uN2mW19o", "7v5iNodh5ZA", "bc2zK4AcQsY", "h83hdRenTM8", "l9NWAue7UyA", "iIzeg1P7KaM"],
                    "Sabrina - Skolens heks": ["SOdfs26p1oU", "ObyWPvitzMU", "I45Y4XQsKk8", "XlOqCW9vYuQ", "G--QnsGcNQ4"],
                    "Juniper Lee": ["00UzN-E-MOc", "qfKVmTs374I", "Fdy3v0nuxP8", "2d1Y4emvz_Q", "cu8dJZ6-PWs", "7Hqciu7pfhA"],
                    "Ed, Edd og Eddy": ["BhQnCEbksX8", "qbTaekKhnFc", "KficyJz8L4U", "UJ-gmM401mw", "9v22NRqsIt8", "xn1T8L9yU7Q", "U2ePD1yqXQc", "iKmEVvY6Z4E", "2ZdqzRgDtSI", "pLNtRtPiYcM", "hw2kaIxa--w", "iKmEVvY6Z4E", "2ZdqzRgDtSI", "cZRxPYTlbag", "udkwBO3pZ7w", "tTiwuTPam-k", "vkod5pdBupQ", "H7Toz0JmY9Y", "h7x6kQ9tzsA", "MoF0fex3iHA"],
                    "Camp Lazlo": ["6maqwk8obic"],
                    "Krampe Tvillingerne": ["1cJpDlN9jhA", "Njl3AUS706A", "V60ed2fnFqo", "rNwYrgsPySk", "sn2CrnF8WpI", "MaLLTk2Ve84", "-Vmmu6kTVVA", "eOvxWxkKTyI", "xmCIEzvMA2g", "d3E5D3Etv70", "O51r0T3mf2o", "PRld4zaLtQI", "8-uyvrFRukI", "Oscgy7GInl4", "EngJ7fAWCpA", "3qJn913yi0M", "zqP1-F_6LR4", "QN3sw11V9QI", "fhtVyxgceXM", "a6uWM38fUWI", "CweP6EZgJNM", "-jUWdoD9o-o", "ok_bOzghySo", "A2mYNZ2cblY", "PI9O5ZBx5Vk", "klrLNsm8bAs", "Lq2FtOjSz1Y", "i9ciAWxsxbA", "8-4vQV4UOX4", "Ejj-obomZ0U", "T6Zdr3XaojM", "yXVWjfWcYW8", "I7Gr3CaQcnU", "qFcmBoJlPhw", "VZVHpniPxtk", "C86EdTBgFbE", "_Gd5gbIkYjo", "jFoABBHb5Hc", "pAJQlsEm4cw", "mjatRo4NUPo", "t8HJMx1_xgo", "yf3fDaOyGRc", "vHgMCcaF6zc", "QzVZFZP3bmY", "0LlHp9FoozA", "DzhkZ-Ch6x4", "V8aMc-JFFN4", "tMeBgsVokUQ", "esWyZ_vfrTc", "vafgFOrCnJY"],
                    "Familien Flintstone": ["GitWzr2c4sc", "CnQsTmPakkU", "mjpMv2f_SwM", "QVBNzERonb8", "_tbcDj3wLIo", "4N_dBIQ151U"],
                    "Powerpuff Pigerne": ["YkWuPoDz1vs", "50mVPTaZz3o"],
                    "Chowder": ["YXAKI8vQ9MQ", "dODLuN8n4hg"],
                    "Johnny Bravo": ["SKlC4AQc5xA", "Q70N3uSbTVM", "ByFl6PRmP-I", "vqAgvFSKEjs", "y_rsJZIzQB4", "yNMDtj1nNpM", "T0Q9q427DhY", "B4otvbWvjTU", "qFwOM538wWg", "l6R-da2-XKc"],
                    "Scooby Doo": ["A9JEbTvmF24", "Tt7Bqt1m1wY", "jUmOr7fZZ0o", "faud2kc-a7I"],
                    "Ben 10": ["https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E01.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E02.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E03.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E04.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E05.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E06.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E07.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E08.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E09.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E10.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E11.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E12.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S01E13.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E01.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E02.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E03.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E04.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E05.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E06.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E07.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E08.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E09.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E10.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E11.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E12.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S02E13.mp4", "https://ia800804.us.archive.org/33/items/ben-10-2003/S03E01.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E02.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E03.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E04.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E05.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E06.mp4", "https://ia600804.us.archive.org/33/items/ben-10-2003/S03E07.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E08.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E09.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E10.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E11.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E12.mp4", "https://dn720704.ca.archive.org/0/items/ben-10-2003/S03E13.mp4"],
                    "Batman: Den tapre og modige": ["Cy6xkqfdSbI"],
                    "Foster's hjem for fantasivenner": ["X9GjZDawyL4", "giIOFnwLVzM", "813YzofZh_M", "56nP95hRt2c", "wipx_2OnvCo", "F-lM3W4pYkk", "TrWErP_UObc", "D3hLFK31iw8", "Ys2OUpvcXCM"],
                    "Kodenavn: Naboens børn": ["https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E01.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E02.DK.ENG.PDTV.x264-BONDE.mp4", "https://ia600208.us.archive.org/26/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E03.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E04.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E05.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E06.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E07.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E08.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E10.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E11.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E11.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E12.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S01E13.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E01.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E02.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E03.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E04.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://ia800208.us.archive.org/26/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E06.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E07.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E08.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E09.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E10.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E11.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E12.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S02E13.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E01.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E02.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E03.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E04.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://ia800208.us.archive.org/26/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E05.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E07.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E08.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E09.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E09.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E10.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E11.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E12.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S03E13.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S04E01.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S04E02.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S04E03.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S04E04.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S04E06.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S04E07.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S04E08.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S04E09.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S04E10.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S04E13.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E01.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E02.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E03.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E04.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E05.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E06.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E07.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E09.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E10.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E11.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E12.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S05E13.DK.ENG.PDTV.x264-BONDE%20.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E01.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E02.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E03.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E04.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E05.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E06.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E07.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E08.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E10.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E11.DK.ENG.PDTV.x264-BONDE.mp4", "https://dn721609.ca.archive.org/0/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E12.DK.ENG.PDTV.x264-BONDE.mp4", "https://ia600208.us.archive.org/26/items/kodenvn-nboens-bor/Codename.Kids.Next.Door.S06E13.DK.ENG.PDTV.x264-BONDE.mp4"],
                    "Ko og Kylling": ["k97ScATFM8U", "SeY1FpxnWm0", "ZyuyeifZazs", "ZE9X17CrpO8", "bha4HQXCVmE", "s3PB2_Ltoxg", "Rall9ncURwc", "H-hEgyUJz34", "3BR7wDUgeO8", "itzx5pvkqF8", "aY6hoJbyOZI", "frRgj11QXBE", "qy7mJR-iaA8", "b0f5GG7TW_0"],
                    "What a cartoon": ["qDfB7qwtegs", "OsLQgXoS994", "Dnz8IjSTtxs", "So7BtN_F9nc", "qbBehMStxqA", "_esXP0K5Sk0", "qrP7RH2IXf8"],
                    "Dexter's laboratorium": ["F-9sesft0lw", "dp4QKCaikVY", "cYDGKOD-g54", "f70dsgpD5CE", "7PkbzK_iGPs", "6BGwqIYZ4Ns", "loocTs2UXkM", "JdLjJhasQek", "dGrHnUJouG8", "JdLjJhasQek", "evnoxjtvXrg", "T7xTcj72oxQ", "A3ZnirIbbXE", "loT9Zt9IBiM", "tS9w3araFAA", "RdL_QdZdu4o", "u2bOuuffmwY"],
                    "Robotboy": ["eIjb1oZMNc4", "IT0jAy4IVNg", "uilUjYuUtck", "gNYyUsD0g3c", "fP8FPqrqOW0", "_46YMGDru8", "B5PSWQkzeic", "5Jzx0pHqelE", "ISe3z9OEHFc", "dA8jEfCI9pE", "r8mIlHd8WJs", "tcpgGrS_x0o", "sBQuVP2Z_B8", "EyZuSeo8KKU", "9eqBSLrSSRY", "DGfoTwdwFjc", "TMHRXf44Ihc", "h7j7azB7oGI", "pqdlm2LJiUo", "gTlxMgSQcYU", "3KFQvcmqsxA", "rJJkWOPc3fM", "setXpQiH_Mg", "Q-RlF9aLRvE", "2WLCA5V6laE", "3dzwiJ1GQb4", "nQ_61aVj3a0", "DTv0SSHKn7Q", "JlsxQGzms3U", "zI4IhhbZ3Pk", "cATwR-IjRcw", "5Td6r02WmUQ", "L0cxbXdTBQU", "FOu7MJn_Omk", "AVaiRfiVGAw", "0gcJCYcKAYcqIYzv", "M5b8aoN4ASg", "vrnPEioga0I", "np4DPKZUtGk", "ctAXNzaNfXc", "AQGHP2ZI7pM", "CgPtwz6CaX4", "zFDG9DlPrJ0", "d0qGysvsJUQ", "xgM7xma5G9A", "Niv0fTHvDTM", "xNsB5TcK8ys", "kVxTGrNXAPs"],
                    "Jackie Chan Adventures": ["oNLBxtUxOKs"],
                    "Frygtløs den frygtsomme hund": ["n3ONGMAGh8k", "q1qy2AE0meE", "J59auG6dD4Y", "RZle6X4yDFQ", "A5D7CiHtzH8", "x6MlwDW0Wzw", "Y3bEzvQlD_Q", "eTrEJbu5T7M", "K2waTzIJpdY", "wlr1IqKPia0", "b1LLO3Ol02s", "ZFQJptU4UWQ", "vGVJG7u0CU", "yKwaNrprfmE", "L2Ert3vPdbs", "Y1nTBZfBUqE", "Xko2ZG3eZr0", "unanmjdHS2o"],
                    "Familien Jetson": ["1hPNDLP77cE", "pxcEeZW5fUY", "mvH69jX24EI"],
                    "Jeg er Væsel": ["BQgGfLLjbCY"]
                }
            },
            {
                name: "RK2",
                series: {
                    "Legenden om Tarzan": ["w1olCJ3g98U", "amy4PzB_MHo", "wn77F5TX7VA", "i39mbdx2d1U", "upyWvx1z75s", "-grXg0n_wVI", "fmhdSho74rM", "HdON75xe6Og", "o5xIeFSHXUE", "mHnDY5IcRJM", "PtYJgMvIBj8"],
                    "Frikvarter": ["https://dn721809.ca.archive.org/0/items/frikvrter/Recess.School%27s.Out.NORDiC.720p%20WEB-DL%20H%20264%20AAC2.0-BONDE.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E01.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E02.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E03.mp4", "https://ia800301.us.archive.org/18/items/frikvrter/S01E04.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E05.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E06.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E07.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E08.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E09.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E10.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E11.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E12.mp4", "https://dn721809.ca.archive.org/0/items/frikvrter/S01E13.mp4"],
                    "Brandy og Hr. Wimse": ["fYOfGZy4ENM", "ZMWVLORH-FA", "ES0nKwEMOIU", "LnwXLju-XDw", "3tKHDWC1lD4", "Vo2YHTW8KrY", "tF9F6cCNH3U", "Y2AWBSVp1sI", "81SRPYBNc-4", "9MwK0W4-0cg", "ktCg7ogKUy8", "Ldi88MkRmv4", "cmHfAOSJ3Tg", "G2JCHgtViXU", "C-UQFXOUq4w", "QNTBCoJdbc4", "i_aeOtOp3U0"],
                    "Barbaren Dave": ["KK6WO8h1b84", "rEKwKmf5xP8", "YwSHsT_LiVA", "XYFdkFzmEug", "sZiaT1l8JI8", "3Dbn0KqbvMY", "URAQseQvP4c", "2FrTDN33a_0", "SOMOC8OCobE", "I9dx8fo-RJU", "rsTUjOUt8BE", "wj19J-Uhyfw", "tHF9VS5TJ-U", "uIl6Q-SEYN4", "-m74C1A4TFc"],
                    "Filmore!": ["NW7QHaz3kKE", "nkZAJL3BBwY", "mIyXivF_2XI", "nKLCAlmHzkI", "P3S4_fqgC98", "77cvJbnt6S4", "y3Rx-2uUDz8", "nOW0blBVTzE", "egwqd3WGTN8"],
                    "Lloyd I rummet": ["vkWeQm9qRCw", "9JYjtx00GB4", "OmpHmOMLi6U", "5YB_5qgXZnQ", "yPzY7NhqLAY", "Y3-XLJlv0jQ", "_JJQikHPSRI", "R2O5m3qFQXI", "9qFpmtgIGpI", "jKzWvNx7XBo", "NiUew9usjV0", "FZL3PeLslz4", "Gms6YwqVBt0"],
                    "Rap sjak": ["https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E01.The.Really.Mighty.Ducks.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E02.Island.Of.The.Not.So.Nice.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E03.Leader.Of.The.Quack.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://ia800208.us.archive.org/21/items/rp-sjk/Quack.Pack.E05.Pride.Goeth.Before.The.Fall.Guy.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E06.Need.4.Speed.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E07.The.Germinator.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://ia800208.us.archive.org/21/items/rp-sjk/Quack.Pack.E08.The.Late.Donald.Duck.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E09.Tasty.Paste.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E10.Phoniest.Home.Videos.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E11.Return.Of.The.T-Squad.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E12.Koi.Story.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E13.Ready.Aim.Duck.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://ia600208.us.archive.org/21/items/rp-sjk/Quack.Pack.E14.Pardon.My.Molecules.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E15.Unusual.Suspects.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E16.Ducklaration.Of.Independence.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E17.Cant.Take.A.Yolk.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E18.Heavy.Dental.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E19.Duck.Quake.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E20.Long.Arm.Of.The.Claw.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E21.Shrunken.Heroes.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E22.Snow.Place.To.Hide.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E23.Huey.Duck.P.I.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E24.Take.My.Duck.Please.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E25.Ducks.By.Nature.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E26.Recipe.For.Adventure.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E27.The.Boy.Who.Cried.Ghost.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E28.I.O.U.A.U.F.O.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E29.Gator.Aid.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://ia600208.us.archive.org/21/items/rp-sjk/Quack.Pack.E30.None.Like.It.Hot.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E31.Ducky.Dearest.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E32.Transmission.Impossible.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E33.Nosy.Neighbors.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E34.Hit.The.Road.Backwater.Jack.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E35.Cat.And.Louse.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E36.Hero.Today.Don.Tomorrow.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E37.Captain.Donald.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E38.Stunt.Double.Or.Nothing.NORDiC.WEB-DL.H.264-BTAHP.mp4", "https://dn710009.ca.archive.org/0/items/rp-sjk/Quack.Pack.E39.Feats.Of.Clay.NORDiC.WEB-DL.H.264-BTAHP.mp4"]
                }
            },
            {
                name: "RK3",
                series: {
                    "Puslekrogen": ["HJnSdzPmYa0"],
                    "Sonic X": ["https://ia801005.us.archive.org/10/items/sonic-x_202412/S01E01.mp4", "https://ia601005.us.archive.org/10/items/sonic-x_202412/S01E02.mp4", "https://ia801005.us.archive.org/10/items/sonic-x_202412/S01E03.mp4", "https://ia801005.us.archive.org/10/items/sonic-x_202412/S01E04.mp4", "https://ia601005.us.archive.org/10/items/sonic-x_202412/S01E07.mp4", "https://ia601005.us.archive.org/10/items/sonic-x_202412/S01E08.mp4", "https://ia601005.us.archive.org/10/items/sonic-x_202412/S01E09.mp4", "https://ia601005.us.archive.org/10/items/sonic-x_202412/S01E10.mp4", "https://ia601005.us.archive.org/10/items/sonic-x_202412/S01E11.mp4", "https://ia801005.us.archive.org/10/items/sonic-x_202412/S01E12.mp4", "https://ia801005.us.archive.org/10/items/sonic-x_202412/S01E13.mp4", "https://ia601005.us.archive.org/10/items/sonic-x_202412/S01E14.mp4", "https://ia801005.us.archive.org/10/items/sonic-x_202412/S01E15.mp4"],
                    "Pokemon": ["https://dn721601.ca.archive.org/0/items/pkemn/Pokemon.S01E01.DANiSH.576p.WEB-DL.x264-DBRETAiL.mp4", "https://dn721601.ca.archive.org/0/items/pkemn/Pokemon.S01E02.DANiSH.576p.WEB-DL.x264-DBRETAiL.mp4", "https://dn721601.ca.archive.org/0/items/pkemn/Pokemon.S01E03.DANiSH.576p.WEB-DL.x264-DBRETAiL.mp4", "https://dn721601.ca.archive.org/0/items/pkemn/Pokemon.S01E04.DANiSH.576p.WEB-DL.x264-DBRETAiL.mp4", "https://dn721601.ca.archive.org/0/items/pkemn/Pokemon.S01E05.DANiSH.576p.WEB-DL.x264-DBRETAiL.mp4", "https://dn721601.ca.archive.org/0/items/pkemn/Pokemon.S01E06.DANiSH.576p.WEB-DL.x264-DBRETAiL.mp4"]
                }
            },
            {
                name: "RK4",
                series: {
                    "Oban Star Racers": ["KG1SHsBTTA8", "8xaE3zIToWc", "U76bVRyiW0s", "FcTEVV-4-dw", "Y7kL7ltJTnI", "TP6io9gyoa0"],
                    "A.T.O.M": ["6t6yO4cgWnY", "-_czQHx4Ns", "vTRaCQF_kjE", "nUeyiD4jQYs", "ig5qr4tBv4g", "PIV55gT3b28", "0Za-4iKgWKs", "R-A7kbOsyLU", "ztXk1glYC1c"],
                    "Den magiske skolebus": ["rln8CplA2mg", "ikgcgGw6uf8", "WNIDvLs6hng", "ACmN2-OOHFI", "hvmtunuUSGk", "Pxi9_4Iv6W0", "j7n85Vs0J0A", "DfqBv1Dcvvk", "fpy4ffC0Qus", "PnnUPhTpkFo", "Kzcd7ohR9ss", "4WRxizns7OU"],
                    "Team Galaxy": ["pXXHm6oS8ew", "NA8qJEfntbU", "9Py9Cq9MJOc", "x6KwoRTo4sE", "Eq4LmDY1j2c", "OFSTYDXAPKw", "FeVz5jdemXI", "MUqN_SpGVVo", "z2CldCFPvIU", "IrsvR4ntftI", "w8bGkTvX_no", "SCK4z6GvqEc", "KGGNXA-H7o0", "wjDuwyERCeg", "AOAgOXk5Q4U", "ONmiN-TW2wo", "x_EjzAsMbEE", "jxXz4_dCIps", "kO6ZNLtt5EQ", "A2H2GGByYL4", "SaUn0e5HoL0", "zDuM_K3wNkI", "6NTgUlo33Ic", "dwkcoHUhCuE", "BqPIypKCjOY", "iXdAgQJtuCU", "5FmNFmpRgBE", "NNktZWdAaaU", "Ok5tRQ8EUE0", "RTQbvEHHW3M", "dz1wcCzLb9c", "cWbSYLUVuYk", "1MJeVbSAAy0", "umLoHqyFmFE", "FcyzjrXEBaA", "Gv1yrQJJWsI", "Mu0jbRLy5Bo", "7eO7XHpyoPg", "Nn-RStIsR7c", "TtQVg_hIBDg", "DCje-_VYDtk", "gLRkHBfQX0w", "NjtQkbhFg3M", "_hGTgQ9eqK4", "WCIdp7fszzk", "bUW3FrqJaBM", "ez_rRxDdX9w", "6hf95Phk5wk", "kyTGrtwNJrU", "wHqx7mGiAGo", "uDPKEEJQXN4", "oXs3t6tEvQE"],
                    "Martin Mysterie": ["tEYFphJHklM", "_wrYSHg_FSY", "ifzjnPpyvcY", "0Dzzv4q5eUc", "YzGZv3Q3hPI", "-s9uo0xHZjE", "nJzJZeXFSRc", "znuJcTaw9zI", "RHmEbAf5hL0", "qcUoMZ6_OBw", "yC1Rl19e-RU", "Au46kjFDmpY", "yk8Y8m3enWg", "uamX9T-_TV4", "oBPRdkhtqVw", "GYP5M3xh2wA", "67IeBz65roE", "Zam7Wu6NLxM", "eqZOI3F8dAk", "iIbld58p6Bo", "YsleFluh9ks", "i-D1-kCz36U", "NH-M2rLKmoM", "Z5IWK_pou7Y", "n-BFTyB--9Y", "_lbdN9Nj5bs", "0x8FdW6kAcQ", "WQLuaPqEyfs", "kYrQk_wSagE", "bGu0vbsFgLM", "pcMP9VVCGF4", "2vP6eqxz2VI", "TK3DJ5II48E", "YmzwXVl8zYM", "Jl4evC8jKis", "8cZqspiUQmo", "Mrm_XbQBEjI", "kg89vhN4Gy4", "yvpzxRgi_Sk", "_cIPEKWx-qc", "oKW63YnlRaU", "9oPJnaZMt7g", "Fc_NoR8qkVQ", "i-9CsnX3hl8", "FqM4WI6WE90", "pOxFm3cMSd0", "h6P4cLKy8xo", "YUXeOmV69B4", "fVnDY9lJTdM", "cQuOVmTATaM", "sy0TerlqYpQ", "JSRU_kOSTFU", "SPCIIVFlNmo", "gRt6JYWvXaY", "ioSqC03R2cE", "qyU_cZcXYzQ", "a6NCidcjpmo", "hqNctZI88Z0", "IcfO-qRCCcY", "XzLqIovmheo", "Dq_imRYnjQw", "I9ZJSH1vPKA", "JQQVoq3zKjA", "vyfdZy41SWI", "6F4TTaqo5Zo"]
                }
            },
            {
                name: "RK5",
                series: {
                    "Richard Scarrys Travle Verden": ["cM01SH5IYYo", "JCq_hSExlnQ"],
                    "Superman": ["t51Si5XEgxg", "RcJFaH9MQ0E", "4Ygh3a1oipo", "-hVs5ZhFJj8", "Ewn4e_RklpM"],
                    "Kong Arthur": ["AAYUd9BEQu4", "LKNFKFq6LTs", "X736zvAOd1c"],
                    "Trolderi": ["L0uBXAQJFl8", "bo9wIU5k05U", "RvDgiXg41cE", "S-0asq0aldg", "Sa7GdXXGMyA", "dWz5cWNsxfk", "70NnRJ4AiME", "8TH9frVU4yc", "Lm6MEhI9CR4", "D1TJ6rIiE8c", "o8h_pufyly4", "lR5Ze5mMQHk", "lFigeEXk9pI", "jHMnncfmU0M", "8nZ-ELgWFjM", "hVrT-U6pW34", "w8OW2f-guuE", "qbxi1aQR9ug", "7bpKl5JTPWc", "Nq28Hl3eybY", "_T5awqqfdP0", "Q8n8bdTjCMs", "w-RSSrfMa8E", "Lm6F-dB_rnk", "rMXJEVeiKPU", "bmxGoFpCIL8"],
                    "De tre venner og Jerry": ["hr-jNsLgM-w", "dZpMoAQIP-k", "GQBRd2fN-bU", "qHDX722bZMM", "IQkm3Bkxafg", "V8tC4NvwZ5o", "WZAVzyxS-Fo", "SAS2vzZFdtk", "ZhBPNl1GRkk", "NaKLJglaVIY", "GK83Uwexmgk", "nFLBxZ8Luz4", "Y6NUPAU3xNM", "xHZeA0l08Tw", "eNbcMQzF1bE", "cm90J7i2e5Y", "BA5nabt0deQ", "kfK_nrIu3MA"],
                    "Mumitroldene": ["n1fNeNzRrD8", "Ex5_0MaoyGU", "tUb8RuaNpQY", "esaICecdhsQ", "S4p8cfpNgPQ", "SxdY8p9rteA", "HxNdKtu5PJQ", "HVKac1HKT-4", "S5elMq9gyK8", "w_9T3-YK_4s", "D_P0LZF0SLg", "TXZIjE4QCVg", "1uctplf1dBs", "nARFgfHNIjI", "EsuaAZJ_wpI", "mhTkKT2Fyl0", "vIIciBpW_c0", "HxTfc-Y1bso", "HfISRNQnFa4", "lJWNfU8GHa8", "efLp2gQRYao", "V_9D0L18BJo", "t7KRldU8xRQ", "G7VB758yJgw", "NXmhtkY8fCs", "aueFkB11MLQ", "I7w8in3u8Qs", "FTS6cPjS4FE", "Un34Nwkriys", "5JsTxUGebEw", "zTA8kTZxIis", "0aU7NbnJMcI", "HwM7-n9-IdE", "Zi-8YT78vB8", "lLrLVVJ9uU4", "u8tb2vTAWt4", "JSULatqgD8I", "Y2J_DjMKzPE", "NPJJfgaa6Og", "Yj-SL1JbMzg", "yNrIt3W4jtI", "Z8NLHt6vJfs", "GpH7i71m9jI", "ho2HEqs9p08", "4Dnyw1gmsIg", "8W_ovqdSyXc", "SU7Cw0nRJAk", "NkVM-1k8Xgg", "-D4K-9KTi4M", "ZmwNfzFWM9I", "gVa7YD2eDcE", "5oeRVu7gtJ0", "_Jijl_GxP7g", "c1vsNhSzg4Q", "3hPYj0C9iuw", "D7QxdmM9M7o", "6jIQ-4eoz8w", "lgDn3ZmQhL8", "Rq6X7ZRMlDw", "fWe6yJP1JCE", "LQelZWJIKZg", "kLKsFJC3pGg", "qnLyj16aCCE", "Q7hy7FLV_3o", "O3GMMxT_Vos", "10441SRPZEQ", "1CtLQZ13G0g", "yb0cnI8knxg", "0IAIbYp6G1I", "8Y0EIob4Tvw", "6Vp5gadoOsg", "LrAaCh5eesw", "fEIcJWAJkLc", "kB1XDVQqU7s", "XXkMkjLOSsM", "NfK8OyPse1g", "H9cRMGfJpV8", "Hr7D-Xxe3zc"],
                    "Sallies historier": ["8-waX4dkEio", "a7S2RF5WAMQ", "hHO3tovfuA8", "whdGHE-fBJ0", "tBGGRMIAy3Q", "k0zM1mRUgew", "3MpgqVIctVA", "cIdXwVGWCWA", "NFLwvptfwX8", "TYwmwrL0gpc", "DK5-fnh-vs0", "v5cv05XNgYw", "qOQlxiGLeYc"],
                    "Pucca": ["JfusnPJd4s4"],
                    "Sunes verden": ["V8uGAe1GHtE", "ETsqNVhhFYE", "MCRx4WE5MuE", "Kt34ANsdNNs", "KVRmswPP13Y", "GUTkMsZtaXs", "khbE4znEBGs", "1_FZJBvQ3gc", "XGwztjBvFGk", "hyAFfhbzxPs", "U9bCLsLCp0U", "OOE6zrpQBxc", "PNI0I2EHM6E", "Re-4uLLl0oM"],
                    "Lucky Luke": ["TIMm4Axc850"],
                    "Mission eftersidning": ["4MUyHC9H2a0"],
                    "Conrad og Bernhard": ["vU72yrUzhyE", "oO7dBA1kH8Q", "HWymRR4HCxE", "W4ZXuCNd10k", "uTH9t1OeXoU", "yN7ROPbb-pc", "pPLPH2lhxdc", "31BfHsKrOU", "B44I_1FkiqU", "x4hNVMVo1pc", "_i_uVyDIaf0", "JTf_aZ7c6kA", "Avy6yIFs7Qc", "pk2ctkyz7iU", "v5AgqtYT2ok", "I_8Mr6s5ULc", "QBPbe6UKwWQ", "ki9UKW11iJw", "P2Yn32MuNcQ", "OJYH6gLnmDk", "2T5E08c3BEA", "fO-mus4ClxM", "D-5XrJWg-m4", "lp1rjHx_318", "jyxtu029FYg", "z7XaBEVN_LQ", "-tfClde7xOA", "6zL7MOZEURI", "zanqOCSa2kk", "dndwqZUT7vc", "zEmyvKR89xE", "dwN85pYkzdI", "ts77BTFV07I", "0-wZegiWsQ8", "a-0Ltj--gj4"]
                }
            },
            {
                name: "RK6",
                series: {
                    "Casper møder Wendy": ["DJqOCRJX3F8"],
                    "Morten på nye skoleeventyr": ["AXu04cQsztM"],
                    "Bratz - The Movie": ["5FkFnz39OeI"],
                    "Lucky Luke - Dalton Brødrene På Flugt": ["xvV7z46zjjU"],
                    "Lucky Luke og Dalton Brødrene": ["y8XO--oCL6U"],
                    "Lucky Luke - Lovløse i lænker": ["HdDrRITdNn0"],
                    "Lucky Luke & De Lovløse": ["qBaYixkI4SY"],
                    "Lucky Luke: Lange Luke": ["vz2fxBA_0QQ"],
                    "Asterix & hans gæve gallere": ["CZB8A2u3TkY"],
                    "Lucky Luke - Dr Doxey": ["yHq7awMsP9I"],
                    "Tintin: Rackham Den Rødes Skat": ["26jHetaFtjc"],
                    "Tintin: Enhjørningens Hemmelighed": ["hlNWoH7RUHk"],
                    "Lucky Luke i Mississippi": ["7bL3RAu8xf0"],
                    "Tintin: Månen Tur - retur": ["vro7kA2b0i4"],
                    "Dr Jekyll & Mr Hyde": ["SW_BxrS81Ic"],
                    "En Verdensomsejling Under Havet": ["DxfSKDZ5ADQ"],
                    "Kong Salomons Miner": ["Xh_lk3unAoM"],
                    "Klokkeren fra Notre Dame": ["oYCqvsQqFAE"],
                    "Adventures of Robinson Crueso": ["TGyRK1-VjNc"],
                    "Lucky Luke i Daisytown": ["RRuaD1MB6oE"],
                    "Inspektør Gadget": ["8iB2eycMieo"],
                    "Abekongen": ["2SWoxmuxpTU"],
                    "Tintin: Krabben med de gyldne klør": ["oS6ijmVMlbY"],
                    "M.A.S.K": ["2vQX26wRRFE"],
                    "He man": ["hIzDK4nSmcc"],
                    "Lucky Luke overgår sig selv": ["pSHjdb3ZIOY"],
                    "Tintin: Den Sorte Ø": ["GmoujlOwQ38"],
                    "Basserne": ["wp4jbQ4QGhk"],
                    "Asterix: Sejren over Cæsar": ["jUSJhPpO9JY"],
                    "LEGO® Brand LEGO Historien": ["KkOwoVnvqEw"],
                    "Eventyret om den vidunderlige kartoffel": ["r-L71ZNHRps"],
                    "Quark": ["c13xKiEYBtA"],
                    "Immunforsvaret": ["fyHsHvT9H3Y"],
                    "Action Man: X Missions": ["lzoF1vk-2tA"],
                    "Yu-Gi-Oh! - Den Lysende Pyramide": ["OeCU88a0-vM"],
                    "Familien Flintstone: I-Yabba-Dabba-Do!": ["https://www.dailymotion.com/video/x96o9ik"],
                    "Jetsons møder familien Flintstone": ["https://www.dailymotion.com/video/x96o9ii"],
                    "Krammebjørnene: Rejsen til Legelyst": ["VPxW39iY2dg"],
                    "Scooby Doo - Legenden om vampyren": ["https://archive.org/details/scooby-doo-films/11.+Scooby-doo+og+legenden+om+vampyren+(2003).mp4"],
                    "Scooby Doo - Loch Ness uhyret": ["https://archive.org/details/scooby-doo-films/14.+Scooby-Doo+og+Loch+Ness+Uhyret+(2004).mp4"],
                    "Scooby Doo - Pirater i sigte": ["https://archive.org/details/scooby-doo-films/15.+Scooby-Doo!+Pirater+i+Sigte!+(2005).mp4"],
                    "Scooby Doo - Kleopatras forbandelse": ["https://archive.org/details/scooby-doo-films/16.+Scooby-doo+Og+Kleopatras+Forbandelse+(2005).mp4"]
                }
            },
            {
                name: "RK7",
                series: {
                    "Looney Tunes": ["https://dn721902.ca.archive.org/0/items/lny-tuns/E01.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E02.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E03.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E04.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E05.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E06.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E07.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E08.mp4", "https://ia600300.us.archive.org/21/items/lny-tuns/E09.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E10.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E11.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E12.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E13.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E14.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E15.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E16.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E17.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E18.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E19.mp4", "https://dn721902.ca.archive.org/0/items/lny-tuns/E20.mp4"],
                    "Pinky og Brain": ["https://dn710006.ca.archive.org/0/items/pnky-g-bran/Pinky.and.the.Brain.S01E01.Das.Mouse.XviD.mp4", "https://dn710006.ca.archive.org/0/items/pnky-g-bran/Pinky.and.the.Brain.S01E03.Tokyo.Grows.pdtv-dkids.mp4", "https://dn710006.ca.archive.org/0/items/pnky-g-bran/Pinky.and.the.Brain.S01E06.Pinky.%26.the.Fog.pdtv-dkids.mp4", "https://dn710006.ca.archive.org/0/items/pnky-g-bran/Pinky.and.the.Brain.S01E06.Pinky.%26.the.Fog.pdtv-dkids.mp4"],
                    "Tidspatruljen": ["https://ia801306.us.archive.org/0/items/Tidspatruljen/S01E01.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E02.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E03.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E04.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E05.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E06.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E06.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E07.mp4", "https://ia801306.us.archive.org/0/items/Tidspatruljen/S01E08.mp4", "https://ia801306.us.archive.org/0/items/Tidspatruljen/S01E09.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E10.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E11.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E12.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E13.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E14.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S01E15.mp4", "https://ia801306.us.archive.org/0/items/Tidspatruljen/S02E01.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S02E02.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S02E03.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S02E04.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S02E05.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S02E06.mp4", "https://ia801306.us.archive.org/0/items/Tidspatruljen/S02E07.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S02E08.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S02E09.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S02E10.mp4", "https://dn721803.ca.archive.org/0/items/Tidspatruljen/S02E11.mp4"],
                    "Får i storbyen": ["https://ia801004.us.archive.org/12/items/far-i-storbyen/S01E02.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S01E03.mp4", "https://ia601004.us.archive.org/12/items/far-i-storbyen/S01E04.mp4", "https://ia801004.us.archive.org/12/items/far-i-storbyen/S01E05.mp4", "https://ia801004.us.archive.org/12/items/far-i-storbyen/S01E06.mp4", "https://ia801004.us.archive.org/12/items/far-i-storbyen/S01E07.mp4", "https://ia801004.us.archive.org/12/items/far-i-storbyen/S01E08.mp4", "https://ia801004.us.archive.org/12/items/far-i-storbyen/S01E09.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S01E10.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S01E11.mp4", "https://ia801004.us.archive.org/12/items/far-i-storbyen/S01E12.mp4", "https://ia801004.us.archive.org/12/items/far-i-storbyen/S01E13.mp4", "https://ia801004.us.archive.org/12/items/far-i-storbyen/S02E01.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E02.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E03.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E04.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E05.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E06.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E08.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E09.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E10.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E11.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E12.mp4", "https://dn721607.ca.archive.org/0/items/far-i-storbyen/S02E13.mp4"]
                }
            },
            {
                name: "RK8",
                series: {
                    "Kick Buttowski": ["https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S01E13.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S01E15.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S01E16.mp4", "https://ia800101.us.archive.org/29/items/kick-buttowski_202409/S01E17.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S01E20.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S01E20.mp4", "https://ia800101.us.archive.org/29/items/kick-buttowski_202409/S02E01.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E02.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E03.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E04.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E05.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E06.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E07.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E08.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E09.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E11.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E12.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E13.mp4", "https://dn710109.ca.archive.org/0/items/kick-buttowski_202409/S02E14.mp4", "https://ia800101.us.archive.org/29/items/kick-buttowski_202409/S02E15.mp4"],
                    "Brum": ["-OIpR8r8YjM", "HIO6JVQ5sDo"],
                    "Noddy": ["-0fdvvANlP0&t=1s"],
                    "Jackie Chan Adventures": ["https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E01.mp4", "https://ia801503.us.archive.org/32/items/jackie-chan-adventures_20240809/S01E02.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E03.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E04.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E05.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E06.mp4", "https://ia801503.us.archive.org/32/items/jackie-chan-adventures_20240809/S01E07.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E08.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E09.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E11.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E13.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E01.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E02.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E03.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E04.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E05.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E06.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E07.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E08.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E09.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E11.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S01E13.mp4", "https://ia601503.us.archive.org/32/items/jackie-chan-adventures_20240809/S02E01.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E02.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E03.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E04.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E05.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E06.mp4", "https://ia801503.us.archive.org/32/items/jackie-chan-adventures_20240809/S02E07.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E08.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E09.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E10.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E11.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E12.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E15.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E16.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E17.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E18.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E19.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E20.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E21.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E22.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E25.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E26.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E27.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E28.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E29.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E30.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E31.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E32.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E33.mp4", "https://ia801503.us.archive.org/32/items/jackie-chan-adventures_20240809/S02E34.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E35.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E36.mp4", "https://dn721808.ca.archive.org/0/items/jackie-chan-adventures_20240809/S02E37.mp4", "https://ia801503.us.archive.org/32/items/jackie-chan-adventures_20240809/S02E39.mp4"],
                    "Duedrengen": ["GX6zTpSuHko", "6mdGulMapHw", "FIgqbpeRPls", "NohZIaUwdDg"],
                    "Braceface": ["3-8ybymuT7E", "F0GDN2F67D4", "C8Kruj34fQg", "y3iFvC3gF0I", "y3iFvC3gF0I", "-FfxuawrqgU", "VuOOxzdVu_c", "fZB_Q8xyIaU", "1Y_TTXTyoC4", "E8GMFKBm9PM", "V0gI5PWt9Zg", "hCx_F0gpH4g", "t1CiqE-4wYc", "6Y9aVP46L5U", "J_Ji2c0Fs0o", "vxvOSLrBWQU", "wjFgCgxATks", "4SFfjTrPbGs", "4Y9eofemkvE", "vFUFuxVmD4w", "UKcsJj5IaQw", "MAqVD9iCESU", "1I7R4MHCZDo", "Ucrb1q_eTEE", "lvT3cpj4xmM", "ogJwFxIGLPo", "kw2C8vDE-3U", "MaXGpcwgFZo", "eQeZB5oZues", "v9eqFkvqiko", "G9kGCWBEp9g", "R-JWGN1Q8ck"],
                    "Junglebogens Junglebørn": ["https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E01.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E02.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E03.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E04.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E05.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E06.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E07.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E08.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E09.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E10.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E11.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E12.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S01E13.mp4", "https://ia600206.us.archive.org/8/items/junglebogens-jungleborn/S02E01.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S02E02.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S02E03.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S02E04.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S02E05.mp4", "https://ia800206.us.archive.org/8/items/junglebogens-jungleborn/S02E06.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S02E07.mp4", "https://dn710203.ca.archive.org/0/items/junglebogens-jungleborn/S02E08.mp4"],
                    "Aladdin": ["https://dn710209.ca.archive.org/0/items/alddin/S01E01.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E02.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E03.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E04.mp4", "https://ia800302.us.archive.org/7/items/alddin/S01E05.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E06.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E08.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E09.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E10.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E13.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E15.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E16.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E17.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E22.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E23.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E27.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E28.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E29.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E30.mp4", "https://ia800302.us.archive.org/7/items/alddin/S01E31.mp4", "https://ia800302.us.archive.org/7/items/alddin/S01E32.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E37.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E42.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E43.mp4", "https://ia800302.us.archive.org/7/items/alddin/S01E45.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E50.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E56.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E57.mp4", "https://ia800302.us.archive.org/7/items/alddin/S01E58.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E60.mp4", "https://dn710209.ca.archive.org/0/items/alddin/S01E72.mp4"]
                }
            },
            {
                name: "RK9",
                series: {
                    "LazyTown": ["LN8_K5buZwg", "31XYDtzYRkY", "4cp98c3ULmw", "prV1Wju1K7M", "7jsGIhZ9WjE", "8Xs-q9eKucA", "wwqYv_OjclM", "nE0pG1EN6PA", "OkA16barG_E", "MBTfO1GSVuM", "Va2SbvlRg2s", "5NHFI3_eFzw", "mWPw9aR-sx4", "ectq84Wz6yw", "1OOaYXDFJYk", "OnHiQoS5d_4", "BvMwyhsuo7A", "1xyg3DJ9Zv8", "qxNAh8pKeYQ", "WRTPMOQtnNY", "JnoHv37aPE0", "tnCwC84S-MY", "scsvr-ZzGSo", "3yL4XTi-MIs", "GwxEdT5tMJY", "7cpluvA8XFY", "pFUZ6jIl1pM", "ekFtX7mGAT8", "V5so0-icwxo", "q-_ChvYV_eU", "WzUjSQ4iFAk", "wUWVMZVcU1A", "_2wtq3Bknrk", "arecKrv9XS4", "_pRoHpsqnaM", "l1xUO0xfHAg", "-8ooncDyQSc", "KtduWc6xj84", "S3C3rLFGL4U", "0aXAQ0FDslU", "mv3YrcZJgYQ", "T36QBpU1Nfk", "n6gm8o7KnrM", "83NIQh9ANzU", "hAehR_Xj1rc", "Cg-e9ElHeCQ", "NVOudQ2rggo", "ubq8IqymcJ4", "buBUKcZ2MCE", "NlroQpKnBTA", "JL59TpnDwwo", "SeTONRnofG0", "dSkbKCXbd0M", "Rsb_PggXWS4", "i5Lxst5UAa4", "6jxiVI86y5c", "1C8lSzhRaxs", "EubelWaSXhs", "hpqMCT1Zkos", "VmmxsQ6UZXw", "6Yc3Q2daa-o", "eGqE44zuudQ", "s9TJdSgE8Tk", "K6CU25C3cZA", "Ar0QapITYeI", "30zaObDKzr0", "57WHlhAyO-E", "gMpAKA_5Qsg", "pCqlmM46Emw", "bsvJ29XKHEs", "ae9k_UBnoQs", "6oAjGEPS5xg", "wV_D0r-u_Mk", "83P9RjB7LnY", "kTdgAPnN9w8", "Ns3PoMODHrE"],
                    "Shuriken School": ["https://dn721805.ca.archive.org/0/items/shuriken-school/S01E01.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S01E02.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S01E03.mp4", "https://ia800801.us.archive.org/35/items/shuriken-school/S01E04.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S01E05.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S01E06.mp4", "https://ia800801.us.archive.org/35/items/shuriken-school/S01E07.mp4", "https://ia600801.us.archive.org/35/items/shuriken-school/S01E08.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S01E09.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S01E10.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S01E11.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S01E12.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S01E13.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E01.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E03.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E04.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E05.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E06.mp4", "https://ia600801.us.archive.org/35/items/shuriken-school/S02E07.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E08.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E09.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E10.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E11.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E12.mp4", "https://dn721805.ca.archive.org/0/items/shuriken-school/S02E13.mp4"],
                    "Men in black": ["https://dn721904.ca.archive.org/0/items/men-in-black-den-animerede-serie_202408/Men%20in%20Black%20-%20Den%20animerede%20serie%20S01E08.mp4"]
                }
            }
        ];

        const adsCartoon = [
            "l65l2u37hSo", "6QtcQO89DkQ", "bmhZK8eU3kY", "oENF1ixq2l8", "ICEAWwfzFoM",
            "jsntC_3Ln-k", "syFaSMUx2Qg", "CopdbByi2NA", "AbZkkTKM2y4", "ai--2ssHpp4",
            "F5UiuiqxGuU", "r7_bcYbek5I", "yamzBGtQkJw", "MoeTuiFGGuE", "kwJRkoHmoJs",
            "20d5qraCF9I", "4h7KoL5-1Wk", "GcAI7EDU9ys", "-3WG1dKhD6U", "C6-PdGCSZOg",
            "7tZw7FiGzW8", "TP0PtkN7ThM", "iIjkEAc3tT8", "uKgyEQKNqJ8", "dDoW-NBdP_0",
            "VurfV8M2Svc", "MvZQRsHhJIg", "twSJcxuS138", "cDfk7iflyXY", "suF6muRGh14",
            "s_azpILN_Wg", "3ND1mPAdWEc", "4YXNKS9gDyA", "0xjTGxlAGDw", "qc6ugPwtnnw",
            "bAwO4f_fnsA", "JfEwo9JNWoY", "qwVAaVUdyWk", "bXO4bLepFHw", "BhZ-IlcZXGw",
            "hcNCL3bmivE", "qjfoeUNCCJQ", "3F_LkODa_ZQ", "FrLSepuK2uw", "3zXVBPH-33c",
            "5HuWe5cpspw", "yL8haswz7QU", "R44TtSiwXPw", "Uuwc-hE8Mao", "LZFbtzElITA",
            "do4_ZnX5vvk", "c2qmzNqpE_k", "6Y4cd0cSJBw", "4xh9A4dSH_M", "wWETLa6G0ak",
            "AsncQZKdJCA", "gsBasNfXURA", "Z2m0AnYrCa8", "tRdsbpiqI60", "qnEQcdNOqRI",
            "QBdvH42-PdE", "mWeqXr5UiDQ", "wjHUMzd-5wM", "Z_u3vhRKOpA", "corwfKbXuGI",
            "xMsUeFLRWqo", "spmHlVHTgYA", "4Jh2zYzbIoQ", "Z-y-Hjid9wc", "nI-IsoBOx2k",
            "1KZ4b83gZyI", "ox4XFDMbPcs", "bbL3BjEFgJ0", "Td7rNcvMp0g", "XzLt8_x6rHQ",
            "pMiODqMOi-0", "Gk3SeahokGc", "WNGBb7S9_eA", "AbYTkF1tVgo", "zw4Dap1oKK0",
            "https://archive.org/details/spaced-out-premire-ad-cartoon-network-nordic-2002-dansk",
            "JzaBnPKUaYQ", "TEdzQVBvVJM"
        ];

        const adsDisney = ["gHiyQM_RuVA", "QPMr2_ld2yc", "ccG1eJDDzxI", "0AU5VuxdUxA", "6Zv1s7YfFD8", "ZCBhZCmHUnE", "H29WJfiXJS0"];
        const adsFox = ["sL5X6rmVY3I", "rRnFUNX6IWI", "LNjHpwuccXc", "FjncsmnkUyw", "VmgCTA7W6kA", "9zxQccwrn54"];
        const adsJetix = ["aKMJXqhJjaw", "a0_ykhb5m9g", "0eSdyafYgMA", "uICl3DsuLNU", "EFSfN5JX0oI", "6QNrLAL3v6o", "jvgIzUW7T0E", "sgTY_aEtfgE"];

        const adLengths = {};
        let adLengthsLoaded = false;

        // Brightness & Color Logic - MUST be declared before loadState()
        let brightness = 100;
        let saturation = 100;

        let current = 0, on = false, volume = 50, muted = false, adsEnabled = true, player;
        let volTimer;
        let playbackState = {
            videoId: '',
            currentSeries: '',
            currentEpisodeIndex: 0,
            adSequence: [],
            adIndex: 0,
            isPlayingAd: false,
            firstAdAfterPowerOn: false,
            consecutiveErrorCount: 0,
            lastActivity: Date.now() // Track for iOS heartbeat
        };
        let saveInterval;
        let ytReady = false;
        let ytQueue = [];
        // Variables cleaned up
        let seriesHistory = {};
        let channelStates = {};
        let isHovering = false;
        let currentLoadId = 0; // Track concurrent loads to prevent black screens during skipping

        const staticVideo = document.getElementById("staticVideo");
        const powerOffVideo = document.getElementById("powerOffVideo");
        const label = document.getElementById("label");
        const muteIcon = document.getElementById("muteIcon");
        const volumeBar = document.getElementById("volumeBar");
        const volumeContainer = document.getElementById("volumeContainer");
        const volumeNumber = document.getElementById("volumeNumber");
        const clickSound = document.getElementById("clickSound");
        const staticSound = document.getElementById("staticSound");
        const powerOffSound = document.getElementById("powerOffSound");

        // Ensure iOS playsinline attributes are set (critical for iPad)
        if (staticVideo) {
            staticVideo.setAttribute('playsinline', 'true');
            staticVideo.setAttribute('webkit-playsinline', 'true');
            staticVideo.playsInline = true;
        }
        if (powerOffVideo) {
            powerOffVideo.setAttribute('playsinline', 'true');
            powerOffVideo.setAttribute('webkit-playsinline', 'true');
            powerOffVideo.playsInline = true;
        }

        if (window.location.protocol === 'file:') {
            console.warn("App running via file:// protocol. YouTube videos may fail with Error 153.");
            // We don't show OSD yet because the TV is off. 
            // We'll show it when power() is called.
        }

        function loadState() {
            const saved = localStorage.getItem('tvState');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (typeof data === 'object' && data !== null) {
                        // Only load saved channel if it's not the first time ever
                        // Check if there's a "hasUsedTV" flag
                        if (data.hasUsedTV) {
                            current = Number(data.current) || 0;
                        } else {
                            // First time ever, start at channel 1 (index 0)
                            current = 0;
                        }
                        volume = Math.min(100, Math.max(0, Number(data.volume) || 50));
                        muted = Boolean(data.muted);
                        brightness = Number(data.brightness) || 100;
                        saturation = Number(data.saturation) || 100;
                        adsEnabled = data.adsEnabled !== undefined ? Boolean(data.adsEnabled) : true;

                        // Update UI sliders immediately if they exist
                        const bSlider = document.getElementById('brightnessSlider');
                        const sSlider = document.getElementById('saturationSlider');
                        const adToggle = document.getElementById('adToggle');
                        if (bSlider) bSlider.value = brightness;
                        if (sSlider) sSlider.value = saturation;
                        if (adToggle) adToggle.checked = adsEnabled;
                        updateAdLed();

                        if (Array.isArray(data.seriesHistory)) {
                            seriesHistory = data.seriesHistory;
                        }
                        if (data.channelStates && typeof data.channelStates === 'object') {
                            // Only load AD BREAK state, ignore playlists/series to force fresh start
                            channelStates = {};
                            // We could preserve adBreak state if we want persistence of ads across reloads?
                            // User said: "hver gang man kommer ind... skal det være en ny serie".
                            // So we CLEAN SLATE everything related to content order.
                        }
                        // Ignore saved playbackState series/episode to force fresh start
                    }
                } catch (e) {
                    localStorage.removeItem('tvState');
                }
            } else {
                // No saved state at all - definitely first time, start at channel 1 (index 0)
                current = 0;
            }
        }

        function saveState() {
            if (!on) return;
            const state = {
                current,
                volume,
                muted,
                brightness,
                saturation,
                adsEnabled,
                hasUsedTV: true, // Mark that TV has been used at least once
                // Don't save channelStates to disk to ensure random start on reload?
                // Actually user said: "hver gang man kommer ind på den skal det være en ny serie".
                // So let's NOT save channelStates or at least not the playlists.
                // We save volume/channel index though.
            };
            // We purposefully DO NOT save channelStates or playbackState content details anymore 
            // to comply with "fresh start" request.
            localStorage.setItem('tvState', JSON.stringify(state));
        }

        function startAutoSave() {
            stopAutoSave();
            saveInterval = setInterval(saveState, 2000);
        }

        function stopAutoSave() {
            if (saveInterval) {
                clearInterval(saveInterval);
                saveInterval = null;
            }
        }

        function playClick() { clickSound.currentTime = 0; clickSound.play().catch(() => { }); }

        function showStatic(cb) {
            staticVideo.style.display = "block";
            staticVideo.currentTime = 0;
            staticVideo.play().catch(() => { });
            staticSound.currentTime = 0;
            staticSound.volume = 0.2;
            staticSound.play().catch(e => console.log('Static sound error:', e));
            setTimeout(() => {
                staticVideo.pause();
                staticVideo.style.display = "none";
                staticSound.pause();
                staticSound.currentTime = 0;
                cb();
            }, 600);
        }

        function showVolume() {
            volumeBar.style.width = volume + "%";
            volumeNumber.textContent = volume;
            volumeContainer.style.opacity = 1;
            volumeNumber.style.opacity = 1;
            muteIcon.style.opacity = (muted || volume === 0) && on ? 1 : 0;
            clearTimeout(volTimer);
            volTimer = setTimeout(() => {
                volumeContainer.style.opacity = 0;
                volumeNumber.style.opacity = 0;
            }, 1000);
        }

        function whenYTReady(fn) {
            if (ytReady) {
                fn();
            } else {
                ytQueue.push(fn);
            }
        }

        window.onYouTubeIframeAPIReady = function () {
            ytReady = true;
            ytQueue.forEach(fn => fn());
            ytQueue = [];
            renderTVGuide(); // Render guide when API is ready (or just on load)
        };

        // Inject YouTube API script asynchronously ensuring callback is defined first
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        // Fallback render call
        window.addEventListener('load', renderTVGuide);

        // Chicken sound easter egg - click on logo when TV is off
        window.addEventListener('load', () => {
            const tvGuide = document.getElementById('tvGuide');
            const chickenSounds = [
                document.getElementById('chickenSound1'),
                document.getElementById('chickenSound2'),
                document.getElementById('chickenSound3')
            ];

            let lastPlayedIndex = -1; // Track last played sound to avoid repeats

            if (tvGuide && chickenSounds.every(s => s)) {
                tvGuide.addEventListener('click', (e) => {
                    // Don't play if clicking on buttons or interactive elements
                    if (e.target.tagName === 'BUTTON' ||
                        e.target.classList.contains('program-item') ||
                        e.target.closest('button')) {
                        return;
                    }

                    // Only play if TV is off and guide is not collapsed
                    if (!on && !tvGuide.classList.contains('collapsed')) {
                        // Stop all chicken sounds first
                        chickenSounds.forEach(sound => {
                            sound.pause();
                            sound.currentTime = 0;
                        });

                        // Pick a different sound than last time
                        let randomIndex;
                        do {
                            randomIndex = Math.floor(Math.random() * chickenSounds.length);
                        } while (randomIndex === lastPlayedIndex && chickenSounds.length > 1);

                        lastPlayedIndex = randomIndex;
                        const randomSound = chickenSounds[randomIndex];
                        randomSound.volume = 0.6;
                        randomSound.play().catch(() => { });
                    }
                });
            }
        });

        /* --- GUIDE & QUEUE LOGIC --- */

        function renderTVGuide() {
            console.log('renderTVGuide called, TV on:', on, 'channelStates:', channelStates);
            // If TV is off, clear guide
            if (!on) {
                document.getElementById('guide-content').innerHTML = '';
                return;
            }

            if (!sessionState.bannedSeries && typeof loadBans === 'function') loadBans();

            const container = document.getElementById('guide-content');
            console.log('Guide container:', container, 'exists:', !!container);
            const scrollPos = container.scrollTop;
            container.innerHTML = '';

            channels.forEach((ch, index) => {
                const block = document.createElement('div');
                block.className = 'channel-block';

                const title = document.createElement('div');
                title.className = 'channel-title';
                title.style.cursor = 'pointer';
                title.textContent = ch.name;

                // Expansion Toggle
                title.onclick = () => {
                    if (index !== current) {
                        const chKey = `ch${index}`;
                        if (!channelStates[chKey]) channelStates[chKey] = {};
                        channelStates[chKey].manualExpand = !channelStates[chKey].manualExpand;
                        renderTVGuide();
                    }
                };
                block.appendChild(title);

                const chKey = `ch${index}`;
                const isCurrent = (index === current);
                const isManualExpanded = channelStates[chKey] && channelStates[chKey].manualExpand;

                // COLLAPSE LOGIC
                if (!isCurrent && !isManualExpanded) {
                    container.appendChild(block);
                    return;
                }

                let rawList = [];
                if (channelStates[chKey] && channelStates[chKey].playlist && channelStates[chKey].playlist.length > 0) {
                    rawList = channelStates[chKey].playlist;
                }

                // AD MERGING LOGIC
                let displayList = [];
                for (let i = 0; i < rawList.length; i++) {
                    const item = rawList[i];
                    const seriesName = getSeriesName(item);
                    const episodeInfo = getEpisodeInfo(item);

                    if (seriesName === "REKLAMEPAUSE") {
                        // Filter out ads if disabled
                        if (!adsEnabled) continue;

                        // If this is REKLAMEPAUSE and the *previous* stored item was ALSO REKLAMEPAUSE, skip
                        if (displayList.length > 0 && displayList[displayList.length - 1].seriesName === "REKLAMEPAUSE") {
                            continue; // Merge/Skip
                        }
                    }
                    displayList.push({ seriesName: seriesName, episodeInfo: episodeInfo, originalIndex: i });
                }

                // Render Slots (Limit to 5 visual items)
                let renderedCount = 0;
                for (let i = 0; i < displayList.length; i++) {
                    if (renderedCount >= 5) break;

                    const item = displayList[i];
                    const seriesName = item.seriesName;
                    const episodeInfo = item.episodeInfo;
                    const trueIndex = item.originalIndex;

                    const slot = document.createElement('div');
                    slot.className = 'program-slot';

                    const badgeEl = document.createElement('div');
                    badgeEl.className = 'program-badge';

                    if (current === index && on) {
                        // "NU" is always the first VISIBLE item
                        if (renderedCount === 0) badgeEl.innerHTML = `<span style="color:#d84315">NU:</span>`;
                        else if (renderedCount === 1) badgeEl.innerHTML = `NÆSTE:`;
                    }
                    slot.appendChild(badgeEl);

                    const contentEl = document.createElement('div');
                    contentEl.className = 'program-content';

                    // Display series name with episode info if available
                    const displayText = episodeInfo ? `${seriesName}${episodeInfo}` : seriesName;
                    contentEl.textContent = displayText;

                    if (seriesName === "REKLAMEPAUSE") {
                        contentEl.classList.add('ad-break');
                        contentEl.innerHTML = `<span style="color:#555">[ REKLAMER ]</span>`;
                    } else {
                        // Pass trueIndex to remove the correct item from the underlying list
                        contentEl.onclick = function () { removeEpisode(seriesName, trueIndex, index, this); };
                    }

                    slot.appendChild(contentEl);
                    block.appendChild(slot);

                    renderedCount++;
                }



                container.appendChild(block);
            });

            // RESTORE SCROLL
            container.scrollTop = scrollPos;
        }

        function forcePlaySeries(chIndex, seriesName) {
            // Deprecated interaction
        }

        let playerType = null; // 'youtube', 'dailymotion', or 'video'
        let dmPlayer = null; // Dailymotion player instance
        let ytPlayer = null; // YouTube player instance
        let videoElement = null; // Generic video element

        function transformOneDriveUrl(url) {
            // Basic check for OneDrive API links
            if (url.includes('api.onedrive.com')) {
                if (!url.includes('?download=1')) {
                    return url + '?download=1';
                }
            }

            // Handle new 1drv.ms links - PREVENT API CONVERSION
            if (url.includes('1drv.ms')) {
                if (!url.includes('download=1')) {
                    const separator = url.includes('?') ? '&' : '?';
                    return url + separator + 'download=1';
                }
                return url;
            }

            // Fallback: If it's not a known format, return as is
            if (!url.includes('onedrive.live.com')) return url;

            try {
                let shareId = '';
                const sMatch = url.match(/s!([a-zA-Z0-9_-]+)/);
                if (sMatch) {
                    shareId = 's!' + sMatch[1];
                } else if (url.includes('redeem=')) {
                    const params = new URLSearchParams(url.split('?')[1]);
                    const redeem = params.get('redeem');
                    if (redeem) {
                        const decoded = atob(redeem.replace(/-/g, '+').replace(/_/g, '/'));
                        const dsMatch = decoded.match(/s!([a-zA-Z0-9_-]+)/);
                        if (dsMatch) shareId = 's!' + dsMatch[1];
                    }
                }
                if (shareId) return `https://api.onedrive.com/v1.0/shares/${shareId}/root/content?download=1`;
            } catch (e) {
                console.error("OneDrive logic error:", e);
            }
            return url;
        }

        // iOS Detection
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        const isInAppBrowser = (navigator.userAgent.includes('Instagram') ||
            navigator.userAgent.includes('FBAN') ||
            navigator.userAgent.includes('FBAV') ||
            navigator.userAgent.includes('Line/')) && isIOS; // Only flag in-app if also iOS
        const shouldStayMuted = isIOS || isInAppBrowser;

        // Debug log for testing
        console.log('Platform detection:', { isIOS, isInAppBrowser, shouldStayMuted, userAgent: navigator.userAgent });

        function createPlayer({ videoId, startAt = 0, loadId = currentLoadId, onReadyCb, onStateChangeCb, onEnded, onError }) {
            // Detect platform
            // Dailymotion detection: support both dm: prefix and full URLs
            const isDailymotion = videoId.startsWith('dm:') || videoId.includes('dailymotion.com/video/');
            const isOneDrive = videoId.includes('1drv.ms') || videoId.includes('onedrive.live.com/embed');
            // Archive.org handling: /details/ WITH file.mp4 = direct video, WITHOUT = iframe
            const isArchiveDetails = videoId.includes('archive.org/details/');
            const isArchiveWithFile = isArchiveDetails && /\/[^\/]+\.mp4/.test(videoId);
            const isArchiveWithoutFile = isArchiveDetails && !isArchiveWithFile;

            const isIframe = videoId.startsWith('iframe:') || videoId.startsWith('embed:') || videoId.includes('/embed') || isOneDrive || isArchiveWithoutFile;
            // If it's an iframe link, it's NOT a direct video file
            // IMPORTANT: archive.org/details/ links with .mp4 will be converted to /download/ and treated as direct videos
            const isDirectVideo = !isIframe && !isDailymotion && (videoId.startsWith('http') || videoId.startsWith('https')) && (videoId.includes('.mp4') || videoId.includes('.webm') || videoId.includes('.ogg') || isArchiveWithFile);

            let cleanId = videoId;
            // Extract Dailymotion video ID from either dm: prefix or full URL
            if (isDailymotion) {
                if (videoId.startsWith('dm:')) {
                    cleanId = videoId.substring(3);
                } else {
                    // Extract video ID from URL like: https://www.dailymotion.com/video/x96o9ik
                    const match = videoId.match(/dailymotion\.com\/video\/([a-zA-Z0-9]+)/);
                    if (match && match[1]) {
                        cleanId = match[1];
                    }
                }
            }
            if (isIframe && (videoId.startsWith('iframe:') || videoId.startsWith('embed:'))) cleanId = videoId.substring(7);

            // Transform OneDrive share links to embed URLs
            if (isOneDrive && videoId.includes('1drv.ms')) {
                // OneDrive share links need to use the embed view
                // Just add embed=1 parameter and action=embedview
                const separator = videoId.includes('?') ? '&' : '?';
                cleanId = videoId + separator + 'embed=1&action=embedview';
            }

            if (isDirectVideo) {
                playerType = 'video';
            } else if (isDailymotion) {
                playerType = 'dailymotion';
            } else if (isIframe) {
                playerType = 'iframe';
            } else {
                playerType = 'youtube';
            }

            if (isDirectVideo) {
                // === GENERIC VIDEO PLAYER ===
                playerType = 'video';
                const container = document.getElementById('player');
                container.innerHTML = '';

                videoElement = document.createElement('video');
                videoElement.autoplay = true;
                videoElement.muted = true; // Required for iOS autoplay
                videoElement.playsInline = true;
                videoElement.setAttribute('playsinline', 'true'); // iOS attribute
                videoElement.setAttribute('webkit-playsinline', 'true'); // Older iOS versions
                videoElement.style.width = '100%';
                videoElement.style.height = '100%';
                videoElement.style.objectFit = 'cover';

                container.appendChild(videoElement);
                player = createPlayerWrapper();

                videoElement.onloadedmetadata = () => {
                    if (startAt > 0) videoElement.currentTime = startAt;
                    if (onReadyCb) onReadyCb({ target: player });
                };

                videoElement.onplay = () => {
                    // Unmute after playback starts if not muted
                    if (!muted && volume > 0) {
                        setTimeout(() => {
                            videoElement.muted = false;
                            videoElement.volume = volume / 100;
                            console.log('Unmuted video element');
                        }, 500);
                    }
                    if (onStateChangeCb) onStateChangeCb({ data: 1 }); // 1 = PLAYING
                };

                videoElement.onpause = () => {
                    // Auto-retry to keep video playing (iOS often pauses for buffering)
                    if (!videoElement.ended) {
                        setTimeout(() => {
                            if (videoElement && videoElement.paused && !videoElement.ended) {
                                videoElement.play().catch(e => console.log("Pause-retry:", e));
                            }
                        }, 100);
                    }
                    if (onStateChangeCb) onStateChangeCb({ data: 2 }); // 2 = PAUSED
                };



                videoElement.onended = () => {
                    if (onStateChangeCb) onStateChangeCb({ data: 0 }); // 0 = ENDED
                };

                videoElement.onerror = (e) => {
                    if (onError) onError(e);
                    else {
                        console.error("Generic Video Error, skipping:", cleanId);
                        // updateOSD("VIDEO FEJL - SPRINGER OVER", true); // Visual feedback - Disabled to prevent error messages during channel switch
                        addToPlayedHistory(cleanId);

                        setTimeout(() => {
                            // Only skip if this load is still active
                            if (loadId === currentLoadId) {
                                if (channelStates[`ch${current}`]) channelStates[`ch${current}`].currentVideo = null;
                                loadChannel(false, false, true, true);
                            }
                        }, 100); // Super fast skip
                    }
                };

                // Set src AFTER listeners are attached to catch immediate errors
                videoElement.src = transformOneDriveUrl(videoId);

                // CRITICAL iOS FIX: Call play() immediately to trigger loading
                // On iOS, play() must be called to start the loading process
                const playPromise = videoElement.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log('Initial play blocked, will retry on loadedmetadata:', error);
                        // Retry when metadata is loaded
                        videoElement.addEventListener('loadedmetadata', function onLoaded() {
                            videoElement.removeEventListener('loadedmetadata', onLoaded);
                            videoElement.play().catch(e => console.log('Retry play blocked:', e));
                        }, { once: true });
                    });
                }

            } else if (isDailymotion) {
                // === DAILYMOTION PLAYER ===
                if (!window.dailymotion) {
                    console.error('Dailymotion SDK not loaded');
                    return;
                }

                playerType = 'dailymotion';

                if (dmPlayer) {
                    // IMPORTANT: Capture loadId in the callback
                    const currentLoad = loadId;
                    // Load new video
                    dmPlayer.load({ video: cleanId, params: { 'start-time': startAt }, autoplay: true });
                    // Ensure we re-poll for new duration
                    dmCachedDuration = 0;
                    // Explicitly update player reference
                    player = createPlayerWrapper();
                    if (onReadyCb) {
                        // Simulate ready callback
                        setTimeout(() => {
                            if (currentLoad === currentLoadId) onReadyCb({ target: player });
                        }, 100);
                    }
                } else {
                    // Capture loadId for the Promise callback
                    const currentLoad = loadId;
                    // Create new Dailymotion player (returns a Promise!)
                    window.dailymotion.createPlayer('player', {
                        video: cleanId,
                        params: {
                            playsinline: 1,
                            autoplay: 1,
                            controls: 0,
                            'start-time': startAt,
                            mute: 0, // Allow unmuting for audio playback
                            'ui-theme': 'dark',
                            'aspect-ratio': 'none'
                        }
                    }).then((dmInstance) => {
                        if (currentLoad !== currentLoadId) return;
                        dmPlayer = dmInstance;

                        // Explicitly call play for iOS
                        if (isIOS) {
                            dmPlayer.play().catch(e => console.log("DM Initial play catch:", e));
                        }

                        // Forcibly fix Dailymotion wrapper heights using MutationObserver
                        const playerDiv = document.getElementById('player');
                        const fixDailyMotionStyles = () => {
                            if (playerDiv.style.paddingBottom) {
                                playerDiv.style.setProperty('padding-bottom', '0', 'important');
                            }
                            playerDiv.querySelectorAll('div, iframe').forEach(el => {
                                if (el.style.height && el.style.height !== '100%') {
                                    el.style.setProperty('height', '100%', 'important');
                                    el.style.setProperty('max-height', '100%', 'important');
                                    el.style.setProperty('min-height', 'auto', 'important');
                                }
                            });
                        };

                        fixDailyMotionStyles();
                        const observer = new MutationObserver(fixDailyMotionStyles);
                        observer.observe(playerDiv, { childList: true, subtree: true, attributes: true, attributeFilter: ['style'] });

                        // Setup event listeners
                        dmPlayer.on('videochange', () => {
                            if (currentLoad === currentLoadId && onReadyCb) onReadyCb({ target: createPlayerWrapper() });
                        });

                        dmPlayer.on('playing', () => {
                            if (currentLoad !== currentLoadId) return;
                            dmInternalState = 1; // PLAYING

                            // Unmute after playback starts if not muted
                            if (!muted && volume > 0) {
                                setTimeout(() => {
                                    dmPlayer.setMuted(false);
                                    dmPlayer.setVolume(volume / 100);
                                    console.log('Unmuted Dailymotion player');
                                }, 500);
                            }
                        });

                        dmPlayer.on('paused', () => {
                            if (currentLoad !== currentLoadId) return;
                            dmInternalState = 2; // PAUSED
                            // NEVER auto-retry on iOS - causes infinite buffering loop
                            if (!isIOS) {
                                dmPlayer.ended.then(isEnded => {
                                    if (!isEnded) {
                                        setTimeout(() => {
                                            if (currentLoad === currentLoadId && dmPlayer) {
                                                dmPlayer.play().catch(() => { });
                                            }
                                        }, 150);
                                    }
                                }).catch(() => { });
                            }
                            if (onStateChangeCb) onStateChangeCb({ data: 2 });
                        });

                        dmPlayer.on('video_end', () => {
                            if (currentLoad !== currentLoadId) return;
                            dmInternalState = 0; // ENDED
                            if (onStateChangeCb) onStateChangeCb({ data: 0 });
                        });

                        // FORCE SEEK if we are resuming (live simulation)
                        if (startAt > 0) {
                            dmPlayer.currentTime.then(t => {
                                if (Math.abs(t - startAt) > 3) {
                                    console.log(`DM Forcing seek to ${startAt} (current: ${t})`);
                                    dmPlayer.seek(startAt);
                                }
                            });
                        }

                        if (onStateChangeCb) {
                            onStateChangeCb({ data: 1 }); // 1 = PLAYING (same as YT)
                        }

                        // Initial ready callback
                        if (onReadyCb) {
                            setTimeout(() => {
                                if (currentLoad === currentLoadId) onReadyCb({ target: createPlayerWrapper() });
                            }, 100);
                        }

                        // IMPORTANT: Create wrapper AFTER player exists
                        player = createPlayerWrapper();
                    }).catch((error) => {
                        console.error('Dailymotion player creation failed:', error);
                    });
                }

            } else if (playerType === 'iframe') {
                // === IFRAME PLAYER ===
                console.log("Initializing Iframe Player for:", cleanId);

                let finalSrc = cleanId;
                // Inject startAt if provided (for random start)
                if (startAt > 0) {
                    if (finalSrc.includes('start=')) {
                        finalSrc = finalSrc.replace(/start=\d+/, 'start=' + Math.floor(startAt));
                    } else {
                        const sep = finalSrc.includes('?') ? '&' : '?';
                        finalSrc += sep + 'start=' + Math.floor(startAt);
                    }
                }

                // Handle Archive.org /details/ links - convert to /download/ format for direct streaming
                // Archive.org embed players DON'T autoplay - they require manual click
                // But direct download URLs work with HTML5 video element and autoplay properly
                if (finalSrc.includes('archive.org/details/')) {
                    // Extract item ID and filename from URL
                    // Example: https://archive.org/details/motormus-fra-mars-1993/S01E02.mp4
                    // Should become: https://archive.org/download/motormus-fra-mars-1993/S01E02.mp4
                    // Example: https://archive.org/details/hamtaro-episode-1-danish (no file)
                    // Should remain as /embed/ for iframe player

                    const detailsMatch = finalSrc.match(/archive\.org\/details\/([^\/\?]+)(\/([^\/\?]+))?/);
                    if (detailsMatch) {
                        const itemId = detailsMatch[1];
                        const filename = detailsMatch[3]; // May be undefined
                        const baseUrl = finalSrc.substring(0, finalSrc.indexOf('/details/'));

                        if (filename && filename.endsWith('.mp4')) {
                            // Has a specific file - use direct download
                            finalSrc = baseUrl + '/download/' + itemId + '/' + filename;
                            console.log('Converted archive.org to direct download:', finalSrc);
                        } else {
                            // No specific file - use embed player (will require manual click)
                            finalSrc = baseUrl + '/embed/' + itemId;
                            console.log('Converted archive.org to embed (no direct file):', finalSrc);
                        }
                    }
                }

                // Handle Archive.org mute parameter
                // iOS MUST be muted to prevent infinite buffering
                // ALWAYS mute archive.org on iOS, regardless of user settings
                if (finalSrc.includes('archive.org')) {
                    if (isIOS) {
                        // Force muted on iOS to prevent buffering issues
                        if (!finalSrc.includes('muted=1')) {
                            const sep = finalSrc.includes('?') ? '&' : '?';
                            finalSrc += sep + 'muted=1';
                        }
                    } else if (muted || volume === 0) {
                        // Only mute on desktop if user wants it muted
                        if (!finalSrc.includes('muted=1')) {
                            const sep = finalSrc.includes('?') ? '&' : '?';
                            finalSrc += sep + 'muted=1';
                        }
                    }
                }

                // Add cache-busting timestamp for archive.org to force autoplay on reload
                // Browsers block autoplay on iframe reload - timestamp makes it a "new" request
                if (finalSrc.includes('archive.org')) {
                    const sep = finalSrc.includes('?') ? '&' : '?';
                    finalSrc += sep + 't=' + Date.now();
                }

                // Create iframe element
                const container = document.getElementById('player');
                container.innerHTML = '';

                const iframe = document.createElement('iframe');
                iframe.src = finalSrc;
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.allow = 'autoplay; encrypted-media; gyroscope; picture-in-picture; fullscreen';
                iframe.allowFullscreen = true;
                // iOS-specific attributes for autoplay
                iframe.setAttribute('playsinline', 'true');
                iframe.setAttribute('webkit-playsinline', 'true');

                container.appendChild(iframe);

                // Mock player interface for iframes
                player = {
                    playVideo: () => { },
                    pauseVideo: () => { },
                    stopVideo: () => { },
                    setVolume: (v) => { },
                    mute: () => { },
                    unMute: () => { },
                    getDuration: () => 0,
                    seekTo: (s) => { },
                    getCurrentTime: () => Promise.resolve(0)
                };

                // Trigger onReady immediately since iframes don't have an API to tell us
                if (onReadyCb) {
                    setTimeout(() => {
                        onReadyCb({ target: player });
                    }, 500);
                }

                // Create wrapper immediately which handles DOM creation
                player = createPlayerWrapper();

                // Fire ready logic if needed
                if (onReadyCb) {
                    setTimeout(() => {
                        if (loadId === currentLoadId) onReadyCb({ target: player });
                    }, 100);
                }


            } else {
                // === YOUTUBE PLAYER ===
                if (!window.YT || !window.YT.Player) {
                    console.error('YT.Player not available');
                    return;
                }

                playerType = 'youtube';

                if (ytPlayer) {
                    const currentLoad = loadId;
                    // CRITICAL: Update callback references on the player object
                    ytPlayer.currentContext = {
                        loadId: loadId,
                        onReadyCb: onReadyCb,
                        onStateChangeCb: onStateChangeCb,
                        onError: onError,
                        onEnded: onEnded
                    };

                    // Reuse existing YouTube player
                    ytPlayer.loadVideoById({ videoId: cleanId, startSeconds: Math.floor(startAt) });
                    if (onReadyCb) {
                        if (currentLoad === currentLoadId) onReadyCb({ target: player });
                    }
                } else {
                    // Create new YouTube player
                    const playerVars = {
                        playsinline: 1,
                        autoplay: 1,
                        controls: 0,
                        rel: 0,
                        start: Math.floor(startAt),
                        enablejsapi: 1,
                        mute: 1,
                        modestbranding: 1,
                        iv_load_policy: 3,
                        fs: 0,
                        disablekb: 1,
                        cc_load_policy: 0
                    };

                    // Only add origin if NOT on file protocol
                    if (window.location.protocol !== 'file:') {
                        playerVars.origin = window.location.origin;
                    }

                    ytPlayer = new window.YT.Player("player", {
                        host: 'https://www.youtube.com',
                        videoId: cleanId,
                        playerVars: playerVars,
                        events: {
                            onReady: (e) => {
                                // Force highest quality
                                if (e.target.setPlaybackQuality) e.target.setPlaybackQuality("hd1080");

                                const ctx = (ytPlayer && ytPlayer.currentContext) || { loadId, onReadyCb };
                                if (ctx.loadId !== currentLoadId) return;

                                playbackState.consecutiveErrorCount = 0;
                                player = createPlayerWrapper();

                                // CRITICAL iOS FIX: Explicitly call playVideo on iOS
                                // Even with autoplay=1, iOS needs explicit play() to start
                                if (e.target.playVideo) {
                                    e.target.playVideo();
                                }

                                if (ctx.onReadyCb) ctx.onReadyCb({ target: player });
                            },
                            onStateChange: (e) => {
                                const ctx = (ytPlayer && ytPlayer.currentContext) || { loadId, onStateChangeCb };
                                if (ctx.loadId === currentLoadId) {
                                    if (window.YT && e.data === window.YT.PlayerState.PLAYING) {
                                        playbackState.consecutiveErrorCount = 0;
                                        // NEVER unmute on iOS - it will stop playback
                                        if (!muted && volume > 0 && !isIOS) {
                                            setTimeout(() => {
                                                if (ytPlayer) {
                                                    ytPlayer.unMute();
                                                    ytPlayer.setVolume(volume);
                                                    console.log('Unmuted YouTube player');
                                                }
                                            }, 500);
                                        }
                                    }

                                    // Auto-retry on pause to keep video playing
                                    if (window.YT && e.data === window.YT.PlayerState.PAUSED) {
                                        if (ytPlayer && ytPlayer.getPlayerState) {
                                            const state = ytPlayer.getPlayerState();
                                            const duration = ytPlayer.getDuration();
                                            const currentTime = ytPlayer.getCurrentTime();

                                            if (state === window.YT.PlayerState.PAUSED && duration > 0 && currentTime < duration - 1) {
                                                setTimeout(() => {
                                                    if (ctx.loadId === currentLoadId && ytPlayer && ytPlayer.playVideo) {
                                                        ytPlayer.playVideo();
                                                    }
                                                }, 150);
                                            }
                                        }
                                    }

                                    if (ctx.onStateChangeCb) ctx.onStateChangeCb(e);
                                }
                            },
                            onError: (e) => {
                                const ctx = (ytPlayer && ytPlayer.currentContext) || { loadId, onError };
                                if (ctx.loadId !== currentLoadId) return;
                                console.error("YouTube Player Error:", e.data, " Video:", cleanId);

                                playbackState.consecutiveErrorCount++;
                                // updateOSD(`FEJL ${e.data || ''} (${playbackState.consecutiveErrorCount})`, true); // Disabled to prevent error messages during channel switch
                                addToPlayedHistory(cleanId);

                                if (playbackState.consecutiveErrorCount >= 5) {
                                    if (window.location.protocol === 'file:') {
                                        updateOSD("Brug en lokal server (localhost)", true);
                                        document.getElementById('error153Overlay').style.display = 'flex';
                                    } else {
                                        updateOSD("FOR MANGE FEJL - STOPPER", true);
                                    }
                                    showStatic(() => { });
                                    return;
                                }

                                if (ctx.onError) {
                                    ctx.onError(e);
                                } else {
                                    setTimeout(() => {
                                        if (ctx.loadId === currentLoadId) {
                                            if (channelStates[`ch${current}`]) channelStates[`ch${current}`].currentVideo = null;
                                            loadChannel(false, false, true, true);
                                        }
                                    }, 800);
                                }
                            }
                        }
                    });

                    // Initialize currentContext for first load
                    ytPlayer.currentContext = {
                        loadId: loadId,
                        onReadyCb: onReadyCb,
                        onStateChangeCb: onStateChangeCb,
                        onError: onError,
                        onEnded: onEnded
                    };
                }

                // Update wrapper reference
                player = createPlayerWrapper();
            }
        }

        // Unified player wrapper (normalizes both APIs)
        let dmCachedTime = 0;
        let dmCachedDuration = 0;
        let dmUpdateInterval = null;
        let dmInternalState = -1; // -1: unstarted, 0: ended, 1: playing, 2: paused, 3: buffering

        function createPlayerWrapper() {
            if (playerType === 'video') {
                return {
                    _isVideo: true,
                    getCurrentTime: () => videoElement.currentTime,
                    getDuration: () => videoElement.duration,
                    seekTo: (seconds) => { videoElement.currentTime = seconds; },
                    setVolume: (vol) => { videoElement.volume = vol / 100; },
                    mute: () => { videoElement.muted = true; },
                    unMute: () => { videoElement.muted = false; },
                    playVideo: () => { videoElement.play(); },
                    pauseVideo: () => { videoElement.pause(); },
                    loadVideoById: (opts) => {
                        let src = opts.videoId;

                        // Convert archive.org /details/ to /download/ for direct streaming
                        if (src.includes('archive.org/details/')) {
                            const detailsMatch = src.match(/archive\.org\/details\/([^\/\?]+)(\/([^\/\?]+))?/);
                            if (detailsMatch && detailsMatch[3] && detailsMatch[3].endsWith('.mp4')) {
                                const itemId = detailsMatch[1];
                                const filename = detailsMatch[3];
                                const baseUrl = src.substring(0, src.indexOf('/details/'));
                                src = baseUrl + '/download/' + itemId + '/' + filename;
                                console.log('Converted archive.org to direct download for video element:', src);
                            }
                        }

                        videoElement.src = src;
                        videoElement.currentTime = opts.startSeconds || 0;
                        videoElement.play().catch(e => console.log('Video play error:', e));
                    },
                    getPlayerState: () => {
                        if (videoElement.paused) return 2; // PAUSED
                        if (videoElement.ended) return 0; // ENDED
                        return 1; // PLAYING
                    },
                    destroy: () => {
                        if (videoElement) {
                            videoElement.pause();
                            videoElement.src = "";
                            videoElement.load();
                            const container = document.getElementById('player');
                            if (container) container.innerHTML = '';
                        }
                    }
                };
            } else if (playerType === 'iframe') {
                // Wrapper for specialized Iframe players (like generic/Hamtaro)
                return {
                    _isIframe: true,
                    getCurrentTime: () => 0,
                    getDuration: () => 0,
                    seekTo: (s) => { },
                    setVolume: (v) => { },
                    mute: () => { },
                    unMute: () => { },
                    playVideo: () => { },
                    pauseVideo: () => {
                        // Best effort to stop playback: clear invalid sources or remove
                        const container = document.getElementById('player');
                        if (container) container.innerHTML = '';
                    },
                    destroy: () => {
                        const container = document.getElementById('player');
                        if (container) container.innerHTML = '';
                    }
                };
            } else if (playerType === 'dailymotion') {
                // Polling for position updates (DM SDK doesn't have a perfect progress event stream)
                if (dmUpdateInterval) clearInterval(dmUpdateInterval);
                dmUpdateInterval = setInterval(() => {
                    if (dmPlayer) {
                        dmPlayer.currentTime.then(t => { dmCachedTime = t; });
                        dmPlayer.duration.then(d => { dmCachedDuration = d; });
                    }
                }, 200); // Update every 200ms

                return {
                    _isDailymotion: true,
                    getCurrentTime: () => {
                        return dmCachedTime; // Return cached value synchronously
                    },
                    getDuration: () => {
                        return dmCachedDuration; // Return cached value synchronously
                    },
                    seekTo: (seconds, allowSeekAhead) => {
                        dmPlayer.seek(seconds);
                        dmCachedTime = seconds; // Update cache immediately
                    },
                    setVolume: (vol) => {
                        dmPlayer.setVolume(vol / 100); // DM uses 0-1, YT uses 0-100
                    },
                    mute: () => {
                        dmPlayer.setMuted(true);
                    },
                    unMute: () => {
                        dmPlayer.setMuted(false);
                    },
                    playVideo: () => {
                        dmPlayer.play();
                    },
                    pauseVideo: () => {
                        dmPlayer.pause();
                    },
                    loadVideoById: (opts) => {
                        const vid = opts.videoId.startsWith('dm:') ? opts.videoId.substring(3) : opts.videoId;
                        dmPlayer.load({ video: vid, startTime: opts.startSeconds || 0, autoplay: true });
                    },
                    getPlayerState: () => {
                        return dmInternalState;
                    },
                    destroy: () => {
                        if (dmUpdateInterval) clearInterval(dmUpdateInterval);
                        dmUpdateInterval = null;
                        if (dmPlayer) {
                            dmPlayer.pause();
                            // No explicit destroy in DM SDK v2 easily accessible like YT, 
                            // but we can clear the iframe to be sure
                            const container = document.getElementById('player');
                            if (container) container.innerHTML = '';
                        }
                    }
                };

            } else if (playerType === 'iframe') {
                return {
                    _isIframe: true,
                    playVideo: () => {
                        // Do not reload iframe - causes infinite loop on iOS
                        // Autoplay is handled by URL parameters
                    },
                    pauseVideo: () => { },
                    mute: () => { },
                    unMute: () => { },
                    setVolume: (v) => { },
                    seekTo: (s) => { },
                    getDuration: () => 0,
                    getCurrentTime: () => 0,
                    destroy: () => {
                        const container = document.getElementById('player');
                        if (container) container.innerHTML = '';
                    }
                };
            } else {
                // Clear DM interval if switching to YouTube
                if (dmUpdateInterval) {
                    clearInterval(dmUpdateInterval);
                    dmUpdateInterval = null;
                }
                // Return YouTube player instance directly
                return ytPlayer;
            }
        }

        function isLongAd(adId) {
            const saved = localStorage.getItem('adLengths');
            if (saved) {
                try {
                    const lengths = JSON.parse(saved);
                    if (lengths[adId]) {
                        return lengths[adId] > 30;
                    }
                } catch (e) { }
            }
            return Math.random() > 0.5;
        }

        function saveAdLength(adId, duration) {
            const saved = localStorage.getItem('adLengths');
            let lengths = {};
            if (saved) {
                try {
                    lengths = JSON.parse(saved);
                } catch (e) { }
            }
            lengths[adId] = duration;
            localStorage.setItem('adLengths', JSON.stringify(lengths));
        }

        function createAdSequence() {
            // Rules: Min 2 ads, Max 4 ads.
            const patterns = [
                { long: 1, short: 1 }, // 2 ads
                { long: 0, short: 2 }, // 2 ads
                { long: 2, short: 0 }, // 2 ads
                { long: 1, short: 2 }, // 3 ads
                { long: 0, short: 3 }, // 3 ads
                { long: 2, short: 1 }, // 3 ads
                { long: 1, short: 3 }, // 4 ads
                { long: 0, short: 4 }, // 4 ads
                { long: 2, short: 2 }  // 4 ads
            ];

            const pattern = patterns[Math.floor(Math.random() * patterns.length)];
            const longAds = [];
            const shortAds = [];

            let adSource = adsCartoon;
            const chName = channels[current].name;

            if (chName === "RK2") adSource = adsDisney;
            else if (chName === "RK3") adSource = adsFox;
            else if (chName === "RK4") adSource = adsJetix;

            // Unique Filter: Deduplicate the source array just in case
            adSource = [...new Set(adSource)];

            // HISTORY FILTER: Prevent recently played ads
            const adHistory = getAdHistory(chName);
            let availableAds = adSource.filter(id => !adHistory.includes(id));

            // If we filtered out too many and can't fill a decent block, reset/relax
            // We need at least enough to pick ANY pattern (min 2)
            if (availableAds.length < 2) {
                // Soft reset: Allow reusing oldest from history, or just use all source
                availableAds = adSource;
            }

            // Distribute available into Long/Short
            for (const adId of availableAds) {
                if (isLongAd(adId)) {
                    longAds.push(adId);
                } else {
                    shortAds.push(adId);
                }
            }

            longAds.sort(() => Math.random() - 0.5);
            shortAds.sort(() => Math.random() - 0.5);

            const seq = [];
            const totalRequested = pattern.long + pattern.short;

            // If ad source is very small, just pick what we can
            if (availableAds.length < totalRequested) {
                let pool = [...availableAds].sort(() => Math.random() - 0.5);
                // Record these chosen ads in history
                if (pool.length > 0) addToAdHistory(chName, pool);
                // Take up to 4 if available
                return pool.slice(0, 4);
            }

            for (let i = 0; i < pattern.long; i++) {
                if (longAds.length > 0) seq.push(longAds.pop());
            }
            for (let i = 0; i < pattern.short; i++) {
                if (shortAds.length > 0) seq.push(shortAds.pop());
            }

            // Record selection in history
            addToAdHistory(chName, seq);

            return seq.sort(() => Math.random() - 0.5);
        }

        function playAdsThen(cb, isTuningIn = false, resumeSeq = null, resumeStartAt = 0) {
            const loadId = currentLoadId; // Respect the load context we're in
            if (!adsEnabled || !["RK1", "RK2", "RK3", "RK4", "RK5"].includes(channels[current].name)) {
                cb(); return;
            }

            const seq = resumeSeq || createAdSequence();

            // Save Ad Break State
            if (!channelStates[`ch${current}`]) channelStates[`ch${current}`] = {};
            // If we are resuming, we keep original start time, else new
            if (!resumeSeq) {
                channelStates[`ch${current}`].adBreak = {
                    startTime: Date.now(),
                    sequence: seq
                };
            }

            playbackState.adSequence = seq;
            playbackState.isPlayingAd = true;

            let i = 0;
            function next() {
                if (i >= seq.length) {
                    playbackState.isPlayingAd = false;
                    // Clear ad break state when done
                    if (channelStates[`ch${current}`]) delete channelStates[`ch${current}`].adBreak;
                    cb();
                    return;
                }
                const adId = seq[i];
                playbackState.adIndex = i;
                // TuningIn check only applies if it's the very first time we trigger ads, 
                // OR if we are resuming the first ad in the resumeSeq? 
                // actually if resumeStartAt > 0 we use that.

                const isFirstAdOfSeq = (i === 0);
                i++;


                let startAt = 0;
                if (isFirstAdOfSeq && resumeStartAt > 0) {
                    startAt = resumeStartAt;
                }

                playbackState.videoId = adId;
                whenYTReady(() => {
                    createPlayer({
                        videoId: adId,
                        startAt: startAt,
                        loadId: loadId, // Pass the captured loadId
                        onReadyCb: e => {
                            // Strict middle start: Seek to duration / 2 if tuning in
                            // BUT if we have a specific startAt (from resume), respect that first!
                            if (isFirstAdOfSeq && isTuningIn && startAt === 0) {
                                const dur = e.target.getDuration();
                                if (dur && dur > 0) {
                                    e.target.seekTo(dur / 2, true);
                                }
                            }

                            e.target.setVolume(volume);
                            if (muted || volume === 0) e.target.mute();
                            startAutoSave();
                            try {
                                const duration = e.target.getDuration();
                                if (duration) saveAdLength(adId, duration);
                            } catch (err) { }
                        },
                        onStateChangeCb: e => {
                            if (window.YT && e.data === window.YT.PlayerState.ENDED) next();
                        },
                        onError: (e) => {
                            console.log("Ad failed (Error 153/Other), skipping to next ad:", adId);
                            playbackState.consecutiveErrorCount++;
                            if (playbackState.consecutiveErrorCount >= 5) {
                                console.error("Too many consecutive errors during ads. Stopping.");
                                updateOSD("FOR MANGE FEJL - STOPPER", true);
                                showStatic(() => { });
                                return;
                            }
                            next();
                        }
                    });
                });
            }
            next();
        }




        /* --- NEW QUEUE & PLAYBACK ENGINE --- */

        let sessionState = {
            bannedSeries: []
            // We'll store played videos in localStorage "playedHistory" instead of here
        };

        function getPlayedHistory() {
            try {
                return JSON.parse(localStorage.getItem('playedHistory')) || [];
            } catch (e) { return []; }
        }

        function addToPlayedHistory(vidId) {
            let h = getPlayedHistory();
            // LRU logic: if it's already in history, remove it from its current position
            // so we can push it to the very end (most recently seen).
            h = h.filter(id => id !== vidId);
            h.push(vidId);

            // Optional: Cap history size to prevent localStorage bloat, e.g., keep last 1000 items
            if (h.length > 1000) h = h.slice(-1000);

            localStorage.setItem('playedHistory', JSON.stringify(h));
        }

        // ===== PER-CHANNEL PERFECT ROTATION SYSTEM =====
        // Ensures each episode on a channel plays exactly once before any repeats

        // Get played episodes history for a specific channel
        function getChannelHistory(channelIndex) {
            const key = `channelHistory_ch${channelIndex}`;
            try {
                return JSON.parse(localStorage.getItem(key)) || [];
            } catch (e) {
                return [];
            }
        }

        // Set played episodes history for a specific channel
        function setChannelHistory(channelIndex, history) {
            const key = `channelHistory_ch${channelIndex}`;
            localStorage.setItem(key, JSON.stringify(history));
        }

        // Add an episode to channel's played history
        function addToChannelHistory(channelIndex, videoId) {
            let history = getChannelHistory(channelIndex);
            // Only add if not already in history
            if (!history.includes(videoId)) {
                history.push(videoId);
                setChannelHistory(channelIndex, history);
            }
        }

        // Check if an episode has been played on this channel in current rotation
        function hasPlayedOnChannel(channelIndex, videoId) {
            const history = getChannelHistory(channelIndex);
            return history.includes(videoId);
        }

        // Count total available episodes on a channel (excluding filtered/banned series)
        function getTotalAvailableEpisodes(channelIndex) {
            const ch = channels[channelIndex];
            if (!ch || !ch.series) return 0;

            let total = 0;
            Object.keys(ch.series).forEach(seriesName => {
                // Skip banned series
                if (sessionState.bannedSeries.includes(seriesName)) return;
                // Skip filtered series
                if (typeof isSeriesEnabled === 'function' && !isSeriesEnabled(seriesName)) return;

                const episodes = ch.series[seriesName];
                if (Array.isArray(episodes)) {
                    total += episodes.length;
                }
            });

            return total;
        }

        // Reset channel history when all episodes have been shown
        function resetChannelHistoryIfComplete(channelIndex) {
            const history = getChannelHistory(channelIndex);
            const totalAvailable = getTotalAvailableEpisodes(channelIndex);

            // If we've shown all available episodes, reset for new rotation
            if (totalAvailable > 0 && history.length >= totalAvailable) {
                console.log(`Channel ${channelIndex}: All ${totalAvailable} episodes shown. Resetting rotation.`);
                setChannelHistory(channelIndex, []);
                return true;
            }

            return false;
        }


        // --- AD HISTORY ---
        function getAdHistory(chName) {
            try {
                const store = JSON.parse(localStorage.getItem('adHistory')) || {};
                return store[chName] || [];
            } catch (e) { return []; }
        }

        function addToAdHistory(chName, adIds) {
            try {
                let store = JSON.parse(localStorage.getItem('adHistory')) || {};
                let list = store[chName] || [];

                // Add new ads
                for (const id of adIds) {
                    // Remove if existing (to move to end)
                    list = list.filter(x => x !== id);
                    list.push(id);
                }

                // Keep last 10 ads per channel
                if (list.length > 10) list = list.slice(-10);

                store[chName] = list;
                localStorage.setItem('adHistory', JSON.stringify(store));
            } catch (e) { }
        }

        function loadBans() {
            const saved = localStorage.getItem('tvBans');
            if (saved) {
                try { sessionState.bannedSeries = JSON.parse(saved); } catch (e) { }
            }
        }

        function removeEpisode(seriesName, queueIndex, channelIndex, element) {
            if (!on) return;

            // 1. Fade out the EPISODE
            if (element) {
                element.classList.add('banning-anim');
            }

            // 2. Wait for Fade (500ms)
            setTimeout(() => {
                // 3. COLLAPSE THE SLOT (Visual Slide Up)
                let isMerge = false;
                let nextAdContent = null;

                if (element && element.parentElement) {
                    element.parentElement.style.display = 'none'; // This causes the list to slide up

                    // 4. CHECK FOR MERGE (Now that it's hidden)
                    const chKey = `ch${channelIndex}`;
                    if (channelStates[chKey] && channelStates[chKey].playlist) {
                        const list = channelStates[chKey].playlist;
                        if (queueIndex > 0 && queueIndex < list.length - 1) {
                            if (getSeriesName(list[queueIndex - 1]) === "REKLAMEPAUSE" && getSeriesName(list[queueIndex + 1]) === "REKLAMEPAUSE") {
                                isMerge = true;
                                // Find the visual element for the underlying bottom ad
                                // Since we just hid the current slot, the next visible sibling might be it?
                                // Actually, we can rely on DOM structure: parentSlot -> nextElementSibling
                                const parentSlot = element.parentElement;
                                if (parentSlot) {
                                    const nextSlot = parentSlot.nextElementSibling;
                                    if (nextSlot) {
                                        const nextContent = nextSlot.querySelector('.program-content');
                                        if (nextContent && nextContent.textContent.includes("REKLAMER")) {
                                            nextAdContent = nextContent;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // 5. IF MERGE: Fade out the bottom ad
                if (isMerge && nextAdContent) {
                    // Short delay to let the slide-up settle, then fade
                    requestAnimationFrame(() => {
                        nextAdContent.classList.add('banning-anim');
                    });

                    // Wait for 2nd animation (500ms)
                    setTimeout(() => {
                        performRemoval();
                    }, 500);

                } else {
                    // No merge, just proceed
                    performRemoval();
                }

                function performRemoval() {
                    const chKey = `ch${channelIndex}`;
                    if (channelStates[chKey] && channelStates[chKey].playlist) {
                        const playlist = channelStates[chKey].playlist;
                        const queueItem = playlist[queueIndex];
                        const itemSeriesName = getSeriesName(queueItem);

                        // Check if this is the correct item to remove
                        if (itemSeriesName === seriesName) {
                            // COOLDOWN LOGIC: Mark the SPECIFIC removed episode as played
                            // This ensures it won't be re-selected immediately
                            if (typeof queueItem === 'object' && queueItem !== null && queueItem.videoId) {
                                // Mark the specific episode as played
                                addToPlayedHistory(queueItem.videoId);
                                addToChannelHistory(channelIndex, queueItem.videoId);
                            } else {
                                // Fallback: Mark a random video from the series
                                const ch = channels[channelIndex];
                                const sVids = ch.series ? ch.series[seriesName] : ch.videos;
                                if (sVids && sVids.length > 0) {
                                    addToPlayedHistory(sVids[0]);
                                }
                            }

                            playlist.splice(queueIndex, 1);

                            // Refill
                            ensureQueue(channelIndex);

                            // If we removed the currently playing video, force a fresh load
                            if (queueIndex === 0 && channelIndex === current) {
                                // CRITICAL: Clear the old video state first
                                channelStates[chKey].currentVideo = null;

                                // STOP the current player to ensure clean transition
                                try {
                                    if (player && player.destroy) player.destroy();
                                    else if (ytPlayer && ytPlayer.destroy) ytPlayer.destroy();
                                } catch (e) {
                                    console.log('Error stopping player:', e);
                                }

                                player = null;
                                ytPlayer = null;
                                dmPlayer = null;
                                playerType = null;
                                if (dmUpdateInterval) {
                                    clearInterval(dmUpdateInterval);
                                    dmUpdateInterval = null;
                                }

                                // FORCE RECREATE PLAYER DIV
                                // The YT API and others might leave the DOM in a weird state (iframe vs div).
                                // Nuke it and rebuild to guarantee clean slate for next load.
                                const screen = document.querySelector('.screen');
                                let playerDiv = document.getElementById('player');
                                const label = document.getElementById('label');

                                if (playerDiv) playerDiv.remove();

                                playerDiv = document.createElement('div');
                                playerDiv.id = 'player';

                                if (label && screen) {
                                    screen.insertBefore(playerDiv, label);
                                } else if (screen) {
                                    screen.appendChild(playerDiv);
                                }

                                currentLoadId++; // Invalidate any ongoing loads from the skipped video
                                // Now load the next video fresh (which is now at position 0)
                                loadChannel(false, false, false, true, true); // forceStart = true
                            }
                        }

                        // Removal Streak Penalty Logic (ONLY if skipping the CURRENT video)
                        if (queueIndex === 0) {
                            if (!channelStates[chKey].removalStreak) channelStates[chKey].removalStreak = 0;
                            channelStates[chKey].removalStreak++;

                            if (channelStates[chKey].removalStreak >= 3) {
                                // Reset streak
                                channelStates[chKey].removalStreak = 0;

                                // If this is the active channel, FORCE ADS
                                if (channelIndex === current) {
                                    console.log("3 Removals in a row - Forcing Ads!");
                                    playlist.unshift("REKLAMEPAUSE");
                                    renderTVGuide(); // Force render for the new ad

                                    playAdsThen(() => {
                                        rotateQueue(current);
                                        loadChannel(false, false, true, true);
                                    });
                                    return; // Stop here, renderTVGuide already called
                                }
                            }
                        }
                    }
                    renderTVGuide();
                }

            }, 500);
        }


        // Deprecated but keeping signature to avoid errors if called
        function toggleBan(seriesName) { }

        // Extract season and episode information from video URLs
        function extractEpisodeInfo(videoId) {
            // Match patterns like S01E01, S02E03, etc. in archive.org URLs
            const match = videoId.match(/[Ss](\d{2})[Ee](\d{2})/);
            if (match) {
                return ` S${match[1]}E${match[2]}`;
            }
            return '';
        }

        // Helper to get series name from queue item (handles both string and object formats)
        function getSeriesName(item) {
            if (typeof item === 'string') return item;
            if (typeof item === 'object' && item !== null) {
                return item.series || item.name || '';
            }
            return '';
        }

        // Helper to get episode info from queue item
        function getEpisodeInfo(item) {
            if (typeof item === 'object' && item !== null && item.episodeInfo) {
                return item.episodeInfo;
            }
            return '';
        }

        // OSD / Label Logic
        function updateOSD(text, sticky = false) {
            if (!on) return;

            label.textContent = text;
            label.style.opacity = 1;
            label.sticky = sticky;
            if (label.timer) clearTimeout(label.timer);

            if (!sticky) {
                label.timer = setTimeout(() => {
                    label.style.opacity = 0;
                    label.sticky = false;
                }, 4000);
            } else {
                // Sticky items still fade after a while to allow hover to work again
                label.timer = setTimeout(() => {
                    label.style.opacity = 0;
                    label.sticky = false;
                }, 4000);
            }
        }

        function ensureQueue(channelIndex) {
            const chKey = `ch${channelIndex}`;
            const ch = channels[channelIndex];

            if (!channelStates[chKey]) channelStates[chKey] = {};
            if (!channelStates[chKey].playlist) channelStates[chKey].playlist = [];

            const queue = channelStates[chKey].playlist;
            const allSeries = ch.series ? Object.keys(ch.series) : [];

            // If channel has NO content (e.g. RK3/RK4), fill with ADS
            if (allSeries.length === 0) {
                while (queue.length < 15) {
                    queue.push({ series: "REKLAMEPAUSE", videoId: null, episodeInfo: '' });
                }
                return;
            }

            // Fill queue up to 15 items 
            let safetyCounter = 0; // Prevent infinite loops

            // Check if we need to reset channel history (all episodes shown)
            resetChannelHistoryIfComplete(channelIndex);
            const channelHistory = getChannelHistory(channelIndex);

            while (queue.length < 15 && safetyCounter < 50) {
                safetyCounter++;

                // 1. Filter out Banned Series AND Filtered Series
                let available = allSeries.filter(s => !sessionState.bannedSeries.includes(s));
                // Also filter out series that are disabled in the filter menu
                if (typeof isSeriesEnabled === 'function') {
                    available = available.filter(s => isSeriesEnabled(s));
                }
                if (available.length === 0) available = allSeries; // Fallback if all strictly banned/filtered

                // 2. PER-CHANNEL PERFECT ROTATION FILTER
                // Only include series that have at least ONE episode NOT in channelHistory
                const seriesWithUnplayedEpisodes = available.filter(seriesName => {
                    const sVids = ch.series[seriesName];
                    if (!sVids || sVids.length === 0) return false;

                    // Count how many times this series is already in the queue
                    const inQueueCount = queue.filter(s => getSeriesName(s) === seriesName).length;

                    // Find episodes NOT yet played on this channel
                    const unplayedEpisodes = sVids.filter(vidId => !channelHistory.includes(vidId));

                    // Series is available if it has more unplayed episodes than its current count in queue
                    return unplayedEpisodes.length > inQueueCount;
                });

                // Use series with unplayed episodes, or fallback to all available if all are exhausted
                if (seriesWithUnplayedEpisodes.length > 0) {
                    available = seriesWithUnplayedEpisodes;
                }

                // Rule: Max 2 repeats in a row in the queue logic
                // Check last 2 items
                const last1 = queue.length > 0 ? getSeriesName(queue[queue.length - 1]) : null;
                const last2 = queue.length > 1 ? getSeriesName(queue[queue.length - 2]) : null;

                let pick = null;

                // Bias: If we played Series X, and previous wasn't Series X (so count is 1), 
                // try to play Series X again with 40% probability (clustering)
                if (last1 && last1 !== "REKLAMEPAUSE" && last1 !== last2 && available.includes(last1)) {
                    if (Math.random() < 0.40) {
                        pick = last1;
                    }
                }

                if (!pick) {
                    // Pick random from the filtered list
                    pick = available[Math.floor(Math.random() * available.length)];
                }

                if (last1 === pick && last2 === pick && available.length > 1) {
                    continue; // Try again
                }

                // PRE-SELECT EPISODE and extract episode info for TV guide display
                // Get the series videos
                const sVids = ch.series ? ch.series[pick] : [];
                if (sVids && sVids.length > 0) {
                    const channelHistory = getChannelHistory(channelIndex);

                    // Filter to available episodes (not yet played on this channel)
                    let availableVids = sVids.filter(vid => !channelHistory.includes(vid));

                    // If no available episodes, reset and use all
                    if (availableVids.length === 0) {
                        availableVids = sVids;
                    }

                    // Select a random episode
                    if (availableVids.length > 0) {
                        const selectedVideoId = availableVids[Math.floor(Math.random() * availableVids.length)];
                        const episodeInfo = extractEpisodeInfo(selectedVideoId);

                        // Store with pre-selected episode and info
                        queue.push({
                            series: pick,
                            videoId: selectedVideoId,
                            episodeInfo: episodeInfo
                        });
                    } else {
                        // Fallback if no videos available (shouldn't happen)
                        queue.push({ series: pick, videoId: null, episodeInfo: '' });
                    }
                } else {
                    // No videos for this series (shouldn't happen)
                    queue.push({ series: pick, videoId: null, episodeInfo: '' });
                }

                // Chance to insert AD BREAK after an episode (but not if last was ad)
                // 25% chance -> Approx every 4 episodes
                // STRICT RULE: Never have more than 2 REKLAMEPAUSE in a row
                // AND: Only on ad-supported channels
                const adChannels = ["RK1", "RK2", "RK3", "RK4"];
                if (Math.random() < 0.50 && pick !== "REKLAMEPAUSE" && adChannels.includes(ch.name)) {
                    // Count consecutive REKLAMEPAUSE at end of queue
                    let consecutiveAds = 0;
                    for (let j = queue.length - 1; j >= 0; j--) {
                        if (getSeriesName(queue[j]) === "REKLAMEPAUSE") {
                            consecutiveAds++;
                        } else {
                            break;
                        }
                    }

                    // Only add if we don't already have 2 in a row
                    if (consecutiveAds < 2) {
                        queue.push({ series: "REKLAMEPAUSE", videoId: null, episodeInfo: '' });
                    }
                }
            }
        }

        function rotateQueue(channelIndex) {
            const chKey = `ch${channelIndex}`;
            if (!channelStates[chKey] || !channelStates[chKey].playlist) return;

            // Shifts the top item out (it has finished playing)
            const old = channelStates[chKey].playlist.shift();

            // Automatically move it to bottom? 
            // Logic says "random shuffle" but user said "when a series has been shown it should disappear from top and go to bottom".
            // Our ensureQueue does random picking. To strictly follow "go to bottom", we might want a round-robin?
            // But "random order" is also requested.
            // `ensureQueue` random refill effectively puts it back in the pool.

            // Refill to keep buffer full
            ensureQueue(channelIndex);
        }

        function playNextInQueue(channelIndex) {
            const chKey = `ch${channelIndex}`;
            ensureQueue(channelIndex);

            const queue = channelStates[chKey].playlist;
            const queueItem = queue[0];
            const seriesName = getSeriesName(queueItem);

            // Special Case: Continuous Ads
            if (seriesName === "REKLAMEPAUSE") {
                renderTVGuide();
                return "REKLAMEPAUSE";
            }

            // If banned, rotate and try again (skip it)
            if (sessionState.bannedSeries.includes(seriesName)) {
                rotateQueue(channelIndex);
                return playNextInQueue(channelIndex);
            }

            const ch = channels[channelIndex];
            const vids = ch.series ? ch.series[seriesName] : ch.videos;

            if (!vids) return null;

            // GOOD BEHAVIOR: Watching a video resets the removal streak
            channelStates[chKey].removalStreak = 0;

            // CRITICAL: Always use the pre-selected episode from the queue
            // This ensures what's shown in TV guide ALWAYS matches what plays
            let videoId = null;
            if (typeof queueItem === 'object' && queueItem !== null && queueItem.videoId) {
                videoId = queueItem.videoId;
            }

            // If no pre-selected video, this shouldn't happen but handle gracefully
            if (!videoId) {
                console.warn(`No pre-selected video for ${seriesName}, skipping...`);
                rotateQueue(channelIndex);
                return playNextInQueue(channelIndex);
            }

            // Archive.org videos work fine in iframes on iOS, no need to skip them

            const channelHistory = getChannelHistory(channelIndex);
            const wasInHistory = channelHistory.includes(videoId);

            // Mark as played (both global and per-channel)
            addToPlayedHistory(videoId);
            addToChannelHistory(channelIndex, videoId);

            // Update State
            playbackState.currentSeries = seriesName;
            // Removed updateOSD(seriesName) call per request

            renderTVGuide();

            return { id: videoId, wasInHistory: wasInHistory };
        }

        function loadChannel(justPoweredOn = false, isChannelSwitch = false, afterAd = false, skipStatic = false, forceStart = false) {
            // CRITICAL: Never load/play content if TV is powered off
            if (!on && !justPoweredOn) {
                console.log('loadChannel blocked: TV is off');
                return;
            }

            // Auto-advance (afterAd=true) should always start from beginning, not random seek
            if (afterAd) forceStart = true;

            const loadId = ++currentLoadId; // Capture this load context

            if (isHovering && on) {
                updateOSD(`${channels[current].name}`, true);
            }

            const ch = channels[current];
            const chKey = `ch${current}`;

            if (afterAd) {
                rotateQueue(current);
                if (channelStates[chKey]) channelStates[chKey].currentVideo = null;
            }

            // FIRST: Check what's at the top of the queue
            ensureQueue(current);
            const queueTop = channelStates[chKey] && channelStates[chKey].playlist
                ? channelStates[chKey].playlist[0]
                : null;

            // If queue says REKLAMEPAUSE, we MUST play ads (don't reuse old video)
            // If queue says REKLAMEPAUSE, we MUST play ads (don't reuse old video)
            if (getSeriesName(queueTop) === "REKLAMEPAUSE") {
                // If ads are disabled, skip this item immediately
                if (!adsEnabled) {
                    const ch = channels[current];
                    const hasContent = ch.series && Object.keys(ch.series).length > 0;

                    if (!hasContent) {
                        // Ad-only channel with ads disabled -> Stop player and show static
                        if (window.ytPlayer && typeof window.ytPlayer.stopVideo === 'function') {
                            window.ytPlayer.stopVideo();
                        }
                        // Update UI to reflect no content
                        if (channelStates[chKey]) channelStates[chKey].currentVideo = null;

                        showStatic(() => { });
                        return;
                    }

                    // Content channel -> skip ad block
                    loadChannel(false, false, true, true); // afterAd=true (rotates queue), skipStatic=true
                    return;
                }

                renderTVGuide();
                const startAds = () => {
                    playAdsThen(() => {
                        loadChannel(false, false, true, true); // skipStatic=true
                    });
                };
                if (skipStatic) { startAds(); } else { showStatic(startAds); }
                return;
            }

            // We are playing content now, so ensure ad state is cleared
            // This is critical if we just skipped an ad, otherwise the system thinks we are still playing an ad
            playbackState.isPlayingAd = false;
            playbackState.adSequence = null;
            if (channelStates[chKey] && channelStates[chKey].adBreak) {
                delete channelStates[chKey].adBreak;
            }

            // Check if we already have a video playing on this channel
            let videoId = null;
            let state = channelStates[chKey] ? channelStates[chKey].currentVideo : null;

            // If we have a currentVideo and we're not coming from an ad, reuse it
            let wasInHistory = false;
            if (state && state.id && !afterAd) {
                videoId = state.id;
            } else {
                // Otherwise get the next video from queue
                const result = playNextInQueue(current);
                if (result && typeof result === 'object') {
                    videoId = result.id;
                    wasInHistory = result.wasInHistory;
                } else {
                    videoId = result;
                }
            }

            if (!videoId) return;

            // LIVE SIMULATION LOGIC
            let seekTo = 0;

            // If we are returning to a video that has been running
            if (state && state.id === videoId && !justPoweredOn && !afterAd) {
                const elapsed = (Date.now() - state.startTime) / 1000;

                // If we know the duration, check if video finished
                if (state.duration && state.duration > 0) {
                    if (elapsed < state.duration - 5) {
                        seekTo = elapsed;
                    } else {
                        // Video finished while away
                        console.log("Video finished while away");
                        rotateQueue(current);
                        channelStates[chKey].currentVideo = null;
                        loadChannel(false, false, false, true); // forceStart false (normal flow)
                        return;
                    }
                } else {
                    // Duration not known yet, but still seek to elapsed time
                    seekTo = Math.max(0, elapsed);
                }
            }

            // IFRAME RANDOM START FIX (Since we can't get duration from iframes)
            const isIframe = videoId.startsWith('iframe:') || videoId.startsWith('embed:') || videoId.includes('/embed') || videoId.includes('1drv.ms') || videoId.includes('archive.org/details/');
            const isNewVideo = (!state || state.id !== videoId);

            // FORCE START FIX: If we must start from beginning (e.g. after ads), ensure seekTo is 0
            if (forceStart) {
                seekTo = 0;
            }

            if (isIframe && isNewVideo && seekTo === 0) {
                // If we just powered on OR it's a new video we haven't seen before
                // AND not forced start!
                if ((justPoweredOn || !wasInHistory) && !forceStart) {
                    console.log("Randomizing start for Iframe (no duration available)");
                    seekTo = Math.floor(Math.random() * 600); // Random 0-10 mins
                }
            }

            const loadVideo = () => {
                // Initialize currentVideo if it doesn't exist or is different
                // Only done for NEW videos. Resuming videos keep their existing state object.
                if (!state || state.id !== videoId) {
                    channelStates[chKey].currentVideo = {
                        id: videoId,
                        startTime: Date.now() - (seekTo * 1000), // Adjust startTime by the initial seek offset
                        duration: 0
                    };
                    // Reset channel-specific pending seek
                    channelStates[chKey].pendingSeek = null;

                    // Update TV guide to show the new video that's playing
                    renderTVGuide();
                }

                // If resuming a video, save the seek target specifically for THIS channel
                if (state && state.id === videoId && seekTo > 0) {
                    channelStates[chKey].pendingSeek = seekTo;
                } else if (state && state.id === videoId && seekTo === 0) {
                    // Should be rare, but if elapsed is 0, we still want to avoid random seek if it's a resume
                    // But actually if seekTo is 0 and it's a resume, it means we just started or wrapped?
                    // Let's rely on 'isNewVideo' to filter random seeks.
                }

                createPlayer({
                    videoId: videoId,
                    startAt: seekTo,
                    loadId: loadId,
                    onReadyCb: (e) => {
                        if (loadId !== currentLoadId) return; // Ignore stale load callbacks

                        // Skip all control attempts for iframe players (they can't be controlled)
                        if (e.target._isIframe) {
                            console.log('Iframe player ready - autoplay handles playback');
                            // Just save duration and return
                            let dur = e.target.getDuration();
                            if (dur && channelStates[chKey] && channelStates[chKey].currentVideo) {
                                channelStates[chKey].currentVideo.duration = dur;
                            }
                            return;
                        }

                        // Force playback for all platforms
                        if (e.target.playVideo) {
                            try {
                                e.target.playVideo();
                            } catch (err) {
                                console.log('Force play error:', err);
                            }
                        }

                        e.target.setVolume(volume);

                        // CRITICAL: Attempt to unmute if user settings allow
                        if (!muted && volume > 0) {
                            setTimeout(() => {
                                e.target.unMute();
                                console.log('Unmuted in onReady');
                            }, 500);
                        } else if (muted) {
                            e.target.mute();
                        }

                        // 1. Save Duration (DM duration might be 0 immediately after load)
                        let dur = e.target.getDuration();
                        if (dur && channelStates[chKey] && channelStates[chKey].currentVideo) {
                            channelStates[chKey].currentVideo.duration = dur;
                        }

                        // 2. Random Start Logic 
                        const isNewVideo = (!state || state.id !== videoId);

                        // ONLY Random Seek if it is a NEW video start or power on, AND not a forced start
                        // Crucial fix: 'isChannelSwitch' shouldn't trigger random seek if it's NOT a new video (i.e. resuming)
                        // AND skip random seek if the video was already in history (meaning it should start from 0:00)
                        const shouldRandom = (justPoweredOn || (isNewVideo && seekTo === 0 && !wasInHistory));

                        if (shouldRandom && !forceStart) {
                            console.log(`Debug Random Start: PowerOn=${justPoweredOn} New=${isNewVideo} seekTo=${seekTo} Force=${forceStart} WasPlayed=${wasInHistory}`);
                            playbackState.pendingRandomSeek = true;

                            if (dur && dur > 10) {
                                const randTime = 2 + Math.random() * (dur - 7);
                                e.target.seekTo(randTime, true);
                                playbackState.pendingRandomSeek = false;

                                // Update StartTime because we shifted the timeline
                                if (channelStates[chKey] && channelStates[chKey].currentVideo) {
                                    channelStates[chKey].currentVideo.startTime = Date.now() - (randTime * 1000);
                                }
                            }
                        } else if (seekTo > 0) {
                            // Strict Resume
                            e.target.seekTo(seekTo, true);
                        } else if (!isNewVideo && seekTo === 0) {
                            // Resuming at 0 (rare but possible)
                        }

                        // Mark as visited
                        channelStates[chKey].visited = true;
                    },
                    onStateChangeCb: (e) => {
                        if (e.data === window.YT.PlayerState.PLAYING) {
                            let dur = e.target.getDuration();

                            // CRITICAL for Dailymotion: Capture duration if it was missing during onReady
                            if (dur && channelStates[chKey] && channelStates[chKey].currentVideo && (!channelStates[chKey].currentVideo.duration || channelStates[chKey].currentVideo.duration === 0)) {
                                channelStates[chKey].currentVideo.duration = dur;
                            }

                            // Handle Pending Resume for THIS CHANNEL
                            if (channelStates[chKey].pendingSeek) {
                                const resumeTime = channelStates[chKey].pendingSeek;
                                channelStates[chKey].pendingSeek = null; // Clear it

                                // Force seek via absolute difference check
                                const currentT = e.target.getCurrentTime();
                                if (Math.abs(currentT - resumeTime) > 3) {
                                    console.log(`Channel ${current} forcing resume seek to:`, resumeTime);
                                    e.target.seekTo(resumeTime, true);
                                }
                            }

                            // Handle Pending Random Seek
                            if (playbackState.pendingRandomSeek) {
                                playbackState.pendingRandomSeek = false;
                                if (dur > 10) {
                                    const randTime = 2 + Math.random() * (dur - 7);
                                    e.target.seekTo(randTime, true);
                                    if (channelStates[chKey] && channelStates[chKey].currentVideo) {
                                        channelStates[chKey].currentVideo.duration = dur;
                                        channelStates[chKey].currentVideo.startTime = Date.now() - (randTime * 1000);
                                    }
                                }
                            }
                        }
                        if (e.data === window.YT.PlayerState.ENDED) {
                            if (loadId !== currentLoadId) return;
                            if (channelStates[chKey]) channelStates[chKey].currentVideo = null;
                            loadChannel(false, false, true, true);
                        }
                    },
                    onError: (e) => {
                        console.error("Playback Error in loadChannel:", e);
                        playbackState.consecutiveErrorCount++;
                        // updateOSD(`FEJL - SPRINGER OVER (${playbackState.consecutiveErrorCount})`, true); // Disabled to prevent error messages during channel switch

                        // Mark bad video
                        addToPlayedHistory(videoId);

                        if (playbackState.consecutiveErrorCount >= 10) {
                            updateOSD("FOR MANGE FEJL - STOPPER", true);
                            showStatic(() => { });
                            return;
                        }

                        // Skip to next
                        setTimeout(() => {
                            if (loadId === currentLoadId) {
                                if (channelStates[chKey]) channelStates[chKey].currentVideo = null;
                                loadChannel(false, false, true, true);
                            }
                        }, 100);
                    },

                });
            };

            if (skipStatic) { loadVideo(); } else {
                // Ensure static also respects loadId if it was delayed
                showStatic(() => {
                    if (loadId === currentLoadId) loadVideo();
                });
            }
        }

        // --- Background Playback Fix ---
        let audioContext = null;
        function setupSilentAudio() {
            if (audioContext) return;
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;

                audioContext = new AudioContext();
                // Create a silent oscillator
                // Create a silent oscillator
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.0001; // Extremely low gain
                oscillator.frequency.value = 1; // 1Hz frequency (inaudible)
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start();
                console.log("Silent audio started for background persistence.");
            } catch (e) {
                console.error("AudioContext setup failed:", e);
            }
        }

        let playbackMonitorInterval = null;

        function startPlaybackMonitor() {
            if (playbackMonitorInterval) return;
            playbackMonitorInterval = setInterval(() => {
                if (!on || !player) return;
                // DISABLE for iframe players - we can't check status and it causes stuttering
                if (playerType === 'iframe') return;

                // "Triple-Trigger" check: if TV is on but not playing for > 2s, force a play call sequence
                if (!playbackState.isPlayingAd && !playbackState.isStatic) {
                    const now = Date.now();
                    const lastActivity = playbackState.lastActivity || now;

                    let isStuck = false;
                    if (playerType === 'youtube' && ytPlayer && ytPlayer.getPlayerState) {
                        const s = ytPlayer.getPlayerState();
                        // -1 (unstarted), 3 (buffering), 2 (paused)
                        if (s === -1 || s === 3 || s === 2) isStuck = true;
                    } else if (playerType === 'dailymotion' && dmPlayer) {
                        // 2 (paused), -1 (unstarted/buffering)
                        if (dmInternalState === 2 || dmInternalState === -1) isStuck = true;
                    } else if (playerType === 'video' && videoElement) {
                        if (videoElement.paused) isStuck = true;
                    }

                    if (isStuck) {
                        // iOS: Much shorter delay to immediately catch auto-advance failures
                        const stuckDelay = isIOS ? 500 : 2500;
                        if (now - lastActivity > stuckDelay) {
                            console.log("iOS Triple-Trigger: Player stuck, forcing play sequence...");

                            const forcePlay = () => {
                                if (player && player.mute) player.mute();
                                if (player && player.playVideo) player.playVideo();

                                // Explicit Dailymotion/Video fallbacks
                                if (playerType === 'dailymotion' && dmPlayer) dmPlayer.play().catch(() => { });
                                if (playerType === 'video' && videoElement) videoElement.play().catch(() => { });

                                // CRITICAL: DO NOT unmute on iOS - it breaks autoplay
                                // iOS requires user interaction to unmute, attempting it will stop playback
                            };

                            forcePlay();
                            playbackState.lastActivity = now;
                        }
                    } else {
                        playbackState.lastActivity = now;
                    }
                }
            }, 1500); // Check more frequently
        }

        function stopPlaybackMonitor() {
            if (playbackMonitorInterval) {
                clearInterval(playbackMonitorInterval);
                playbackMonitorInterval = null;
            }
        }


        // Handle Page Visibility - Resume playback when returning to tab
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden && on && player) {
                try {
                    // Resume audio context if suspended
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    // Ensure player is playing
                    const playerState = player.getPlayerState();
                    if (playerState === window.YT.PlayerState.PAUSED || playerState === window.YT.PlayerState.BUFFERING) {
                        player.playVideo();
                    }
                } catch (e) {
                    console.log('Resume error:', e);
                }
            }
        });

        function power() {
            setupSilentAudio();
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            playClick();
            if (on) {
                if (player) {
                    try {
                        // IMMEDIATE STOP: For iframes/Hamtaro, we must kill the DOM element to stop sound.
                        // Our custom wrapper defines destroy() which clears the container.
                        if (player.destroy) player.destroy();
                        else if (player.pauseVideo) player.pauseVideo();

                        player.mute(); // fallback
                    } catch (e) { }

                    // Force container clear if it's an iframe type directly
                    if (playerType === 'iframe') {
                        const container = document.getElementById('player');
                        if (container) container.innerHTML = '';
                    }
                }
                saveState();
                stopAutoSave();
                muted = false; muteIcon.style.opacity = 0;
                updateOSD("TV slukket", true);
                showStatic(() => {
                    powerOffSound.currentTime = 0;
                    powerOffSound.volume = 0.3;
                    powerOffSound.play().catch(() => { });
                    powerOffVideo.style.display = "block";
                    powerOffVideo.currentTime = 0;
                    powerOffVideo.play();
                    setTimeout(() => {
                        powerOffVideo.pause();
                        powerOffVideo.style.display = "none";
                        if (player) {
                            try {
                                if (player.destroy) player.destroy();
                                else if (playerType === 'youtube' && ytPlayer) ytPlayer.destroy();
                            } catch (e) { }
                            player = null;
                        }
                        // Clear player references for both platforms
                        ytPlayer = null;
                        dmPlayer = null;
                        playerType = null;
                        // Force container clear as well
                        const container = document.getElementById('player');
                        if (container) container.innerHTML = '';
                        if (dmUpdateInterval) {
                            clearInterval(dmUpdateInterval);
                            dmUpdateInterval = null;
                        }
                        on = false;
                        document.body.classList.remove('tv-on'); // Remove class to show logo
                        stopPlaybackMonitor();
                        updateAdLed();
                        channelStates = {}; // Clear channel states to ensure fresh playlist on next power on
                        renderTVGuide(); // Will render blank because on=false
                    }, 1500);
                });
            } else {
                // Power on
                on = true;
                document.body.classList.add('tv-on'); // Add class to hide logo
                // Allow unmuted playback - power button is user interaction
                muted = false;
                initializeTVPlayback();
            }
        }

        function initializeTVPlayback() {
            if (isIOS) startPlaybackMonitor();
            // Resume on last used channel (loaded from state)
            // current = Math.floor(Math.random() * channels.length);

            // Random Week Number
            const weekNum = Math.floor(Math.random() * 52) + 1;
            const weekEl = document.getElementById('week-display');
            if (weekEl) weekEl.innerText = `UGE ${weekNum} - 2004`;

            // Apply filters when turning on
            applyFilters();

            // Update LED light when TV turns on
            updateAdLed();

            // Initialize playlists
            channels.forEach((_, idx) => ensureQueue(idx));

            if (window.location.protocol === 'file:') {
                updateOSD("KØR VIA LOCALSERVER FOR VIDEO", true);
            } else {
                updateOSD("Tænder...", false);
            }

            // Update OSD if hovering
            if (isHovering) updateOSD(`${channels[current].name}`, true);

            // Render TV Guide with populated playlists
            renderTVGuide();

            // Start with random video at random time like all other channels
            // iOS: Skip static to maintain user interaction context for autoplay
            const skipStaticOnPowerOn = isIOS;
            loadChannel(true, false, false, skipStaticOnPowerOn, false);
        }

        function chUp() {
            if (on) {
                playClick();
                playClick();

                // STOP current playback immediately to ensure channel switch works
                if (player) {
                    try {
                        if (player.destroy) player.destroy();
                        else if (playerType === 'youtube' && ytPlayer) ytPlayer.destroy();
                    } catch (e) {
                        console.log('Error destroying during channel switch:', e);
                    }
                    player = null;
                    ytPlayer = null;
                    dmPlayer = null;
                    playerType = null;
                    if (dmUpdateInterval) {
                        clearInterval(dmUpdateInterval);
                        dmUpdateInterval = null;
                    }
                }

                saveState();
                current = (current + 1) % channels.length;
                renderTVGuide(); // Update guide to show new channel
                // iOS: Skip static to maintain user interaction context for autoplay
                loadChannel(false, true, false, isIOS);
            }
        }

        function chDown() {
            if (on) {
                playClick();
                playClick();

                // STOP current playback immediately to ensure channel switch works
                if (player) {
                    try {
                        if (player.destroy) player.destroy();
                        else if (playerType === 'youtube' && ytPlayer) ytPlayer.destroy();
                    } catch (e) {
                        console.log('Error destroying during channel switch:', e);
                    }
                    player = null;
                    ytPlayer = null;
                    dmPlayer = null;
                    playerType = null;
                    if (dmUpdateInterval) {
                        clearInterval(dmUpdateInterval);
                        dmUpdateInterval = null;
                    }
                }

                saveState();
                current = (current - 1 + channels.length) % channels.length;
                renderTVGuide(); // Update guide to show new channel
                // iOS: Skip static to maintain user interaction context for autoplay
                loadChannel(false, true, false, isIOS);
            }
        }

        function volUp() {
            if (on) {
                playClick();
                if (volume < 100) {
                    volume = Math.min(100, volume + 5);
                    if (volume > 0) {
                        muted = false;
                        muteIcon.style.opacity = 0;
                    }
                    saveState();
                    showVolume();

                    // Apply volume to ALL player types
                    if (player) {
                        try {
                            if (player.setVolume) player.setVolume(volume);
                            if (!muted && player.unMute) player.unMute();
                        } catch (e) {
                            console.log('Volume control error:', e);
                        }
                    }

                    // Also apply to HTML5 video elements directly
                    if (videoElement) {
                        videoElement.volume = volume / 100;
                        if (volume > 0) videoElement.muted = false;
                    }
                }
            }
        }

        function volDown() {
            if (on) {
                playClick();
                if (volume > 0) {
                    volume = Math.max(0, volume - 5);
                    if (volume > 0) {
                        muted = false;
                        muteIcon.style.opacity = 0;
                    } else {
                        muted = true;
                        muteIcon.style.opacity = 1;
                    }
                    saveState();
                    showVolume();

                    // Apply volume to ALL player types
                    if (player) {
                        try {
                            if (player.setVolume) player.setVolume(volume);
                            if (volume === 0 && player.mute) player.mute();
                            else if (!muted && player.unMute) player.unMute();
                        } catch (e) {
                            console.log('Volume control error:', e);
                        }
                    }

                    // Also apply to HTML5 video elements directly
                    if (videoElement) {
                        videoElement.volume = volume / 100;
                        videoElement.muted = (volume === 0 || muted);
                    }
                }
            }
        }


        function muteToggle() {
            if (on) {
                playClick();
                muted = !muted;

                // If volume is 0, always stay muted
                if (volume === 0) {
                    muted = true;
                }

                if (player) {
                    // Handle different player types
                    if (playerType === 'iframe') {
                        // Iframe players (like Archive.org) need a reload to apply mute state via URL
                        showVolume();
                        loadChannel(false, false, false, true);
                    } else if (player.mute && player.unMute) {
                        // Use unified player wrapper methods for YT, DM, and Direct Video
                        try {
                            if (muted || volume === 0) {
                                player.mute();
                            } else {
                                player.unMute();
                            }
                        } catch (e) {
                            console.warn('Mute error:', e);
                        }
                        showVolume();
                    }
                }

                updateOSD(muted ? "LYD FRA" : `LYD TIL (${volume}%)`, false);
                saveState();
                renderTVGuide();
            }
        }

        function toggleFullscreen() {
            playClick();
            const container = document.querySelector('.screen');

            if (!document.fullscreenElement) {
                // Enter fullscreen
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen(); // Safari
                } else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen(); // Firefox
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen(); // IE11
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        // TV Guide Toggle
        let guideCollapsed = false;

        // Fumble Antenna Effect
        let isFumbling = false;
        function antennaFumble() {
            if (!on || isFumbling) return;
            isFumbling = true;

            // Random static duration between 300ms and 1500ms
            const duration = 300 + Math.random() * 1200;

            // Show static
            staticVideo.style.display = "block";
            staticVideo.style.opacity = "0.6";
            staticVideo.style.mixBlendMode = "exclusion";
            staticVideo.style.filter = "contrast(1.5) brightness(1.2)";
            staticVideo.currentTime = Math.random() * 10;
            staticVideo.play().catch(() => { });

            // Play static sound at higher volume for effect
            // Play static sound at higher volume for effect
            staticSound.currentTime = 0;
            staticSound.volume = 0.2;
            staticSound.play().catch(() => { });

            // Show OSD
            updateOSD("JUSTERER ANTENNE...", true);

            setTimeout(() => {
                staticVideo.pause();
                staticVideo.style.display = "none";
                staticVideo.style.opacity = "1";
                staticVideo.style.mixBlendMode = "normal";
                staticVideo.style.filter = "none";
                staticSound.pause();
                staticSound.currentTime = 0;
                isFumbling = false;
                // Restore OSD to channel name
                if (on) updateOSD(`${channels[current].name}`, true);
            }, duration);
        }

        function toggleGuide() {
            // NEVER collapse guide on mobile or iOS - absolute enforcement
            const isActuallyMobile = window.innerWidth <= 768 || (typeof isIOS !== 'undefined' && isIOS);
            if (isActuallyMobile) return;

            playClick();
            guideCollapsed = !guideCollapsed;
            const layout = document.getElementById('main-layout');
            const guide = document.getElementById('tvGuide');
            const tv = document.getElementById('tv');

            if (guideCollapsed) {
                guide.classList.add('collapsed');
                layout.classList.add('guide-collapsed');
            } else {
                guide.classList.remove('collapsed');
                layout.classList.remove('guide-collapsed');
            }

            // Save state
            localStorage.setItem('guideCollapsed', guideCollapsed);
        }

        function loadGuideState() {
            // NEVER collapse guide on mobile or iOS - always show it
            const isActuallyMobile = window.innerWidth <= 768 || (typeof isIOS !== 'undefined' && isIOS);
            if (isActuallyMobile) {
                guideCollapsed = false;
                const guide = document.getElementById('tvGuide');
                const layout = document.getElementById('main-layout');
                if (guide) guide.classList.remove('collapsed');
                if (layout) layout.classList.remove('guide-collapsed');
                return;
            }

            const saved = localStorage.getItem('guideCollapsed');
            if (saved === 'true') {
                guideCollapsed = true;
                const guide = document.getElementById('tvGuide');
                if (guide) guide.classList.add('collapsed');
            }
        }


        const tv = document.getElementById("tv");

        // Auto-fade logic vars
        let hoverTimer = null;

        function resetHoverTimer() {
            if (hoverTimer) clearTimeout(hoverTimer);
            // Fade out after 20 seconds of inactivity even if hovering
            hoverTimer = setTimeout(() => {
                label.style.opacity = 0;
            }, 20000);
        }

        tv.addEventListener("mouseenter", () => {
            isHovering = true;
            if (on) {
                updateOSD(`${channels[current].name}`, true); // Sticky while hovering
                resetHoverTimer();
            } else {
                updateOSD("TV slukket", true);
                resetHoverTimer();
            }
        });

        tv.addEventListener("mousemove", () => {
            if (isHovering && on && label.style.opacity == 0) {
                // If it faded out but we moved mouse, show it again
                updateOSD(`${channels[current].name}`, true);
            }
            resetHoverTimer();
        });

        tv.addEventListener("mouseleave", () => {
            isHovering = false;
            if (hoverTimer) clearTimeout(hoverTimer);
            // Hide immediately
            label.style.opacity = 0;
        });

        // Brightness & Color Logic variables moved to earlier in code (line ~2018) to avoid temporal dead zone error
        const screenEl = document.querySelector('.screen');

        // Slider Click Sound Engine
        let sliderAudioCtx = null;
        let lastSliderSoundTime = 0;

        function playSliderSound() {
            // Throttle
            const now = Date.now();
            if (now - lastSliderSoundTime < 40) return;
            lastSliderSoundTime = now;

            try {
                if (!sliderAudioCtx) sliderAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (sliderAudioCtx.state === 'suspended') sliderAudioCtx.resume();

                const osc = sliderAudioCtx.createOscillator();
                const gain = sliderAudioCtx.createGain();

                // Mechanical "Tick" Sound
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, sliderAudioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(300, sliderAudioCtx.currentTime + 0.02);

                gain.gain.setValueAtTime(0.05, sliderAudioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, sliderAudioCtx.currentTime + 0.02);

                osc.connect(gain);
                gain.connect(sliderAudioCtx.destination);

                osc.start();
                osc.stop(sliderAudioCtx.currentTime + 0.03);
            } catch (e) { }
        }

        function setBrightness(val) {
            if (val != brightness) {
                if (on) playSliderSound();
                brightness = val;
                saveState();
            }
            if (on) {
                applyFilters();
                updateOSD(`LYSSTYRKE: ${brightness}`, true);
                resetHoverTimer();
            }
        }

        function setSaturation(val) {
            if (val != saturation) {
                if (on) playSliderSound();
                saturation = val;
                saveState();
            }
            if (on) {
                applyFilters();
                updateOSD(`FARVE: ${saturation}`, true);
                resetHoverTimer();
            }
        }


        // Fullscreen Controls Auto-Hide Logic
        let fsControlsTimeout;
        const fsControls = document.getElementById('fsControls');
        const screenArea = document.querySelector('.screen');

        function showFsControls() {
            if (!document.fullscreenElement) return;

            // Synchronize fullscreen controls with current state
            const fsSaturationSlider = document.getElementById('fsSaturationSlider');
            const fsBrightnessSlider = document.getElementById('fsBrightnessSlider');

            if (fsSaturationSlider) fsSaturationSlider.value = saturation;
            if (fsBrightnessSlider) fsBrightnessSlider.value = brightness;

            fsControls.classList.add('visible');

            // Clear existing timeout
            if (fsControlsTimeout) clearTimeout(fsControlsTimeout);

            // Hide after 3 seconds of inactivity
            fsControlsTimeout = setTimeout(() => {
                fsControls.classList.remove('visible');
            }, 3000);
        }

        // Monitor mouse movement on screen
        screenArea.addEventListener('mousemove', showFsControls);
        screenArea.addEventListener('click', showFsControls);
        screenArea.addEventListener('touchstart', showFsControls);

        // Hide controls immediately when exiting fullscreen
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                fsControls.classList.remove('visible');
            }
        });

        function setColor(val) {
            if (val != saturation) {
                if (on) playSliderSound();
                saturation = val;
                saveState();
            }
            if (on) {
                applyFilters();
                updateOSD(`FARVE: ${saturation}`, true);
                resetHoverTimer();
            }
        }

        function toggleAds(enabled) {
            adsEnabled = enabled;

            // Synchronize all ad toggle UI elements
            const mainToggle = document.getElementById('adToggle');
            if (mainToggle) mainToggle.checked = adsEnabled;

            if (on) {
                const toggleSound = document.getElementById('toggleSound');
                if (toggleSound) {
                    toggleSound.currentTime = 0;
                    toggleSound.volume = 0.4;
                    toggleSound.play().catch(() => { });
                }
            }

            saveState();
            updateAdLed();

            if (on) {
                updateOSD(`REKLAMER: ${adsEnabled ? 'TIL' : 'FRA'}`, true);

                // If we are currently playing an ad and user disabled them, skip immediately
                if (!adsEnabled && playbackState.isPlayingAd) {
                    loadChannel(false, false, true, true); // afterAd=true (rotates queue), skipStatic=true
                }
            }
            renderTVGuide(); // Refresh guide to show/hide ads
        }

        function updateAdLed() {
            const led = document.getElementById('adLed');
            if (!led) return;
            led.classList.remove('on-green', 'on-red');
            // Only show LED light when TV is on
            if (on) {
                if (adsEnabled) {
                    led.classList.add('on-green');
                } else {
                    led.classList.add('on-red');
                }
            }
        }

        const filterLayer = document.getElementById('filterLayer');

        function applyFilters() {
            if (filterLayer) {
                filterLayer.style.filter = `brightness(${brightness}%) saturate(${saturation}%)`;
            }
        }



        function downloadSource() {
            try {
                const source = "<!DOCTYPE html>\n" + document.documentElement.outerHTML;
                const blob = new Blob([source], { type: 'text/html' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                const date = new Date().toISOString().split('T')[0];
                a.href = url;
                a.download = `Retro_TV_Backup_${date}.html`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                updateOSD("KODE DOWNLOADET", false);
            } catch (e) {
                console.error("Download error:", e);
                // updateOSD("FEJL VED DOWNLOAD", true); // Disabled to prevent error messages during channel switch
            }
        }

        loadBans();
        loadState();
        loadGuideState();

        // ====== SERIES FILTER MENU FUNCTIONALITY ======

        // Storage key for series filters
        const SERIES_FILTER_KEY = 'retro_tv_series_filters';

        // Load filtered series from localStorage
        function loadSeriesFilters() {
            const stored = localStorage.getItem(SERIES_FILTER_KEY);
            if (stored) {
                try {
                    return JSON.parse(stored);
                } catch (e) {
                    console.error('Error loading series filters:', e);
                }
            }
            return {}; // Empty object means all series are enabled
        }

        // Save filtered series to localStorage
        function saveSeriesFilters(filters) {
            localStorage.setItem(SERIES_FILTER_KEY, JSON.stringify(filters));
        }

        // Global series filters object (series name -> boolean, true = enabled)
        let seriesFilters = loadSeriesFilters();

        // Check if a series is enabled (not filtered out)
        function isSeriesEnabled(seriesName) {
            // If not in filters object, default to enabled
            return seriesFilters[seriesName] !== false;
        }

        // Toggle a series filter
        function toggleSeriesFilter(seriesName, enabled) {
            seriesFilters[seriesName] = enabled;
            saveSeriesFilters(seriesFilters);

            // If disabling a series, we need to handle immediate playback consequences
            if (!enabled) {
                // Check if this series is currently playing
                const chKey = `ch${current}`;
                const currentlyPlaying = channelStates[chKey] && channelStates[chKey].playlist && channelStates[chKey].playlist[0];

                if (getSeriesName(currentlyPlaying) === seriesName && on) {
                    // This series is currently playing! Stop it and skip to next.
                    console.log(`Disabled series "${seriesName}" is currently playing. Stopping and skipping...`);

                    // Clear the current queue
                    if (channelStates[chKey] && channelStates[chKey].playlist) {
                        channelStates[chKey].playlist = [];
                    }

                    // Rebuild queue without this series
                    if (typeof ensureQueue === 'function') {
                        ensureQueue(current);
                    }

                    // Skip to next item (which will be a different series or ad)
                    if (typeof play === 'function') {
                        play(); // This will pick up the new queue top
                    }
                } else {
                    // Not currently playing, but remove from all channel queues
                    channels.forEach((ch, idx) => {
                        const key = `ch${idx}`;
                        if (channelStates[key] && channelStates[key].playlist) {
                            // Remove all instances of this series from the queue
                            channelStates[key].playlist = channelStates[key].playlist.filter(item => item !== seriesName);
                            // Rebuild queue to fill in the gaps
                            if (typeof ensureQueue === 'function') {
                                ensureQueue(idx);
                            }
                        }
                    });
                }
            } else {
                // Re-enabling a series - rebuild queues to include it
                channels.forEach((ch, idx) => {
                    const key = `ch${idx}`;
                    if (channelStates[key] && channelStates[key].playlist) {
                        // Rebuild queue to potentially include the newly enabled series
                        if (typeof ensureQueue === 'function') {
                            ensureQueue(idx);
                        }
                    }
                });
            }

            // Refresh TV guide to reflect changes
            if (typeof renderTVGuide === 'function') {
                renderTVGuide();
            }
        }

        // Select all series
        function selectAllSeries() {
            // Clear all filters (empty object = all enabled)
            seriesFilters = {};
            saveSeriesFilters(seriesFilters);

            // Update all checkboxes
            const checkboxes = document.querySelectorAll('.filter-series-item input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);

            // Rebuild all channel queues to include all series
            channels.forEach((ch, idx) => {
                const key = `ch${idx}`;
                if (channelStates[key] && typeof ensureQueue === 'function') {
                    ensureQueue(idx);
                }
            });

            // Refresh TV guide
            if (typeof renderTVGuide === 'function') {
                renderTVGuide();
            }
        }

        // Deselect all series
        function deselectAllSeries() {
            // Set all series to false
            channels.forEach(channel => {
                Object.keys(channel.series).forEach(seriesName => {
                    seriesFilters[seriesName] = false;
                });
            });
            saveSeriesFilters(seriesFilters);

            // Update all checkboxes
            const checkboxes = document.querySelectorAll('.filter-series-item input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);

            // Clear all channel queues and rebuild
            channels.forEach((ch, idx) => {
                const key = `ch${idx}`;
                if (channelStates[key] && channelStates[key].playlist) {
                    channelStates[key].playlist = [];
                    if (typeof ensureQueue === 'function') {
                        ensureQueue(idx);
                    }
                }
            });

            // If TV is on, restart playback with new queue
            if (on && typeof play === 'function') {
                play();
            }

            // Refresh TV guide
            if (typeof renderTVGuide === 'function') {
                renderTVGuide();
            }
        }

        // Expand all channel blocks
        function expandAllChannels() {
            const blocks = document.querySelectorAll('.filter-channel-block');
            blocks.forEach(block => block.classList.remove('collapsed'));
        }

        // Collapse all channel blocks
        function collapseAllChannels() {
            const blocks = document.querySelectorAll('.filter-channel-block');
            blocks.forEach(block => block.classList.add('collapsed'));
        }

        // Toggle channel block collapse
        function toggleChannelBlock(channelIndex) {
            const block = document.getElementById(`filter-channel-${channelIndex}`);
            if (block) {
                block.classList.toggle('collapsed');
            }
        }

        // Generate the filter menu UI
        function generateFilterMenu() {
            const container = document.getElementById('filterChannels');
            if (!container) return;

            container.innerHTML = '';

            channels.forEach((channel, channelIndex) => {
                const seriesList = Object.keys(channel.series);

                // Create channel block
                const channelBlock = document.createElement('div');
                channelBlock.className = 'filter-channel-block collapsed'; // Start collapsed
                channelBlock.id = `filter-channel-${channelIndex}`;

                // Create channel header
                const header = document.createElement('div');
                header.className = 'filter-channel-header';
                header.onclick = () => toggleChannelBlock(channelIndex);

                const headerText = document.createElement('span');
                headerText.textContent = `${channel.name} (${seriesList.length} serier)`;

                const arrow = document.createElement('span');
                arrow.className = 'filter-channel-arrow';
                arrow.textContent = '▼';

                header.appendChild(headerText);
                header.appendChild(arrow);
                channelBlock.appendChild(header);

                // Create series list
                const seriesListDiv = document.createElement('div');
                seriesListDiv.className = 'filter-series-list';

                seriesList.forEach(seriesName => {
                    const item = document.createElement('div');
                    item.className = 'filter-series-item';

                    const label = document.createElement('label');

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = isSeriesEnabled(seriesName);
                    checkbox.onchange = (e) => toggleSeriesFilter(seriesName, e.target.checked);

                    const text = document.createTextNode(seriesName);

                    label.appendChild(checkbox);
                    label.appendChild(text);
                    item.appendChild(label);
                    seriesListDiv.appendChild(item);
                });

                channelBlock.appendChild(seriesListDiv);
                container.appendChild(channelBlock);
            });
        }

        // Initialize filter menu when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            generateFilterMenu();
        });

        // If DOM is already loaded, generate menu now
        if (document.readyState === 'loading') {
            // Already set up listener above
        } else {
            generateFilterMenu();
        }
    </script>

    <p class="footer-disclaimer">
        Videoerne afspilles direkte fra YouTube.<br>
        Alt indhold tilhører deres respektive ophavsretshavere og vises via Youtubes, Dailymotion og internet archives
        indlejringsfunktioner.<br>
        Retrokyllingen har ingen tilknytning til eller ejerskab over videoerne.<br>
        <span style="display: inline-block; margin-top: 10px; opacity: 0.7;">Powered by <a
                href="https://retrokyllingen.dk" target="_blank"
                style="color: inherit; text-decoration: underline;">Retrokyllingen.dk</a></span><br>
        <span style="display: inline-block; margin-top: 8px; opacity: 0.6; font-size: 10px;">
            <span id="contactLink" onclick="copyEmailToClipboard()"
                style="color: inherit; text-decoration: none; cursor: pointer;">Kontakt</span>
        </span>

        <script>
            function copyEmailToClipboard() {
                const email = 'retrotvdk@gmail.com';

                // Try to copy to clipboard
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(email).then(() => {
                        showEmailCopiedMessage();
                    }).catch(() => {
                        // Fallback if clipboard API fails
                        fallbackCopyEmail(email);
                    });
                } else {
                    // Fallback for older browsers
                    fallbackCopyEmail(email);
                }
            }

            function fallbackCopyEmail(email) {
                const textArea = document.createElement('textarea');
                textArea.value = email;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showEmailCopiedMessage();
                } catch (err) {
                    alert('Email: ' + email);
                }
                document.body.removeChild(textArea);
            }

            function showEmailCopiedMessage() {
                const contactLink = document.getElementById('contactLink');
                const originalText = contactLink.textContent;
                contactLink.textContent = '✓ Email kopieret!';
                contactLink.style.color = '#4caf50';

                setTimeout(() => {
                    contactLink.textContent = originalText;
                    contactLink.style.color = 'inherit';
                }, 2000);
            }
        </script>
    </p>



    <wyidbvbgs-riyxlfsi style="all: initial !important;"></wyidbvbgs-riyxlfsi>

</body>

</html>