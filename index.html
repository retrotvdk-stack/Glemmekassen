<!DOCTYPE html>
<html lang="da">

<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer-when-downgrade">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Retro Cartoon TV</title>

  <!-- 100% privacy-first analytics -->
  <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      /* Retro Wallpaper Pattern */
      background-color: #f0e6d2;
      background-image:
        linear-gradient(90deg, transparent 50%, rgba(255, 255, 255, .5) 50%);
      background-size: 50px 50px;
      height: 100vh;
      display: flex;
      flex-direction: row;
      /* Desktop: side by side */
      justify-content: center;
      align-items: center;
      font-family: 'Courier New', monospace;
    }

    .tv {
      width: 800px;
      height: 480px;
      /* Increased height proportionally */
      position: relative;
      padding: 20px;
      display: flex;
      flex-direction: row;
      border-radius: 24px;
      background: transparent;
      border: none;
      box-shadow: none;
      z-index: 0;
      max-height: 90vh;
      /* Final height constraint */
      max-width: 95vw;
      /* Final width constraint */
    }

    /* Background on pseudo-element to allow legs to be behind it */
    .tv::before {
      content: "";
      position: absolute;
      inset: 0;
      background: #5d4037;
      background-image: linear-gradient(90deg, #4e342e 0%, #6d4c41 20%, #8d6e63 50%, #6d4c41 80%, #4e342e 100%);
      border-radius: 24px;
      box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.6);
      border: 8px solid #3e2723;
      z-index: -5;
      /* Behind content but in front of legs (-10) */
    }

    .monitor-encasement {
      flex: 4;
      background: #111;
      border-radius: 24px;
      padding: 15px;
      box-shadow: inset 0 0 20px #000;
      border-bottom: 2px solid #333;
      display: flex;
      flex-direction: column;
    }

    .screen-bezel {
      width: 100%;
      height: 100%;
      background: #000;
      border-radius: 20px;
      overflow: hidden;
      position: relative;
      border: 4px solid #222;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
    }

    .screen {
      width: 100%;
      height: 100%;
      background: #050505;
      position: relative;
      /* subtle CRT curve effect could go here but keeping it simple for video visibility */
    }

    #staticVideo,
    #powerOffVideo {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
      z-index: 5;
    }

    #player {
      width: 100% !important;
      height: 100% !important;
      max-width: 100%;
      max-height: 100%;
      overflow: hidden;
      pointer-events: none;
      position: relative;
    }

    /* Ensure Dailymotion iframe and wrapper fit properly */
    #player iframe,
    #player .dailymotion-player-wrapper,
    #player .dailymotion-player,
    #player div,
    #player>* {
      width: 100% !important;
      height: 100% !important;
      max-width: 100% !important;
      max-height: 100% !important;
      min-height: auto !important;
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      object-fit: contain !important;
    }

    .label,
    .mute-icon,
    .volume-number {
      position: absolute;
      opacity: 0;
      transition: .3s;
      z-index: 10;
      font-weight: bold;
      text-shadow: 1px 1px 0 #000;
    }

    .label {
      top: 15px;
      left: 20px;
      color: #0f0;
      font-size: 18px;
    }

    .mute-icon {
      top: 15px;
      right: 20px;
      color: #f00;
      font-size: 18px;
    }

    .volume-bar-container {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 240px;
      height: 12px;
      background: #444;
      border-radius: 6px;
      opacity: 0;
      transition: .3s;
      z-index: 10;
      border: 1px solid #666;
    }

    .volume-bar {
      height: 100%;
      background: #0f0;
      width: 0%;
      border-radius: 5px;
    }

    .volume-number {
      bottom: 35px;
      left: 50%;
      transform: translateX(-50%);
      color: #0f0;
    }

    .side-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding-left: 25px;
      justify-content: flex-start;
    }

    .brand-plate {
      margin-bottom: 20px;
      text-align: center;
      font-weight: bold;
      color: #deb887;
      font-size: 20px;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-shadow: 0 1px 1px #000;
      border: 2px solid #3e2723;
      padding: 5px;
      background: #4e342e;
      box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.5);
    }

    .speaker-grille {
      flex: 1;
      background: repeating-linear-gradient(0deg,
          #2a1b15,
          #2a1b15 6px,
          #1a100c 6px,
          #1a100c 10px);
      border-radius: 8px;
      margin-bottom: 25px;
      box-shadow: inset 0 0 15px #000;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .controls-area {
      background: #4a3b32;
      padding: 15px;
      border-radius: 10px;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.6);
      display: flex;
      flex-direction: column;
      gap: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .control-row {
      display: flex;
      gap: 10px;
      justify-content: space-between;
    }

    button {
      flex: 1;
      height: 44px;
      background: #222;
      border: none;
      border-radius: 4px;
      color: #aaa;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 0 #000;
      transition: transform 0.1s, box-shadow 0.1s;
      font-size: 12px;
      text-transform: uppercase;
      border-top: 1px solid #444;
    }

    button:active {
      transform: translateY(3px);
      box-shadow: 0 1px 0 #000;
    }

    button.power-btn {
      background: #800;
      color: #ffcccc;
      border-top: 1px solid #a00;
    }

    button.power-btn:active {
      background: #600;
    }

    /* Banned Item Style */
    .program-item.banned {
      text-decoration: line-through;
      color: #999;
      position: relative;
    }

    .program-item.banned::after {
      content: '❌';
      position: absolute;
      right: 10px;
      color: red;
      font-size: 14px;
    }

    .program-item.now-playing {
      background: #ffe0b2;
      font-weight: bold;
      border-left: 4px solid #ff9800;
    }

    .program-item.up-next {
      background: #e8f5e9;
      border-left: 4px solid #4caf50;
    }

    .status-badge {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      margin-right: 5px;
      display: inline-block;
      width: 45px;
    }

    .program-item.ad-break {
      background: #eee;
      color: #555;
      font-style: italic;
      cursor: default;
    }

    .program-item.ad-break:hover {
      background: #eee;
    }

    /* --- LAYOUT & TV GUIDE --- */
    #main-layout {
      position: relative;
      display: flex;
      flex-direction: row;
      /* Desktop: side by side */
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
      gap: 60px;
      /* Gap to keep guide away from TV */
      overflow: hidden;
      transition: gap 0.3s ease;
    }

    #main-layout.guide-collapsed {
      gap: 0px;
      /* TV centers naturally without margin when sidebar is absolute */
    }

    .tv-guide {
      width: 300px;
      height: 480px;
      background: #fdfbf7;
      border: 1px solid #d3d3d3;
      box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.2);
      padding: 20px;
      font-family: 'Times New Roman', serif;
      color: #333;
      overflow-y: auto;
      border-radius: 2px;
      position: relative;
      z-index: 100;
    }

    /* Magasinryg effekt - hidden on mobile */
    @media (min-width: 769px) {
      .tv-guide::before {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 4px;
        background: #aaa;
        /* Binding */
      }
    }

    .guide-header {
      text-align: center;
      border-bottom: 2px solid #333;
      margin-bottom: 15px;
      padding-bottom: 10px;
    }

    .guide-header h2 {
      margin: 0;
      text-transform: uppercase;
      font-size: 24px;
      letter-spacing: 1px;
    }

    .guide-header span {
      font-size: 12px;
      color: #666;
      font-style: italic;
    }

    .channel-block {
      margin-bottom: 20px;
    }

    .channel-title {
      font-weight: bold;
      background: #eee;
      padding: 4px 8px;
      margin-bottom: 5px;
      border-bottom: 1px solid #ccc;
      font-size: 14px;
      text-transform: uppercase;
    }

    .program-slot {
      display: flex;
      align-items: center;
      border-bottom: 1px dotted #e0e0e0;
      min-height: 28px;
    }

    .program-badge {
      width: 50px;
      font-size: 10px;
      font-weight: bold;
      color: #666;
      text-transform: uppercase;
      flex-shrink: 0;
    }

    .program-content {
      flex-grow: 1;
      font-size: 13px;
      padding: 4px 8px;
      cursor: pointer;
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    }

    .program-content:hover {
      background: #fff8e1;
      font-weight: bold;
    }

    .program-content.banning-anim {
      opacity: 0;
      transform: translateX(20px);
      pointer-events: none;
    }

    .program-content.ad-break {
      background: #eee;
      color: #555;
      font-style: italic;
      cursor: default;
    }

    /* Scrollbar styling for retro feel */
    .tv-guide::-webkit-scrollbar {
      width: 8px;
    }

    .tv-guide::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .tv-guide::-webkit-scrollbar-thumb {
      background: #ccc;
    }

    .tv-guide::-webkit-scrollbar-thumb:hover {
      background: #999;
    }

    /* GUIDE TOGGLE BUTTON */
    .guide-toggle {
      background: transparent;
      border: none;
      font-size: 18px;
      cursor: pointer;
      position: absolute;
      right: 15px;
      top: 12px;
      padding: 5px;
      transition: transform 0.3s ease;
      color: #333;
    }

    .guide-toggle:hover {
      color: #000;
    }

    /* COLLAPSED GUIDE STATE */
    .tv-guide.collapsed {
      width: 40px;
      padding: 20px 5px;
      overflow: hidden;
      position: relative;
    }

    .tv-guide.collapsed .guide-header h2,
    .tv-guide.collapsed #guide-content,
    .tv-guide.collapsed #week-display {
      display: none;
    }

    .tv-guide.collapsed .guide-header {
      border-bottom: none;
    }

    /* Hide border when TV is off (no content) */
    .tv-guide:has(#guide-content:empty) .guide-header {
      border-bottom: none;
    }

    .tv-guide.collapsed .guide-toggle {
      right: 50%;
      transform: translateX(50%) rotate(180deg);
      top: 50%;
      margin-top: -12px;
    }

    /* SMOOTH TRANSITIONS */
    .tv-guide {
      transition: width 0.3s ease, padding 0.3s ease;
    }

    #tv {
      transition: transform 0.3s ease;
    }

    #tv.expanded {
      transform: scale(1.35);
      /* Removed translateX to keep it centered when expanded */
    }





    /* LEGS STYLES */
    .leg {
      position: absolute;
      bottom: -25px;
      width: 25px;
      height: 40px;
      background: linear-gradient(to bottom, #4e342e, #281a16);
      border: 3px solid #1a100c;
      border-top: none;
      box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.5);
      box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.5);
      z-index: -10;
      /* Behind .tv::before (-5) */
    }

    .leg.left {
      left: 80px;
      transform: skewX(15deg);
      border-radius: 0 0 5px 15px;
    }

    .leg.right {
      right: 80px;
      transform: skewX(-15deg);
      border-radius: 0 0 15px 5px;
    }

    /* Range Slider Styling */
    .retro-slider {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      background: #222;
      outline: none;
      border-radius: 4px;
      border-bottom: 1px solid #555;
      box-shadow: inset 0 1px 3px #000;
      appearance: none;
    }

    .retro-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 20px;
      background: #555;
      cursor: pointer;
      border: 1px solid #777;
      border-radius: 2px;
      box-shadow: 0 2px 2px #000;
    }

    .retro-slider::-moz-range-thumb {
      width: 14px;
      height: 20px;
      background: #555;
      cursor: pointer;
      border: 1px solid #777;
      border-radius: 2px;
      box-shadow: 0 2px 2px #000;
    }

    /* TOGGLE SWITCH - RETRO MECHANICAL STYLE */
    .toggle-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding-top: 5px;
      border-top: 1px solid rgba(0, 0, 0, 0.2);
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 46px;
      height: 24px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 50%, #1a1a1a 100%);
      transition: .3s;
      border-radius: 3px;
      box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.8), 0 1px 0 rgba(255, 255, 255, 0.1);
      border: 2px solid #2a2a2a;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 2px;
      bottom: 1px;
      background: linear-gradient(135deg, #666 0%, #444 50%, #333 100%);
      transition: .3s;
      border-radius: 2px;
      box-shadow: 0 3px 5px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.2);
      border: 1px solid #555;
      /* Ridged texture effect */
      background-image: repeating-linear-gradient(90deg,
          transparent,
          transparent 2px,
          rgba(0, 0, 0, 0.3) 2px,
          rgba(0, 0, 0, 0.3) 3px);
    }

    input:checked+.slider {
      background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 50%, #1a1a1a 100%);
    }

    input:checked+.slider:before {
      transform: translateX(14px);
    }

    .ad-led {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: #333;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
      transition: background-color 0.3s, box-shadow 0.3s;
      margin-left: 5px;
    }

    .ad-led.on-green {
      background-color: #4caf50;
      box-shadow: 0 0 5px #4caf50;
    }

    .ad-led.on-red {
      background-color: #f44336;
      box-shadow: 0 0 5px #f44336;
    }

    .toggle-label {
      font-size: 8px;
      color: #888;
      text-transform: uppercase;
      font-weight: bold;
    }

    /* Support Link / Coffee Badge (Sidebar Placement) */
    .guide-sidebar {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      height: 480px;
      /* High enough to align with TV */
      justify-content: flex-start;
      transition: opacity 0.3s ease, transform 0.3s ease, position 0s ease 0.3s;
    }

    /* Position sidebar absolutely when guide is collapsed so TV can center */
    .guide-sidebar:has(.tv-guide.collapsed) {
      position: absolute;
      right: -50px;
      /* Place at very edge of screen, slightly beyond */
      top: 50%;
      transform: translateY(-50%);
      z-index: 1;
      /* Lower than TV so it doesn't overlap */
    }

    .coffee-link {
      text-decoration: none;
      width: 100%;
      max-width: 300px;
      transition: transform 0.2s ease, opacity 0.3s ease;
      display: block;
    }

    /* Hide button when tv-guide is collapsed */
    .tv-guide.collapsed+.coffee-link {
      opacity: 0;
      pointer-events: none;
      transform: translateY(10px);
    }

    .coffee-plate {
      background: #f4c430;
      color: #3e2723;
      text-align: center;
      font-weight: bold;
      font-size: 11px;
      padding: 12px 18px;
      border-radius: 4px;
      border: 3px solid #5d4037;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      transform: rotate(-1deg);
    }

    .coffee-plate:hover {
      background: #ffdb58;
      transform: rotate(0deg) scale(1.05);
      box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.3);
    }

    .coffee-plate:active {
      transform: scale(0.95);
    }

    /* ANTENNA STYLES */
    .antenna-container {
      position: absolute;
      top: -60px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 80px;
      z-index: -20;
      /* Behind TV */
      pointer-events: auto;
      cursor: pointer;
    }

    .antenna-base {
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 30px;
      background: radial-gradient(circle at 30% 30%, #a0a0a0, #404040);
      border-radius: 30px 30px 5px 5px;
      box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
      border: 2px solid #2a2a2a;
      z-index: 1;
    }

    .antenna-rod {
      position: absolute;
      bottom: 5px;
      left: 50%;
      width: 4px;
      height: 250px;
      background: linear-gradient(90deg, #d0d0d0, #f8f8f8, #a0a0a0);
      border-radius: 2px;
      transform-origin: bottom center;
      border: 1px solid #666;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
    }

    .antenna-rod.left {
      transform: translateX(-50%) rotate(-35deg);
    }

    .antenna-rod.right {
      transform: translateX(-50%) rotate(35deg);
    }

    /* Telescopic segments visual trick */
    .antenna-rod::before {
      content: "";
      position: absolute;
      top: 30%;
      left: -2px;
      width: 6px;
      height: 10px;
      background: radial-gradient(circle, #e0e0e0, #808080);
      border: 1px solid #444;
      border-radius: 2px;
    }

    .antenna-rod::after {
      content: "";
      position: absolute;
      top: 60%;
      left: -2px;
      width: 6px;
      height: 10px;
      background: radial-gradient(circle, #e0e0e0, #808080);
      border: 1px solid #444;
      border-radius: 2px;
    }

    .antenna-tip {
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ff0000, #800000);
      border: 1px solid #400000;
      box-shadow: 0 0 2px #000;
    }


    /* iOS Tap to Start Overlay - DISABLED */
    #iosOverlay {
      display: none !important;
    }

    /* ========================================
       RESPONSIVE MOBILE STYLING
       ======================================== */

    /* iPad and smaller tablets (landscape) - HORIZONTAL GUIDE */
    @media screen and (max-width: 1024px) {
      body {
        padding: 10px;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        gap: 15px;
      }

      #main-layout {
        flex-direction: column;
      }

      .tv {
        transform: scale(1.0);
        transform-origin: center;
        margin: 0;
      }

      #tv.expanded {
        transform: scale(1.0);
      }

      /* Horizontal guide below TV */
      .tv-guide {
        position: relative;
        width: 100%;
        max-width: 95vw;
        height: 180px;
        transform: none;
        right: auto;
        top: auto;
        flex-direction: column;
        display: flex;
        visibility: visible;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      .tv-guide.collapsed {
        height: 50px;
        overflow: hidden;
      }

      .guide-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 15px;
        border-bottom: 2px solid #333;
        margin-bottom: 10px;
      }

      .guide-header h2 {
        font-size: 18px;
        margin: 0;
      }

      .guide-toggle {
        display: none;
        /* Hide collapse button on mobile - guide should always be visible */
      }


      #guide-content {
        display: flex;
        flex-direction: row;
        overflow-x: auto;
        overflow-y: hidden;
        gap: 15px;
        padding: 0 10px 10px 10px;
        height: auto;
        min-height: 100px;
        -webkit-overflow-scrolling: touch;
      }

      .channel-block {
        min-width: 200px;
        flex-shrink: 0;
        display: block;
        visibility: visible;
      }
    }

    /* iPad (portrait) and large phones (landscape) - HORIZONTAL GUIDE */
    @media screen and (max-width: 768px) {
      .tv {
        transform: scale(0.9);
      }

      .tv-guide {
        height: 160px;
      }

      .tv-guide.collapsed {
        height: 45px;
      }
    }

    /* iPhone and smaller devices */
    @media screen and (max-width: 430px) {
      body {
        padding: 5px;
        align-items: center;
        justify-content: flex-start;
        padding-top: 20px;
        overflow-x: hidden;
      }

      .tv {
        transform: scale(0.68);
        transform-origin: center center;
        margin: 0 auto;
      }

      #tv.expanded {
        transform: scale(0.65) translateX(-15px);
      }
    }

    /* Very small phones (iPhone SE, etc.) */
    @media screen and (max-width: 375px) {
      body {
        padding: 3px;
        padding-top: 15px;
      }

      .tv {
        transform: scale(0.52);
        margin: 0 auto;
      }

      #tv.expanded {
        transform: scale(0.58) translateX(-10px);
      }
    }
  </style>


</head>

<body>



  <div id="main-layout">
    <div class="tv" id="tv">

      <!-- Antenna -->
      <div class="antenna-container" onclick="antennaFumble()" title="Justér antenne">
        <div class="antenna-rod left">
          <div class="antenna-tip"></div>
        </div>
        <div class="antenna-rod right">
          <div class="antenna-tip"></div>
        </div>
        <div class="antenna-base"></div>
      </div>

      <!-- Legs visual -->
      <div class="leg left"></div>
      <div class="leg right"></div>


      <div class="monitor-encasement">
        <div class="screen-bezel">
          <div class="screen">
            <video id="staticVideo" loop muted playsinline webkit-playsinline
              src="https://cdn.pixabay.com/video/2018/04/20/15708-266043570_large.mp4"></video>
            <video id="powerOffVideo" muted playsinline webkit-playsinline
              src="https://cdn.pixabay.com/video/2019/09/25/27228-362518551_large.mp4"></video>
            <div id="player"></div>
            <div class="label" id="label">TV slukket</div>
            <div class="mute-icon" id="muteIcon">MUTE</div>
            <div class="volume-bar-container" id="volumeContainer">
              <div class="volume-bar" id="volumeBar"></div>
            </div>
            <div class="volume-number" id="volumeNumber">50</div>
          </div>
        </div>
      </div>

      <div class="side-panel">
        <div class="brand-plate">RETROVISION</div>
        <div class="speaker-grille"></div>
        <div class="controls-area">
          <button class="power-btn" onclick="power()" aria-label="Power">POWER</button>
          <div class="control-row">
            <button onclick="chDown()" aria-label="CH-">CH -</button>
            <button onclick="chUp()" aria-label="CH+">CH +</button>
          </div>
          <div class="control-row">
            <button onclick="volDown()" aria-label="VOL-">VOL -</button>
            <button onclick="volUp()" aria-label="VOL+">VOL +</button>
          </div>
          <div class="control-row" style="justify-content: center; align-items: center; padding-top: 5px;">
            <!-- Color Slider -->
            <div class="brightness-label"
              style="font-size: 8px; color:#888; text-transform:uppercase; margin-right:5px; font-weight:bold;">Farve
            </div>
            <input type="range" id="saturationSlider" min="0" max="200" value="100" class="retro-slider"
              oninput="setColor(this.value)">
          </div>
          <div class="control-row" style="justify-content: center; align-items: center; padding-top: 5px;">
            <!-- Brightness Slider -->
            <div class="brightness-label"
              style="font-size: 8px; color:#888; text-transform:uppercase; margin-right:5px; font-weight:bold;">Lys
            </div>
            <input type="range" id="brightnessSlider" min="20" max="150" value="100" class="retro-slider"
              oninput="setBrightness(this.value)">
          </div>
          <div class="toggle-container">
            <span class="toggle-label">Reklamer FRA</span>
            <label class="switch">
              <input type="checkbox" id="adToggle" checked onchange="toggleAds(this.checked)">
              <span class="slider"></span>
            </label>
            <span class="toggle-label">TIL</span>
            <div id="adLed" class="ad-led"></div>
          </div>
          <button onclick="muteToggle()" aria-label="Mute">MUTE</button>
        </div>
      </div>
    </div>

    <!-- TV GUIDE SIDEBAR COLUMN -->
    <div class="guide-sidebar">
      <div class="tv-guide" id="tvGuide">
        <div class="guide-header">
          <h2>TV Oversigt</h2>
          <button class="guide-toggle" onclick="toggleGuide()" aria-label="Toggle guide">◀</button>
          <span id="week-display" class="week-badge"></span>
        </div>
        <div id="guide-content">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- Support Link -->
      <a href="https://buymeacoffee.com/retrokyllingen.dk?new=1" target="_blank" class="coffee-link">
        <div class="coffee-plate">
          <span style="font-size: 18px;">☕</span> KØB MIG EN KAFFE
        </div>
      </a>
    </div>

  </div>

  <script>
    // Setup OSD Hover Logic
    document.addEventListener('DOMContentLoaded', () => {
      const tv = document.getElementById('tv');
      const label = document.getElementById('label');

      label.style.opacity = 0; // Ensure it starts hidden

      tv.addEventListener('mouseenter', () => {
        if (on) {
          // If a sticky OSD (like Reklamer) is already showing, don't overwrite it immediately
          if (!label.sticky) {
            label.innerText = `${current + 1}. ${channels[current].name}`;
            label.style.opacity = 1;
          }
        }
      });

      tv.addEventListener('mouseleave', () => {
        label.style.opacity = 0;
      });
    });
  </script>

  <audio id="clickSound" preload="auto"
    src="https://orangefreesounds.com/wp-content/uploads/2017/01/Button-click-sound.mp3"></audio>

  <audio id="staticSound" preload="auto">
    <source src="https://www.orangefreesounds.com/wp-content/uploads/2014/11/Static-sound-effect.mp3" type="audio/mpeg">
  </audio>

  <audio id="powerOffSound" preload="auto"
    src="https://www.orangefreesounds.com/wp-content/uploads/2022/03/Tv-turn-off-sound-effect.mp3"></audio>

  <audio id="toggleSound" preload="auto"
    src="https://www.orangefreesounds.com/wp-content/uploads/2017/01/Button-click-sound.mp3"></audio>

  <!-- YouTube API loaded asynchronously in JS to ensure callback is ready -->
  <!-- <script src="https://www.youtube.com/iframe_api"></script> -->
  <script src="https://geo.dailymotion.com/libs/player/x7zes.js"></script>

  <script>
    const channels = [
      {
        name: "Cartoon Network",
        series: {
          "Tidspatruljen": ["S3U8Fwhx2q8"],
          "Sabrina: Den animerede serie": ["SOdfs26p1oU", "ObyWPvitzMU", "I45Y4XQsKk8", "XlOqCW9vYuQ", "G--QnsGcNQ4"],
          "Juniper Lee": ["00UzN-E-MOc", "qfKVmTs374I", "Fdy3v0nuxP8", "2d1Y4emvz_Q", "cu8dJZ6-PWs", "7Hqciu7pfhA"],
          "Ed, Edd og Eddy": ["BhQnCEbksX8", "qbTaekKhnFc", "KficyJz8L4U", "UJ-gmM401mw", "9v22NRqsIt8", "xn1T8L9yU7Q", "U2ePD1yqXQc", "iKmEVvY6Z4E", "2ZdqzRgDtSI", "pLNtRtPiYcM", "hw2kaIxa--w", "iKmEVvY6Z4E", "2ZdqzRgDtSI", "cZRxPYTlbag", "udkwBO3pZ7w", "tTiwuTPam-k", "vkod5pdBupQ", "H7Toz0JmY9Y", "h7x6kQ9tzsA", "MoF0fex3iHA"],
          "Camp Lazlo": ["6maqwk8obic"],
          "Krampe Tvillingerne": ["1cJpDlN9jhA", "Njl3AUS706A", "V60ed2fnFqo", "rNwYrgsPySk", "sn2CrnF8WpI", "MaLLTk2Ve84", "-Vmmu6kTVVA", "eOvxWxkKTyI", "xmCIEzvMA2g", "d3E5D3Etv70", "O51r0T3mf2o", "PRld4zaLtQI", "8-uyvrFRukI", "Oscgy7GInl4", "EngJ7fAWCpA", "3qJn913yi0M", "zqP1-F_6LR4", "QN3sw11V9QI", "fhtVyxgceXM", "a6uWM38fUWI", "CweP6EZgJNM", "-jUWdoD9o-o", "ok_bOzghySo", "A2mYNZ2cblY", "PI9O5ZBx5Vk", "klrLNsm8bAs", "Lq2FtOjSz1Y", "i9ciAWxsxbA", "8-4vQV4UOX4", "Ejj-obomZ0U", "T6Zdr3XaojM", "yXVWjfWcYW8", "I7Gr3CaQcnU", "qFcmBoJlPhw", "VZVHpniPxtk", "C86EdTBgFbE", "_Gd5gbIkYjo", "jFoABBHb5Hc", "pAJQlsEm4cw", "mjatRo4NUPo", "t8HJMx1_xgo", "yf3fDaOyGRc", "vHgMCcaF6zc", "QzVZFZP3bmY", "0LlHp9FoozA", "DzhkZ-Ch6x4", "V8aMc-JFFN4", "tMeBgsVokUQ", "esWyZ_vfrTc", "vafgFOrCnJY"],
          "Familien Flintstone": ["GitWzr2c4sc", "CnQsTmPakkU", "mjpMv2f_SwM", "QVBNzERonb8", "_tbcDj3wLIo", "4N_dBIQ151U"],
          "Powerpuff Pigerne": ["YkWuPoDz1vs", "50mVPTaZz3o"],
          "Chowder": ["YXAKI8vQ9MQ", "dODLuN8n4hg"],
          "Johnny Bravo": ["SKlC4AQc5xA", "Q70N3uSbTVM", "ByFl6PRmP-I", "vqAgvFSKEjs", "y_rsJZIzQB4", "yNMDtj1nNpM", "T0Q9q427DhY", "B4otvbWvjTU", "qFwOM538wWg", "l6R-da2-XKc"],
          "Scooby Doo": ["A9JEbTvmF24", "Tt7Bqt1m1wY", "jUmOr7fZZ0o", "faud2kc-a7I"],
          "Ben 10": ["3J5IUPOTK7U"],
          "Looney Tunes": ["lQvM8S-HHgA"],
          "Batman: Den tapre og modige": ["Cy6xkqfdSbI"],
          "Får i Storbyen": ["oEqPbg3wPdk"],
          "Foster’s hjem for fantasivenner": ["X9GjZDawyL4", "giIOFnwLVzM", "813YzofZh_M", "56nP95hRt2c", "wipx_2OnvCo", "F-lM3W4pYkk", "TrWErP_UObc", "D3hLFK31iw8", "Ys2OUpvcXCM"],
          "Kodenavn: Naboens børn": ["cspDSLHGv_M", "iaxoHtDXWig"],
          "Ko og Kylling": ["k97ScATFM8U", "SeY1FpxnWm0", "ZyuyeifZazs", "ZE9X17CrpO8", "bha4HQXCVmE", "s3PB2_Ltoxg", "Rall9ncURwc", "H-hEgyUJz34", "3BR7wDUgeO8", "itzx5pvkqF8", "aY6hoJbyOZI", "frRgj11QXBE", "qy7mJR-iaA8", "b0f5GG7TW_0"],
          "Kaptajn Rune Renlig": ["qDfB7qwtegs"],
          "Haj og Henning": ["OsLQgXoS994"],
          "Fedtkattene": ["Dnz8IjSTtxs"],
          "Gunnar og Sune": ["So7BtN_F9nc"],
          "Tag to, betal for en": ["qrP7RH2IXf8", "_esXP0K5Sk0", "qbBehMStxqA"],
          "Dexter’s laboratorium": ["F-9sesft0lw", "dp4QKCaikVY", "cYDGKOD-g54", "f70dsgpD5CE", "7PkbzK_iGPs", "6BGwqIYZ4Ns", "loocTs2UXkM", "JdLjJhasQek", "dGrHnUJouG8", "JdLjJhasQek", "evnoxjtvXrg", "T7xTcj72oxQ", "A3ZnirIbbXE", "loT9Zt9IBiM", "tS9w3araFAA", "RdL_QdZdu4o", "u2bOuuffmwY"],
          "Robotboy": ["eIjb1oZMNc4", "IT0jAy4IVNg", "uilUjYuUtck", "gNYyUsD0g3c", "fP8FPqrqOW0", "_46YMGDru8", "B5PSWQkzeic", "5Jzx0pHqelE", "ISe3z9OEHFc", "dA8jEfCI9pE", "r8mIlHd8WJs", "tcpgGrS_x0o", "sBQuVP2Z_B8", "EyZuSeo8KKU", "9eqBSLrSSRY", "DGfoTwdwFjc", "TMHRXf44Ihc", "h7j7azB7oGI", "pqdlm2LJiUo", "gTlxMgSQcYU", "3KFQvcmqsxA", "rJJkWOPc3fM", "setXpQiH_Mg", "Q-RlF9aLRvE", "2WLCA5V6laE", "3dzwiJ1GQb4", "nQ_61aVj3a0", "DTv0SSHKn7Q", "JlsxQGzms3U", "zI4IhhbZ3Pk", "cATwR-IjRcw", "5Td6r02WmUQ", "L0cxbXdTBQU", "FOu7MJn_Omk", "AVaiRfiVGAw", "0gcJCYcKAYcqIYzv", "M5b8aoN4ASg", "vrnPEioga0I", "np4DPKZUtGk", "ctAXNzaNfXc", "AQGHP2ZI7pM", "CgPtwz6CaX4", "zFDG9DlPrJ0", "d0qGysvsJUQ", "xgM7xma5G9A", "Niv0fTHvDTM", "xNsB5TcK8ys", "kVxTGrNXAPs"],
          "Jackie Chan Adventures": ["oNLBxtUxOKs"],
          "Frygtløs den frygtsomme hund": ["n3ONGMAGh8k", "q1qy2AE0meE", "J59auG6dD4Y", "RZle6X4yDFQ", "A5D7CiHtzH8", "x6MlwDW0Wzw", "Y3bEzvQlD_Q", "eTrEJbu5T7M", "K2waTzIJpdY", "wlr1IqKPia0", "b1LLO3Ol02s", "ZFQJptU4UWQ", "vGVJG7u0CU", "yKwaNrprfmE", "L2Ert3vPdbs", "Y1nTBZfBUqE", "Xko2ZG3eZr0", "unanmjdHS2o"],
          "Familien Jetson": ["1hPNDLP77cE", "pxcEeZW5fUY", "mvH69jX24EI"],
          "Jeg er Væsel": ["BQgGfLLjbCY"]
        }
      },
      {
        name: "Disney Channel",
        series: {
          "Legenden om Tarzan": ["w1olCJ3g98U", "amy4PzB_MHo", "wn77F5TX7VA", "i39mbdx2d1U", "upyWvx1z75s", "-grXg0n_wVI", "fmhdSho74rM", "HdON75xe6Og", "o5xIeFSHXUE", "mHnDY5IcRJM", "PtYJgMvIBj8"],
          "Frikvarter": ["kZgDK8eMKyI", "5Nw-20vEsJI", "fXD71RmheyA"],
          "Brandy og Hr. Wimse": ["fYOfGZy4ENM", "ZMWVLORH-FA", "ES0nKwEMOIU", "LnwXLju-XDw", "3tKHDWC1lD4", "Vo2YHTW8KrY", "tF9F6cCNH3U", "Y2AWBSVp1sI", "81SRPYBNc-4", "9MwK0W4-0cg", "ktCg7ogKUy8", "Ldi88MkRmv4", "cmHfAOSJ3Tg", "G2JCHgtViXU", "C-UQFXOUq4w", "QNTBCoJdbc4", "i_aeOtOp3U0"],
          "Barbaren Dave": ["KK6WO8h1b84", "rEKwKmf5xP8", "YwSHsT_LiVA", "XYFdkFzmEug", "sZiaT1l8JI8", "3Dbn0KqbvMY", "URAQseQvP4c", "2FrTDN33a_0", "SOMOC8OCobE", "I9dx8fo-RJU", "rsTUjOUt8BE", "wj19J-Uhyfw", "tHF9VS5TJ-U", "uIl6Q-SEYN4", "-m74C1A4TFc"],
          "Filmore!": ["NW7QHaz3kKE", "nkZAJL3BBwY", "mIyXivF_2XI", "nKLCAlmHzkI", "P3S4_fqgC98", "77cvJbnt6S4", "y3Rx-2uUDz8", "nOW0blBVTzE", "egwqd3WGTN8"],
          "Lloyd I rummet": ["vkWeQm9qRCw", "9JYjtx00GB4", "OmpHmOMLi6U", "5YB_5qgXZnQ", "yPzY7NhqLAY", "Y3-XLJlv0jQ", "_JJQikHPSRI", "R2O5m3qFQXI", "9qFpmtgIGpI", "jKzWvNx7XBo", "NiUew9usjV0", "FZL3PeLslz4", "Gms6YwqVBt0"]
        }
      },
      {
        name: "Fox Kids",
        series: {
          "Puslekrogen": ["HJnSdzPmYa0"]
        }
      },
      {
        name: "Jetix",
        series: {
          "Oban Star Racers": ["KG1SHsBTTA8", "8xaE3zIToWc", "U76bVRyiW0s", "FcTEVV-4-dw", "Y7kL7ltJTnI", "TP6io9gyoa0"],
          "A.T.O.M": ["6t6yO4cgWnY", "-_czQHx4Ns", "vTRaCQF_kjE", "nUeyiD4jQYs", "ig5qr4tBv4g", "PIV55gT3b28", "0Za-4iKgWKs", "R-A7kbOsyLU", "ztXk1glYC1c"],
          "Den magiske skolebus": ["rln8CplA2mg", "ikgcgGw6uf8", "WNIDvLs6hng", "ACmN2-OOHFI", "hvmtunuUSGk", "Pxi9_4Iv6W0", "j7n85Vs0J0A", "DfqBv1Dcvvk", "fpy4ffC0Qus", "PnnUPhTpkFo", "Kzcd7ohR9ss", "4WRxizns7OU"],
          "Team Galaxy": ["pXXHm6oS8ew", "NA8qJEfntbU", "9Py9Cq9MJOc", "x6KwoRTo4sE", "Eq4LmDY1j2c", "OFSTYDXAPKw", "FeVz5jdemXI", "MUqN_SpGVVo", "z2CldCFPvIU", "IrsvR4ntftI", "w8bGkTvX_no", "SCK4z6GvqEc", "KGGNXA-H7o0", "wjDuwyERCeg", "AOAgOXk5Q4U", "ONmiN-TW2wo", "x_EjzAsMbEE", "jxXz4_dCIps", "kO6ZNLtt5EQ", "A2H2GGByYL4", "SaUn0e5HoL0", "zDuM_K3wNkI", "6NTgUlo33Ic", "dwkcoHUhCuE", "BqPIypKCjOY", "iXdAgQJtuCU", "5FmNFmpRgBE", "NNktZWdAaaU", "Ok5tRQ8EUE0", "RTQbvEHHW3M", "dz1wcCzLb9c", "cWbSYLUVuYk", "1MJeVbSAAy0", "umLoHqyFmFE", "FcyzjrXEBaA", "Gv1yrQJJWsI", "Mu0jbRLy5Bo", "7eO7XHpyoPg", "Nn-RStIsR7c", "TtQVg_hIBDg", "DCje-_VYDtk", "gLRkHBfQX0w", "NjtQkbhFg3M", "_hGTgQ9eqK4", "WCIdp7fszzk", "bUW3FrqJaBM", "ez_rRxDdX9w", "6hf95Phk5wk", "kyTGrtwNJrU", "wHqx7mGiAGo", "uDPKEEJQXN4", "oXs3t6tEvQE"],
          "Martin Mysterie": ["tEYFphJHklM", "_wrYSHg_FSY", "ifzjnPpyvcY", "0Dzzv4q5eUc", "YzGZv3Q3hPI", "-s9uo0xHZjE", "nJzJZeXFSRc", "znuJcTaw9zI", "RHmEbAf5hL0", "qcUoMZ6_OBw", "yC1Rl19e-RU", "Au46kjFDmpY", "yk8Y8m3enWg", "uamX9T-_TV4", "oBPRdkhtqVw", "GYP5M3xh2wA", "67IeBz65roE", "Zam7Wu6NLxM", "eqZOI3F8dAk", "iIbld58p6Bo", "YsleFluh9ks", "i-D1-kCz36U", "NH-M2rLKmoM", "Z5IWK_pou7Y", "n-BFTyB--9Y", "_lbdN9Nj5bs", "0x8FdW6kAcQ", "WQLuaPqEyfs", "kYrQk_wSagE", "bGu0vbsFgLM", "pcMP9VVCGF4", "2vP6eqxz2VI", "TK3DJ5II48E", "YmzwXVl8zYM", "Jl4evC8jKis", "8cZqspiUQmo", "Mrm_XbQBEjI", "kg89vhN4Gy4", "yvpzxRgi_Sk", "_cIPEKWx-qc", "oKW63YnlRaU", "9oPJnaZMt7g", "Fc_NoR8qkVQ", "i-9CsnX3hl8", "FqM4WI6WE90", "pOxFm3cMSd0", "h6P4cLKy8xo", "YUXeOmV69B4", "fVnDY9lJTdM", "cQuOVmTATaM", "sy0TerlqYpQ", "JSRU_kOSTFU", "SPCIIVFlNmo", "gRt6JYWvXaY", "ioSqC03R2cE", "qyU_cZcXYzQ", "a6NCidcjpmo", "hqNctZI88Z0", "IcfO-qRCCcY", "XzLqIovmheo", "Dq_imRYnjQw", "I9ZJSH1vPKA", "JQQVoq3zKjA", "vyfdZy41SWI", "6F4TTaqo5Zo"]
        }
      },
      {
        name: "RetroVision Blandet",
        series: {
          "Braceface": ["3-8ybymuT7E", "F0GDN2F67D4", "C8Kruj34fQg", "y3iFvC3gF0I", "y3iFvC3gF0I", "-FfxuawrqgU", "VuOOxzdVu_c", "fZB_Q8xyIaU", "1Y_TTXTyoC4", "E8GMFKBm9PM", "V0gI5PWt9Zg", "hCx_F0gpH4g", "t1CiqE-4wYc", "6Y9aVP46L5U", "J_Ji2c0Fs0o", "vxvOSLrBWQU", "wjFgCgxATks", "4SFfjTrPbGs", "4Y9eofemkvE", "vFUFuxVmD4w", "UKcsJj5IaQw", "MAqVD9iCESU", "1I7R4MHCZDo", "Ucrb1q_eTEE", "lvT3cpj4xmM", "ogJwFxIGLPo", "kw2C8vDE-3U", "MaXGpcwgFZo", "eQeZB5oZues", "v9eqFkvqiko", "G9kGCWBEp9g", "R-JWGN1Q8ck"],
          "Hamtaro": [
            "iframe:https://archive.org/embed/hamtaro-episode-1-danish?autoplay=1&play=1&start=0",
            "iframe:https://archive.org/embed/s-01e-02.-the.-ham-ham.-clubhouse.-wizz.-dk?autoplay=1&play=1&start=0",
            "iframe:https://archive.org/embed/s-01e-03.-calling.-all.-ham-hams.-wizz.-dk?autoplay=1&play=1&start=0",
            "iframe:https://archive.org/embed/s-01e-04.-come.-out.-bijou.-wizz.-dk?autoplay=1&play=1&start=0",
            "iframe:https://archive.org/embed/s-01e-05.-diamonds.-of.-sugar.-wizz.-dk?autoplay=1&play=1&start=0",
            "iframe:https://archive.org/embed/s-01e-06.-first.-time.-at.-the.-beach.-wizz.-dk?autoplay=1&play=1&start=0"
          ],
          "Richard Scarrys Travle Verden": ["cM01SH5IYYo", "JCq_hSExlnQ"],
          "Superman": ["t51Si5XEgxg", "RcJFaH9MQ0E", "4Ygh3a1oipo", "-hVs5ZhFJj8", "Ewn4e_RklpM"],
          "Kong Arthur": ["AAYUd9BEQu4", "LKNFKFq6LTs", "X736zvAOd1c"],
          "Trolderi": ["L0uBXAQJFl8", "bo9wIU5k05U", "RvDgiXg41cE", "S-0asq0aldg", "Sa7GdXXGMyA", "dWz5cWNsxfk", "70NnRJ4AiME", "8TH9frVU4yc", "Lm6MEhI9CR4", "D1TJ6rIiE8c", "o8h_pufyly4", "lR5Ze5mMQHk", "lFigeEXk9pI", "jHMnncfmU0M", "8nZ-ELgWFjM", "hVrT-U6pW34", "w8OW2f-guuE", "qbxi1aQR9ug", "7bpKl5JTPWc", "Nq28Hl3eybY", "_T5awqqfdP0", "Q8n8bdTjCMs", "w-RSSrfMa8E", "Lm6F-dB_rnk", "rMXJEVeiKPU", "bmxGoFpCIL8"],
          "Duedrengen": ["GX6zTpSuHko", "6mdGulMapHw", "FIgqbpeRPls", "NohZIaUwdDg"],
          "De tre venner og Jerry": ["hr-jNsLgM-w", "dZpMoAQIP-k", "GQBRd2fN-bU", "qHDX722bZMM", "IQkm3Bkxafg", "V8tC4NvwZ5o", "WZAVzyxS-Fo", "SAS2vzZFdtk", "ZhBPNl1GRkk", "NaKLJglaVIY", "GK83Uwexmgk", "nFLBxZ8Luz4", "Y6NUPAU3xNM", "xHZeA0l08Tw", "eNbcMQzF1bE", "cm90J7i2e5Y", "BA5nabt0deQ", "kfK_nrIu3MA"],
          "Creep School": ["MSYGOjnBric", "8IMhcIE6N7k"],
          "Fragglerne": ["O573raJ20e0"],
          "Sallies historier": ["8-waX4dkEio", "a7S2RF5WAMQ", "hHO3tovfuA8", "whdGHE-fBJ0", "tBGGRMIAy3Q", "k0zM1mRUgew", "3MpgqVIctVA", "cIdXwVGWCWA", "NFLwvptfwX8", "TYwmwrL0gpc", "DK5-fnh-vs0", "v5cv05XNgYw", "qOQlxiGLeYc"],
          "Pucca": ["JfusnPJd4s4"],
          "Sunes verden": ["V8uGAe1GHtE", "ETsqNVhhFYE", "MCRx4WE5MuE", "Kt34ANsdNNs", "KVRmswPP13Y", "GUTkMsZtaXs", "khbE4znEBGs", "1_FZJBvQ3gc", "XGwztjBvFGk", "hyAFfhbzxPs", "U9bCLsLCp0U", "OOE6zrpQBxc", "PNI0I2EHM6E", "Re-4uLLl0oM"],
          "Lucky Luke": ["TIMm4Axc850"],
          "Mission eftersidning": ["4MUyHC9H2a0"],
          "Conrad og Bernhard": ["vU72yrUzhyE", "oO7dBA1kH8Q", "HWymRR4HCxE", "W4ZXuCNd10k", "uTH9t1OeXoU", "yN7ROPbb-pc", "pPLPH2lhxdc", "31BfHsKrOU", "B44I_1FkiqU", "x4hNVMVo1pc", "_i_uVyDIaf0", "JTf_aZ7c6kA", "Avy6yIFs7Qc", "pk2ctkyz7iU", "v5AgqtYT2ok", "I_8Mr6s5ULc", "QBPbe6UKwWQ", "ki9UKW11iJw", "P2Yn32MuNcQ", "OJYH6gLnmDk", "2T5E08c3BEA", "fO-mus4ClxM", "D-5XrJWg-m4", "lp1rjHx_318", "jyxtu029FYg", "z7XaBEVN_LQ", "-tfClde7xOA", "6zL7MOZEURI", "zanqOCSa2kk", "dndwqZUT7vc", "zEmyvKR89xE", "dwN85pYkzdI", "ts77BTFV07I", "0-wZegiWsQ8", "a-0Ltj--gj4"]
        }
      },
      {
        name: "RetroVision Film",
        series: {
          "Casper møder Wendy": ["DJqOCRJX3F8"],
          "Morten på nye skoleeventyr": ["AXu04cQsztM"],
          "Bratz - The Movie": ["5FkFnz39OeI"],
          "Lucky Luke - Dalton Brødrene På Flugt": ["xvV7z46zjjU"],
          "Lucky Luke og Dalton Brødrene": ["y8XO--oCL6U"],
          "Lucky Luke - Lovløse i lænker": ["HdDrRITdNn0"],
          "Lucky Luke & De Lovløse": ["qBaYixkI4SY"],
          "Lucky Luke: Lange Luke": ["vz2fxBA_0QQ"],
          "Asterix & hans gæve gallere": ["CZB8A2u3TkY"],
          "Lucky Luke - Dr Doxey": ["yHq7awMsP9I"],
          "Tintin: Rackham Den Rødes Skat": ["26jHetaFtjc"],
          "Tintin: Enhjørningens Hemmelighed": ["hlNWoH7RUHk"],
          "Lucky Luke i Mississippi": ["7bL3RAu8xf0"],
          "Tintin: Månen Tur - retur": ["vro7kA2b0i4"],
          "Dr Jekyll & Mr Hyde": ["SW_BxrS81Ic"],
          "En Verdensomsejling Under Havet": ["DxfSKDZ5ADQ"],
          "Kong Salomons Miner": ["Xh_lk3unAoM"],
          "Klokkeren fra Notre Dame": ["oYCqvsQqFAE"],
          "Adventures of Robinson Crueso": ["TGyRK1-VjNc"],
          "Lucky Luke i Daisytown": ["RRuaD1MB6oE"],
          "Inspektør Gadget": ["8iB2eycMieo"],
          "Abekongen": ["2SWoxmuxpTU"],
          "Tintin: Krabben med de gyldne klør": ["oS6ijmVMlbY"],
          "M.A.S.K": ["2vQX26wRRFE"],
          "He man": ["hIzDK4nSmcc"],
          "Lucky Luke overgår sig selv": ["pSHjdb3ZIOY"],
          "Tintin: Den Sorte Ø": ["GmoujlOwQ38"],
          "Basserne": ["wp4jbQ4QGhk"],
          "Asterix: Sejren over Cæsar": ["jUSJhPpO9JY"],
          "LEGO® Brand LEGO Historien": ["KkOwoVnvqEw"],
          "Eventyret om den vidunderlige kartoffel": ["r-L71ZNHRps"],
          "Quark": ["c13xKiEYBtA"],
          "Immunforsvaret": ["fyHsHvT9H3Y"],
          "Action Man: X Missions": ["lzoF1vk-2tA"],
          "Yu-Gi-Oh! - Den Lysende Pyramide": ["OeCU88a0-vM"],
          "Familien Flintstone: I-Yabba-Dabba-Do!": ["dm:x96o9ik"],
          "Jetsons møder familien Flintstone": ["dm:x96o9ii"]
        }
      }
    ];

    const adsCartoon = [
      "l65l2u37hSo", "6QtcQO89DkQ", "bmhZK8eU3kY", "oENF1ixq2l8", "ICEAWwfzFoM",
      "jsntC_3Ln-k", "syFaSMUx2Qg", "CopdbByi2NA", "AbZkkTKM2y4", "ai--2ssHpp4",
      "F5UiuiqxGuU", "r7_bcYbek5I", "yamzBGtQkJw", "MoeTuiFGGuE", "kwJRkoHmoJs",
      "20d5qraCF9I", "4h7KoL5-1Wk", "GcAI7EDU9ys", "-3WG1dKhD6U", "C6-PdGCSZOg",
      "7tZw7FiGzW8", "TP0PtkN7ThM", "iIjkEAc3tT8", "uKgyEQKNqJ8", "dDoW-NBdP_0",
      "VurfV8M2Svc", "MvZQRsHhJIg", "twSJcxuS138", "cDfk7iflyXY", "suF6muRGh14",
      "s_azpILN_Wg", "3ND1mPAdWEc", "4YXNKS9gDyA", "0xjTGxlAGDw", "qc6ugPwtnnw",
      "bAwO4f_fnsA", "JfEwo9JNWoY", "qwVAaVUdyWk", "bXO4bLepFHw", "BhZ-IlcZXGw",
      "hcNCL3bmivE", "qjfoeUNCCJQ", "3F_LkODa_ZQ", "FrLSepuK2uw", "3zXVBPH-33c",
      "5HuWe5cpspw", "yL8haswz7QU", "R44TtSiwXPw", "Uuwc-hE8Mao", "LZFbtzElITA",
      "do4_ZnX5vvk", "c2qmzNqpE_k", "6Y4cd0cSJBw", "4xh9A4dSH_M", "wWETLa6G0ak",
      "AsncQZKdJCA", "gsBasNfXURA", "Z2m0AnYrCa8", "tRdsbpiqI60", "qnEQcdNOqRI",
      "QBdvH42-PdE"
    ];

    const adsDisney = ["gHiyQM_RuVA", "QPMr2_ld2yc", "ccG1eJDDzxI", "0AU5VuxdUxA", "6Zv1s7YfFD8", "ZCBhZCmHUnE", "H29WJfiXJS0"];
    const adsFox = ["sL5X6rmVY3I", "rRnFUNX6IWI", "LNjHpwuccXc", "FjncsmnkUyw", "VmgCTA7W6kA", "9zxQccwrn54"];
    const adsJetix = ["aKMJXqhJjaw", "a0_ykhb5m9g", "0eSdyafYgMA", "uICl3DsuLNU", "EFSfN5JX0oI", "6QNrLAL3v6o", "jvgIzUW7T0E", "sgTY_aEtfgE"];

    const adLengths = {};
    let adLengthsLoaded = false;

    let current = 0, on = false, volume = 50, muted = false, adsEnabled = true, player;
    let volTimer;
    let playbackState = {
      videoId: '',
      currentSeries: '',
      currentEpisodeIndex: 0,
      adSequence: [],
      adIndex: 0,
      isPlayingAd: false,
      firstAdAfterPowerOn: false,
      consecutiveErrorCount: 0,
      lastActivity: Date.now() // Track for iOS heartbeat
    };
    let saveInterval;
    let ytReady = false;
    let ytQueue = [];
    // Variables cleaned up
    let seriesHistory = {};
    let channelStates = {};
    let isHovering = false;
    let currentLoadId = 0; // Track concurrent loads to prevent black screens during skipping

    const staticVideo = document.getElementById("staticVideo");
    const powerOffVideo = document.getElementById("powerOffVideo");
    const label = document.getElementById("label");
    const muteIcon = document.getElementById("muteIcon");
    const volumeBar = document.getElementById("volumeBar");
    const volumeContainer = document.getElementById("volumeContainer");
    const volumeNumber = document.getElementById("volumeNumber");
    const clickSound = document.getElementById("clickSound");
    const staticSound = document.getElementById("staticSound");
    const powerOffSound = document.getElementById("powerOffSound");

    // Ensure iOS playsinline attributes are set (critical for iPad)
    if (staticVideo) {
      staticVideo.setAttribute('playsinline', 'true');
      staticVideo.setAttribute('webkit-playsinline', 'true');
      staticVideo.playsInline = true;
    }
    if (powerOffVideo) {
      powerOffVideo.setAttribute('playsinline', 'true');
      powerOffVideo.setAttribute('webkit-playsinline', 'true');
      powerOffVideo.playsInline = true;
    }

    if (window.location.protocol === 'file:') {
      console.warn("App running via file:// protocol. YouTube videos may fail with Error 153.");
      // We don't show OSD yet because the TV is off. 
      // We'll show it when power() is called.
    }

    function loadState() {
      const saved = localStorage.getItem('tvState');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          if (typeof data === 'object' && data !== null) {
            // Only load saved channel if it's not the first time ever
            // Check if there's a "hasUsedTV" flag
            if (data.hasUsedTV) {
              current = Number(data.current) || 0;
            } else {
              // First time ever, start at channel 1 (index 0)
              current = 0;
            }
            volume = Math.min(100, Math.max(0, Number(data.volume) || 50));
            muted = Boolean(data.muted);
            brightness = Number(data.brightness) || 100;
            saturation = Number(data.saturation) || 100;
            adsEnabled = data.adsEnabled !== undefined ? Boolean(data.adsEnabled) : true;

            // Update UI sliders immediately if they exist
            const bSlider = document.getElementById('brightnessSlider');
            const sSlider = document.getElementById('saturationSlider');
            const adToggle = document.getElementById('adToggle');
            if (bSlider) bSlider.value = brightness;
            if (sSlider) sSlider.value = saturation;
            if (adToggle) adToggle.checked = adsEnabled;
            updateAdLed();

            if (Array.isArray(data.seriesHistory)) {
              seriesHistory = data.seriesHistory;
            }
            if (data.channelStates && typeof data.channelStates === 'object') {
              // Only load AD BREAK state, ignore playlists/series to force fresh start
              channelStates = {};
              // We could preserve adBreak state if we want persistence of ads across reloads?
              // User said: "hver gang man kommer ind... skal det være en ny serie".
              // So we CLEAN SLATE everything related to content order.
            }
            // Ignore saved playbackState series/episode to force fresh start
          }
        } catch (e) {
          localStorage.removeItem('tvState');
        }
      } else {
        // No saved state at all - definitely first time, start at channel 1 (index 0)
        current = 0;
      }
    }

    function saveState() {
      if (!on) return;
      const state = {
        current,
        volume,
        muted,
        brightness,
        saturation,
        adsEnabled,
        hasUsedTV: true, // Mark that TV has been used at least once
        // Don't save channelStates to disk to ensure random start on reload?
        // Actually user said: "hver gang man kommer ind på den skal det være en ny serie".
        // So let's NOT save channelStates or at least not the playlists.
        // We save volume/channel index though.
      };
      // We purposefully DO NOT save channelStates or playbackState content details anymore 
      // to comply with "fresh start" request.
      localStorage.setItem('tvState', JSON.stringify(state));
    }

    function startAutoSave() {
      stopAutoSave();
      saveInterval = setInterval(saveState, 2000);
    }

    function stopAutoSave() {
      if (saveInterval) {
        clearInterval(saveInterval);
        saveInterval = null;
      }
    }

    function playClick() { clickSound.currentTime = 0; clickSound.play().catch(() => { }); }

    function showStatic(cb) {
      staticVideo.style.display = "block";
      staticVideo.currentTime = 0;
      staticVideo.play().catch(() => { });
      staticSound.currentTime = 0;
      staticSound.volume = 0.2;
      staticSound.play().catch(e => console.log('Static sound error:', e));
      setTimeout(() => {
        staticVideo.pause();
        staticVideo.style.display = "none";
        staticSound.pause();
        staticSound.currentTime = 0;
        cb();
      }, 600);
    }

    function showVolume() {
      volumeBar.style.width = volume + "%";
      volumeNumber.textContent = volume;
      volumeContainer.style.opacity = 1;
      volumeNumber.style.opacity = 1;
      muteIcon.style.opacity = (muted || volume === 0) && on ? 1 : 0;
      clearTimeout(volTimer);
      volTimer = setTimeout(() => {
        volumeContainer.style.opacity = 0;
        volumeNumber.style.opacity = 0;
      }, 1000);
    }

    function whenYTReady(fn) {
      if (ytReady) {
        fn();
      } else {
        ytQueue.push(fn);
      }
    }

    window.onYouTubeIframeAPIReady = function () {
      ytReady = true;
      ytQueue.forEach(fn => fn());
      ytQueue = [];
      renderTVGuide(); // Render guide when API is ready (or just on load)
    };

    // Inject YouTube API script asynchronously ensuring callback is defined first
    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    // Fallback render call
    window.addEventListener('load', renderTVGuide);

    /* --- GUIDE & QUEUE LOGIC --- */

    function renderTVGuide() {
      // If TV is off, clear guide
      if (!on) {
        document.getElementById('guide-content').innerHTML = '';
        return;
      }

      if (!sessionState.bannedSeries && typeof loadBans === 'function') loadBans();

      const container = document.getElementById('guide-content');
      const scrollPos = container.scrollTop;
      container.innerHTML = '';

      channels.forEach((ch, index) => {
        const block = document.createElement('div');
        block.className = 'channel-block';

        const title = document.createElement('div');
        title.className = 'channel-title';
        title.style.cursor = 'pointer';
        title.textContent = `${index + 1}. ${ch.name}`;

        // Expansion Toggle
        title.onclick = () => {
          if (index !== current) {
            const chKey = `ch${index}`;
            if (!channelStates[chKey]) channelStates[chKey] = {};
            channelStates[chKey].manualExpand = !channelStates[chKey].manualExpand;
            renderTVGuide();
          }
        };
        block.appendChild(title);

        const chKey = `ch${index}`;
        const isCurrent = (index === current);
        const isManualExpanded = channelStates[chKey] && channelStates[chKey].manualExpand;

        // COLLAPSE LOGIC
        if (!isCurrent && !isManualExpanded) {
          container.appendChild(block);
          return;
        }

        let rawList = [];
        if (channelStates[chKey] && channelStates[chKey].playlist && channelStates[chKey].playlist.length > 0) {
          rawList = channelStates[chKey].playlist;
        }

        // AD MERGING LOGIC
        let displayList = [];
        for (let i = 0; i < rawList.length; i++) {
          const item = rawList[i];
          if (item === "REKLAMEPAUSE") {
            // Filter out ads if disabled
            if (!adsEnabled) continue;

            // If this is REKLAMEPAUSE and the *previous* stored item was ALSO REKLAMEPAUSE, skip
            if (displayList.length > 0 && displayList[displayList.length - 1].name === "REKLAMEPAUSE") {
              continue; // Merge/Skip
            }
          }
          displayList.push({ name: item, originalIndex: i });
        }

        // Render Slots (Limit to 5 visual items)
        let renderedCount = 0;
        for (let i = 0; i < displayList.length; i++) {
          if (renderedCount >= 5) break;

          const item = displayList[i];
          const seriesName = item.name;
          const trueIndex = item.originalIndex;

          const slot = document.createElement('div');
          slot.className = 'program-slot';

          const badgeEl = document.createElement('div');
          badgeEl.className = 'program-badge';

          if (current === index && on) {
            // "NU" is always the first VISIBLE item
            if (renderedCount === 0) badgeEl.innerHTML = `<span style="color:#d84315">NU:</span>`;
            else if (renderedCount === 1) badgeEl.innerHTML = `NÆSTE:`;
          }
          slot.appendChild(badgeEl);

          const contentEl = document.createElement('div');
          contentEl.className = 'program-content';
          contentEl.textContent = seriesName;

          if (seriesName === "REKLAMEPAUSE") {
            contentEl.classList.add('ad-break');
            contentEl.innerHTML = `<span style="color:#555">[ REKLAMER ]</span>`;
          } else {
            // Pass trueIndex to remove the correct item from the underlying list
            contentEl.onclick = function () { removeEpisode(seriesName, trueIndex, index, this); };
          }

          slot.appendChild(contentEl);
          block.appendChild(slot);

          renderedCount++;
        }



        container.appendChild(block);
      });

      // RESTORE SCROLL
      container.scrollTop = scrollPos;
    }

    function forcePlaySeries(chIndex, seriesName) {
      // Deprecated interaction
    }

    let playerType = null; // 'youtube', 'dailymotion', or 'video'
    let dmPlayer = null; // Dailymotion player instance
    let ytPlayer = null; // YouTube player instance
    let videoElement = null; // Generic video element

    function transformOneDriveUrl(url) {
      // Basic check for OneDrive API links
      if (url.includes('api.onedrive.com')) {
        if (!url.includes('?download=1')) {
          return url + '?download=1';
        }
      }

      // Handle new 1drv.ms links - PREVENT API CONVERSION
      if (url.includes('1drv.ms')) {
        if (!url.includes('download=1')) {
          const separator = url.includes('?') ? '&' : '?';
          return url + separator + 'download=1';
        }
        return url;
      }

      // Fallback: If it's not a known format, return as is
      if (!url.includes('onedrive.live.com')) return url;

      try {
        let shareId = '';
        const sMatch = url.match(/s!([a-zA-Z0-9_-]+)/);
        if (sMatch) {
          shareId = 's!' + sMatch[1];
        } else if (url.includes('redeem=')) {
          const params = new URLSearchParams(url.split('?')[1]);
          const redeem = params.get('redeem');
          if (redeem) {
            const decoded = atob(redeem.replace(/-/g, '+').replace(/_/g, '/'));
            const dsMatch = decoded.match(/s!([a-zA-Z0-9_-]+)/);
            if (dsMatch) shareId = 's!' + dsMatch[1];
          }
        }
        if (shareId) return `https://api.onedrive.com/v1.0/shares/${shareId}/root/content?download=1`;
      } catch (e) {
        console.error("OneDrive logic error:", e);
      }
      return url;
    }

    // iOS Detection
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isInAppBrowser = (navigator.userAgent.includes('Instagram') ||
      navigator.userAgent.includes('FBAN') ||
      navigator.userAgent.includes('FBAV') ||
      navigator.userAgent.includes('Line/')) && isIOS; // Only flag in-app if also iOS
    const shouldStayMuted = isIOS || isInAppBrowser;

    // Debug log for testing
    console.log('Platform detection:', { isIOS, isInAppBrowser, shouldStayMuted, userAgent: navigator.userAgent });

    function createPlayer({ videoId, startAt = 0, loadId = currentLoadId, onReadyCb, onStateChangeCb, onEnded, onError }) {
      // Detect platform
      const isDailymotion = videoId.startsWith('dm:');
      const isOneDrive = videoId.includes('1drv.ms') || videoId.includes('onedrive.live.com/embed');
      const isIframe = videoId.startsWith('iframe:') || videoId.startsWith('embed:') || videoId.includes('/embed') || isOneDrive;
      // If it's an iframe link, it's NOT a direct video file
      const isDirectVideo = !isIframe && (videoId.startsWith('http') || videoId.startsWith('https')) && (videoId.includes('.mp4') || videoId.includes('.webm') || videoId.includes('.ogg'));

      let cleanId = videoId;
      if (isDailymotion) cleanId = videoId.substring(3);
      if (isIframe && (videoId.startsWith('iframe:') || videoId.startsWith('embed:'))) cleanId = videoId.substring(7);

      // Transform OneDrive share links to embed URLs
      if (isOneDrive && videoId.includes('1drv.ms')) {
        // OneDrive share links need to use the embed view
        // Just add embed=1 parameter and action=embedview
        const separator = videoId.includes('?') ? '&' : '?';
        cleanId = videoId + separator + 'embed=1&action=embedview';
      }

      if (isDirectVideo) {
        playerType = 'video';
      } else if (isDailymotion) {
        playerType = 'dailymotion';
      } else if (isIframe) {
        playerType = 'iframe';
      } else {
        playerType = 'youtube';
      }

      if (isDirectVideo) {
        // === GENERIC VIDEO PLAYER ===
        playerType = 'video';
        const container = document.getElementById('player');
        container.innerHTML = '';

        videoElement = document.createElement('video');
        videoElement.autoplay = true;
        videoElement.muted = true; // Required for iOS autoplay
        videoElement.playsInline = true;
        videoElement.setAttribute('playsinline', 'true'); // iOS attribute
        videoElement.setAttribute('webkit-playsinline', 'true'); // Older iOS versions
        videoElement.style.width = '100%';
        videoElement.style.height = '100%';
        videoElement.style.objectFit = 'cover';

        container.appendChild(videoElement);
        player = createPlayerWrapper();

        videoElement.onloadedmetadata = () => {
          if (startAt > 0) videoElement.currentTime = startAt;
          if (onReadyCb) onReadyCb({ target: player });
        };

        videoElement.onplay = () => {
          // Attempt to unmute on ALL platforms (iOS included)
          // Longer delay for iOS compatibility
          if (!muted && volume > 0) {
            setTimeout(() => {
              videoElement.muted = false;
              videoElement.volume = volume / 100;
              console.log('Unmuted video element');
            }, shouldStayMuted ? 3000 : 500); // Increased delay for iOS
          }
          if (onStateChangeCb) onStateChangeCb({ data: 1 }); // 1 = PLAYING
        };

        // Only retry on pause for non-iOS to avoid buffering loops
        videoElement.onpause = () => {
          if (!videoElement.ended && !shouldStayMuted) {
            setTimeout(() => {
              videoElement.play().catch(() => { });
            }, 100);
          }
          if (onStateChangeCb) onStateChangeCb({ data: 2 }); // 2 = PAUSED
        };



        videoElement.onended = () => {
          if (onStateChangeCb) onStateChangeCb({ data: 0 }); // 0 = ENDED
        };

        videoElement.onerror = (e) => {
          if (onError) onError(e);
          else {
            console.error("Generic Video Error, skipping:", cleanId);
            updateOSD("VIDEO FEJL - SPRINGER OVER", true); // Visual feedback
            addToPlayedHistory(cleanId);

            setTimeout(() => {
              // Only skip if this load is still active
              if (loadId === currentLoadId) {
                if (channelStates[`ch${current}`]) channelStates[`ch${current}`].currentVideo = null;
                loadChannel(false, false, true, true);
              }
            }, 100); // Super fast skip
          }
        };

        // Set src AFTER listeners are attached to catch immediate errors
        videoElement.src = transformOneDriveUrl(videoId);

      } else if (isDailymotion) {
        // === DAILYMOTION PLAYER ===
        if (!window.dailymotion) {
          console.error('Dailymotion SDK not loaded');
          return;
        }

        playerType = 'dailymotion';

        if (dmPlayer) {
          // IMPORTANT: Capture loadId in the callback
          const currentLoad = loadId;
          // Load new video
          dmPlayer.load({ video: cleanId, params: { 'start-time': startAt }, autoplay: true });
          // Ensure we re-poll for new duration
          dmCachedDuration = 0;
          // Explicitly update player reference
          player = createPlayerWrapper();
          if (onReadyCb) {
            // Simulate ready callback
            setTimeout(() => {
              if (currentLoad === currentLoadId) onReadyCb({ target: player });
            }, 100);
          }
        } else {
          // Capture loadId for the Promise callback
          const currentLoad = loadId;
          // Create new Dailymotion player (returns a Promise!)
          window.dailymotion.createPlayer('player', {
            video: cleanId,
            params: {
              playsinline: 1,
              autoplay: 1,
              controls: 0,
              'start-time': startAt,
              mute: 1,
              'ui-theme': 'dark',
              'aspect-ratio': 'none'
            }
          }).then((dmInstance) => {
            if (currentLoad !== currentLoadId) return;
            dmPlayer = dmInstance;

            // Explicitly call play for iOS
            if (isIOS) {
              dmPlayer.play().catch(e => console.log("DM Initial play catch:", e));
            }

            // Forcibly fix Dailymotion wrapper heights using MutationObserver
            const playerDiv = document.getElementById('player');
            const fixDailyMotionStyles = () => {
              if (playerDiv.style.paddingBottom) {
                playerDiv.style.setProperty('padding-bottom', '0', 'important');
              }
              playerDiv.querySelectorAll('div, iframe').forEach(el => {
                if (el.style.height && el.style.height !== '100%') {
                  el.style.setProperty('height', '100%', 'important');
                  el.style.setProperty('max-height', '100%', 'important');
                  el.style.setProperty('min-height', 'auto', 'important');
                }
              });
            };

            fixDailyMotionStyles();
            const observer = new MutationObserver(fixDailyMotionStyles);
            observer.observe(playerDiv, { childList: true, subtree: true, attributes: true, attributeFilter: ['style'] });

            // Setup event listeners
            dmPlayer.on('videochange', () => {
              if (currentLoad === currentLoadId && onReadyCb) onReadyCb({ target: createPlayerWrapper() });
            });

            dmPlayer.on('playing', () => {
              if (currentLoad !== currentLoadId) return;
              dmInternalState = 1; // PLAYING

              // Attempt to unmute on ALL platforms (iOS included)
              if (!muted && volume > 0) {
                setTimeout(() => {
                  dmPlayer.setMuted(false);
                  dmPlayer.setVolume(volume / 100);
                  console.log('Unmuted Dailymotion player');

                  // Secondary attempt for iOS to ensure it sticks
                  if (isIOS) {
                    setTimeout(() => {
                      if (dmPlayer && !muted) {
                        dmPlayer.setMuted(false);
                        dmPlayer.setVolume(volume / 100);
                      }
                    }, 2000);
                  }
                }, shouldStayMuted ? 3000 : 500);
              }
            });

            dmPlayer.on('paused', () => {
              if (currentLoad !== currentLoadId) return;
              dmInternalState = 2; // PAUSED
              if (!shouldStayMuted) {
                dmPlayer.ended.then(isEnded => {
                  if (!isEnded) {
                    setTimeout(() => {
                      if (currentLoad === currentLoadId && dmPlayer) {
                        dmPlayer.play().catch(() => { });
                      }
                    }, 150);
                  }
                }).catch(() => { });
              }
              if (onStateChangeCb) onStateChangeCb({ data: 2 });
            });

            dmPlayer.on('video_end', () => {
              if (currentLoad !== currentLoadId) return;
              dmInternalState = 0; // ENDED
              if (onStateChangeCb) onStateChangeCb({ data: 0 });
            });

            // FORCE SEEK if we are resuming (live simulation)
            if (startAt > 0) {
              dmPlayer.currentTime.then(t => {
                if (Math.abs(t - startAt) > 3) {
                  console.log(`DM Forcing seek to ${startAt} (current: ${t})`);
                  dmPlayer.seek(startAt);
                }
              });
            }

            if (onStateChangeCb) {
              onStateChangeCb({ data: 1 }); // 1 = PLAYING (same as YT)
            }

            // Initial ready callback
            if (onReadyCb) {
              setTimeout(() => {
                if (currentLoad === currentLoadId) onReadyCb({ target: createPlayerWrapper() });
              }, 100);
            }

            // IMPORTANT: Create wrapper AFTER player exists
            player = createPlayerWrapper();
          }).catch((error) => {
            console.error('Dailymotion player creation failed:', error);
          });
        }

      } else if (playerType === 'iframe') {
        // === IFRAME PLAYER ===
        console.log("Initializing Iframe Player for:", cleanId);

        let finalSrc = cleanId;
        // Inject startAt if provided (for random start)
        if (startAt > 0) {
          if (finalSrc.includes('start=')) {
            finalSrc = finalSrc.replace(/start=\d+/, 'start=' + Math.floor(startAt));
          } else {
            const sep = finalSrc.includes('?') ? '&' : '?';
            finalSrc += sep + 'start=' + Math.floor(startAt);
          }
        }

        // Handle Archive.org mute parameter
        // iOS MUST be muted to prevent infinite buffering
        // ALWAYS mute archive.org on iOS, regardless of user settings
        if (finalSrc.includes('archive.org')) {
          if (isIOS) {
            // Force muted on iOS to prevent buffering issues
            if (!finalSrc.includes('muted=1')) {
              const sep = finalSrc.includes('?') ? '&' : '?';
              finalSrc += sep + 'muted=1';
            }
          } else if (muted || volume === 0) {
            // Only mute on desktop if user wants it muted
            if (!finalSrc.includes('muted=1')) {
              const sep = finalSrc.includes('?') ? '&' : '?';
              finalSrc += sep + 'muted=1';
            }
          }
        }

        // Add cache-busting timestamp for archive.org to force autoplay on reload
        // Browsers block autoplay on iframe reload - timestamp makes it a "new" request
        if (finalSrc.includes('archive.org')) {
          const sep = finalSrc.includes('?') ? '&' : '?';
          finalSrc += sep + 't=' + Date.now();
        }

        // Create iframe element
        const container = document.getElementById('player');
        container.innerHTML = '';

        const iframe = document.createElement('iframe');
        iframe.src = finalSrc;
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.allow = 'autoplay; encrypted-media; gyroscope; picture-in-picture; fullscreen';
        iframe.allowFullscreen = true;
        // iOS-specific attributes for autoplay
        iframe.setAttribute('playsinline', 'true');
        iframe.setAttribute('webkit-playsinline', 'true');

        container.appendChild(iframe);

        // Mock player interface for iframes
        player = {
          playVideo: () => { },
          pauseVideo: () => { },
          stopVideo: () => { },
          setVolume: (v) => { },
          mute: () => { },
          unMute: () => { },
          getDuration: () => 0,
          seekTo: (s) => { },
          getCurrentTime: () => Promise.resolve(0)
        };

        // Trigger onReady immediately since iframes don't have an API to tell us
        if (onReadyCb) {
          setTimeout(() => {
            onReadyCb({ target: player });
          }, 500);
        }

        // Create wrapper immediately which handles DOM creation
        player = createPlayerWrapper();

        // Fire ready logic if needed
        if (onReadyCb) {
          setTimeout(() => {
            if (loadId === currentLoadId) onReadyCb({ target: player });
          }, 100);
        }


      } else {
        // === YOUTUBE PLAYER ===
        if (!window.YT || !window.YT.Player) {
          console.error('YT.Player not available');
          return;
        }

        playerType = 'youtube';

        if (ytPlayer) {
          const currentLoad = loadId;
          // CRITICAL: Update callback references on the player object
          ytPlayer.currentContext = {
            loadId: loadId,
            onReadyCb: onReadyCb,
            onStateChangeCb: onStateChangeCb,
            onError: onError,
            onEnded: onEnded
          };

          // Reuse existing YouTube player
          ytPlayer.loadVideoById({ videoId: cleanId, startSeconds: Math.floor(startAt) });
          if (onReadyCb) {
            if (currentLoad === currentLoadId) onReadyCb({ target: player });
          }
        } else {
          // Create new YouTube player
          ytPlayer = new window.YT.Player("player", {
            host: 'https://www.youtube.com',
            videoId: cleanId,
            playerVars: {
              playsinline: 1,
              autoplay: 1,
              controls: 0,
              rel: 0,
              start: Math.floor(startAt),
              enablejsapi: 1,
              mute: 1,
              modestbranding: 1,
              iv_load_policy: 3,
              fs: 0,
              disablekb: 1,
              cc_load_policy: 0
            },
            events: {
              onReady: (e) => {
                // Force highest quality
                if (e.target.setPlaybackQuality) e.target.setPlaybackQuality("hd1080");

                const ctx = (ytPlayer && ytPlayer.currentContext) || { loadId, onReadyCb };
                if (ctx.loadId !== currentLoadId) return;

                playbackState.consecutiveErrorCount = 0;
                player = createPlayerWrapper();
                if (ctx.onReadyCb) ctx.onReadyCb({ target: player });
              },
              onStateChange: (e) => {
                const ctx = (ytPlayer && ytPlayer.currentContext) || { loadId, onStateChangeCb };
                if (ctx.loadId === currentLoadId) {
                  if (window.YT && e.data === window.YT.PlayerState.PLAYING) {
                    playbackState.consecutiveErrorCount = 0;
                    // Attempt to unmute on ALL platforms (iOS included)
                    // Longer delay for iOS compatibility
                    if (!muted && volume > 0) {
                      setTimeout(() => {
                        if (ytPlayer) {
                          ytPlayer.unMute();
                          ytPlayer.setVolume(volume);
                          console.log('Unmuted YouTube player');
                        }
                      }, shouldStayMuted ? 3000 : 500); // Increased delay for iOS
                    }
                  }

                  // Only retry on pause for non-iOS to avoid buffering loops
                  if (!shouldStayMuted && window.YT && e.data === window.YT.PlayerState.PAUSED) {
                    if (ytPlayer && ytPlayer.getPlayerState) {
                      const state = ytPlayer.getPlayerState();
                      const duration = ytPlayer.getDuration();
                      const currentTime = ytPlayer.getCurrentTime();

                      if (state === window.YT.PlayerState.PAUSED && duration > 0 && currentTime < duration - 1) {
                        setTimeout(() => {
                          if (ctx.loadId === currentLoadId && ytPlayer && ytPlayer.playVideo) {
                            ytPlayer.playVideo();
                          }
                        }, 150);
                      }
                    }
                  }

                  if (ctx.onStateChangeCb) ctx.onStateChangeCb(e);
                }
              },
              onError: (e) => {
                const ctx = (ytPlayer && ytPlayer.currentContext) || { loadId, onError };
                if (ctx.loadId !== currentLoadId) return;
                console.error("YouTube Player Error:", e.data, " Video:", cleanId);

                playbackState.consecutiveErrorCount++;
                updateOSD(`FEJL ${e.data || ''} (${playbackState.consecutiveErrorCount})`, true);
                addToPlayedHistory(cleanId);

                if (playbackState.consecutiveErrorCount >= 5) {
                  if (window.location.protocol === 'file:') {
                    updateOSD("Brug en lokal server (localhost)", true);
                  } else {
                    updateOSD("FOR MANGE FEJL - STOPPER", true);
                  }
                  showStatic(() => { });
                  return;
                }

                if (ctx.onError) {
                  ctx.onError(e);
                } else {
                  setTimeout(() => {
                    if (ctx.loadId === currentLoadId) {
                      if (channelStates[`ch${current}`]) channelStates[`ch${current}`].currentVideo = null;
                      loadChannel(false, false, true, true);
                    }
                  }, 800);
                }
              }
            }
          });

          // Initialize currentContext for first load
          ytPlayer.currentContext = {
            loadId: loadId,
            onReadyCb: onReadyCb,
            onStateChangeCb: onStateChangeCb,
            onError: onError,
            onEnded: onEnded
          };
        }

        // Update wrapper reference
        player = createPlayerWrapper();
      }
    }

    // Unified player wrapper (normalizes both APIs)
    let dmCachedTime = 0;
    let dmCachedDuration = 0;
    let dmUpdateInterval = null;
    let dmInternalState = -1; // -1: unstarted, 0: ended, 1: playing, 2: paused, 3: buffering

    function createPlayerWrapper() {
      if (playerType === 'video') {
        return {
          _isVideo: true,
          getCurrentTime: () => videoElement.currentTime,
          getDuration: () => videoElement.duration,
          seekTo: (seconds) => { videoElement.currentTime = seconds; },
          setVolume: (vol) => { videoElement.volume = vol / 100; },
          mute: () => { videoElement.muted = true; },
          unMute: () => { videoElement.muted = false; },
          playVideo: () => { videoElement.play(); },
          pauseVideo: () => { videoElement.pause(); },
          loadVideoById: (opts) => {
            videoElement.src = opts.videoId;
            videoElement.currentTime = opts.startSeconds || 0;
            videoElement.play();
          },
          getPlayerState: () => {
            if (videoElement.paused) return 2; // PAUSED
            if (videoElement.ended) return 0; // ENDED
            return 1; // PLAYING
          },
          destroy: () => {
            if (videoElement) {
              videoElement.pause();
              videoElement.src = "";
              videoElement.load();
              const container = document.getElementById('player');
              if (container) container.innerHTML = '';
            }
          }
        };
      } else if (playerType === 'iframe') {
        // Wrapper for specialized Iframe players (like generic/Hamtaro)
        return {
          _isIframe: true,
          getCurrentTime: () => 0,
          getDuration: () => 0,
          seekTo: (s) => { },
          setVolume: (v) => { },
          mute: () => { },
          unMute: () => { },
          playVideo: () => { },
          pauseVideo: () => {
            // Best effort to stop playback: clear invalid sources or remove
            const container = document.getElementById('player');
            if (container) container.innerHTML = '';
          },
          destroy: () => {
            const container = document.getElementById('player');
            if (container) container.innerHTML = '';
          }
        };
      } else if (playerType === 'dailymotion') {
        // Start polling for time/duration updates
        if (dmUpdateInterval) clearInterval(dmUpdateInterval);
        dmUpdateInterval = setInterval(() => {
          if (dmPlayer) {
            dmPlayer.currentTime.then(t => { dmCachedTime = t; });
            dmPlayer.duration.then(d => { dmCachedDuration = d; });
          }
        }, 200); // Update every 200ms

        return {
          _isDailymotion: true,
          getCurrentTime: () => {
            return dmCachedTime; // Return cached value synchronously
          },
          getDuration: () => {
            return dmCachedDuration; // Return cached value synchronously
          },
          seekTo: (seconds, allowSeekAhead) => {
            dmPlayer.seek(seconds);
            dmCachedTime = seconds; // Update cache immediately
          },
          setVolume: (vol) => {
            dmPlayer.setVolume(vol / 100); // DM uses 0-1, YT uses 0-100
          },
          mute: () => {
            dmPlayer.setMuted(true);
          },
          unMute: () => {
            dmPlayer.setMuted(false);
          },
          playVideo: () => {
            dmPlayer.play();
          },
          pauseVideo: () => {
            dmPlayer.pause();
          },
          loadVideoById: (opts) => {
            const vid = opts.videoId.startsWith('dm:') ? opts.videoId.substring(3) : opts.videoId;
            dmPlayer.load({ video: vid, startTime: opts.startSeconds || 0, autoplay: true });
          },
          getPlayerState: () => {
            return dmInternalState;
          },
          destroy: () => {
            if (dmUpdateInterval) clearInterval(dmUpdateInterval);
            dmUpdateInterval = null;
            if (dmPlayer) {
              dmPlayer.pause();
              // No explicit destroy in DM SDK v2 easily accessible like YT, 
              // but we can clear the iframe to be sure
              const container = document.getElementById('player');
              if (container) container.innerHTML = '';
            }
          }
        };

      } else if (playerType === 'iframe') {
        return {
          _isIframe: true,
          playVideo: () => {
            // Reload iframe to restart?
            const container = document.getElementById('player');
            const iframe = container.querySelector('iframe');
            if (iframe) iframe.src = iframe.src;
          },
          pauseVideo: () => { },
          mute: () => { },
          unMute: () => { },
          setVolume: (v) => { },
          seekTo: (s) => { },
          getDuration: () => 0,
          getCurrentTime: () => 0,
          destroy: () => {
            const container = document.getElementById('player');
            if (container) container.innerHTML = '';
          }
        };
      } else {
        // Clear DM interval if switching to YouTube
        if (dmUpdateInterval) {
          clearInterval(dmUpdateInterval);
          dmUpdateInterval = null;
        }
        // Return YouTube player instance directly
        return ytPlayer;
      }
    }

    function isLongAd(adId) {
      const saved = localStorage.getItem('adLengths');
      if (saved) {
        try {
          const lengths = JSON.parse(saved);
          if (lengths[adId]) {
            return lengths[adId] > 30;
          }
        } catch (e) { }
      }
      return Math.random() > 0.5;
    }

    function saveAdLength(adId, duration) {
      const saved = localStorage.getItem('adLengths');
      let lengths = {};
      if (saved) {
        try {
          lengths = JSON.parse(saved);
        } catch (e) { }
      }
      lengths[adId] = duration;
      localStorage.setItem('adLengths', JSON.stringify(lengths));
    }

    function createAdSequence() {
      // Rules: Min 2 ads, Max 4 ads.
      const patterns = [
        { long: 1, short: 1 }, // 2 ads
        { long: 0, short: 2 }, // 2 ads
        { long: 2, short: 0 }, // 2 ads
        { long: 1, short: 2 }, // 3 ads
        { long: 0, short: 3 }, // 3 ads
        { long: 2, short: 1 }, // 3 ads
        { long: 1, short: 3 }, // 4 ads
        { long: 0, short: 4 }, // 4 ads
        { long: 2, short: 2 }  // 4 ads
      ];

      const pattern = patterns[Math.floor(Math.random() * patterns.length)];
      const longAds = [];
      const shortAds = [];

      let adSource = adsCartoon;
      const chName = channels[current].name;

      if (chName === "Disney Channel") adSource = adsDisney;
      else if (chName === "Fox Kids") adSource = adsFox;
      else if (chName === "Jetix") adSource = adsJetix;

      // Unique Filter: Deduplicate the source array just in case
      adSource = [...new Set(adSource)];

      // HISTORY FILTER: Prevent recently played ads
      const adHistory = getAdHistory(chName);
      let availableAds = adSource.filter(id => !adHistory.includes(id));

      // If we filtered out too many and can't fill a decent block, reset/relax
      // We need at least enough to pick ANY pattern (min 2)
      if (availableAds.length < 2) {
        // Soft reset: Allow reusing oldest from history, or just use all source
        availableAds = adSource;
      }

      // Distribute available into Long/Short
      for (const adId of availableAds) {
        if (isLongAd(adId)) {
          longAds.push(adId);
        } else {
          shortAds.push(adId);
        }
      }

      longAds.sort(() => Math.random() - 0.5);
      shortAds.sort(() => Math.random() - 0.5);

      const seq = [];
      const totalRequested = pattern.long + pattern.short;

      // If ad source is very small, just pick what we can
      if (availableAds.length < totalRequested) {
        let pool = [...availableAds].sort(() => Math.random() - 0.5);
        // Record these chosen ads in history
        if (pool.length > 0) addToAdHistory(chName, pool);
        // Take up to 4 if available
        return pool.slice(0, 4);
      }

      for (let i = 0; i < pattern.long; i++) {
        if (longAds.length > 0) seq.push(longAds.pop());
      }
      for (let i = 0; i < pattern.short; i++) {
        if (shortAds.length > 0) seq.push(shortAds.pop());
      }

      // Record selection in history
      addToAdHistory(chName, seq);

      return seq.sort(() => Math.random() - 0.5);
    }

    function playAdsThen(cb, isTuningIn = false, resumeSeq = null, resumeStartAt = 0) {
      const loadId = currentLoadId; // Respect the load context we're in
      if (!adsEnabled || !["Cartoon Network", "Disney Channel", "Fox Kids", "Jetix", "Blandet Kanal"].includes(channels[current].name)) {
        cb(); return;
      }

      const seq = resumeSeq || createAdSequence();

      // Save Ad Break State
      if (!channelStates[`ch${current}`]) channelStates[`ch${current}`] = {};
      // If we are resuming, we keep original start time, else new
      if (!resumeSeq) {
        channelStates[`ch${current}`].adBreak = {
          startTime: Date.now(),
          sequence: seq
        };
      }

      playbackState.adSequence = seq;
      playbackState.isPlayingAd = true;

      let i = 0;
      function next() {
        if (i >= seq.length) {
          playbackState.isPlayingAd = false;
          // Clear ad break state when done
          if (channelStates[`ch${current}`]) delete channelStates[`ch${current}`].adBreak;
          cb();
          return;
        }
        const adId = seq[i];
        playbackState.adIndex = i;
        // TuningIn check only applies if it's the very first time we trigger ads, 
        // OR if we are resuming the first ad in the resumeSeq? 
        // actually if resumeStartAt > 0 we use that.

        const isFirstAdOfSeq = (i === 0);
        i++;


        let startAt = 0;
        if (isFirstAdOfSeq && resumeStartAt > 0) {
          startAt = resumeStartAt;
        }

        playbackState.videoId = adId;
        whenYTReady(() => {
          createPlayer({
            videoId: adId,
            startAt: startAt,
            onReadyCb: e => {
              // Strict middle start: Seek to duration / 2 if tuning in
              // BUT if we have a specific startAt (from resume), respect that first!
              if (isFirstAdOfSeq && isTuningIn && startAt === 0) {
                const dur = e.target.getDuration();
                if (dur && dur > 0) {
                  e.target.seekTo(dur / 2, true);
                }
              }

              e.target.setVolume(volume);
              if (muted || volume === 0) e.target.mute();
              startAutoSave();
              try {
                const duration = e.target.getDuration();
                if (duration) saveAdLength(adId, duration);
              } catch (err) { }
            },
            onStateChangeCb: e => {
              if (window.YT && e.data === window.YT.PlayerState.ENDED) next();
            },
            onError: (e) => {
              console.log("Ad failed (Error 153/Other), skipping to next ad:", adId);
              playbackState.consecutiveErrorCount++;
              if (playbackState.consecutiveErrorCount >= 5) {
                console.error("Too many consecutive errors during ads. Stopping.");
                updateOSD("FOR MANGE FEJL - STOPPER", true);
                showStatic(() => { });
                return;
              }
              next();
            }
          });
        });
      }
      next();
    }




    /* --- NEW QUEUE & PLAYBACK ENGINE --- */

    let sessionState = {
      bannedSeries: []
      // We'll store played videos in localStorage "playedHistory" instead of here
    };

    function getPlayedHistory() {
      try {
        return JSON.parse(localStorage.getItem('playedHistory')) || [];
      } catch (e) { return []; }
    }

    function addToPlayedHistory(vidId) {
      let h = getPlayedHistory();
      // LRU logic: if it's already in history, remove it from its current position
      // so we can push it to the very end (most recently seen).
      h = h.filter(id => id !== vidId);
      h.push(vidId);

      // Optional: Cap history size to prevent localStorage bloat, e.g., keep last 1000 items
      if (h.length > 1000) h = h.slice(-1000);

      localStorage.setItem('playedHistory', JSON.stringify(h));
    }

    // --- AD HISTORY ---
    function getAdHistory(chName) {
      try {
        const store = JSON.parse(localStorage.getItem('adHistory')) || {};
        return store[chName] || [];
      } catch (e) { return []; }
    }

    function addToAdHistory(chName, adIds) {
      try {
        let store = JSON.parse(localStorage.getItem('adHistory')) || {};
        let list = store[chName] || [];

        // Add new ads
        for (const id of adIds) {
          // Remove if existing (to move to end)
          list = list.filter(x => x !== id);
          list.push(id);
        }

        // Keep last 10 ads per channel
        if (list.length > 10) list = list.slice(-10);

        store[chName] = list;
        localStorage.setItem('adHistory', JSON.stringify(store));
      } catch (e) { }
    }

    function loadBans() {
      const saved = localStorage.getItem('tvBans');
      if (saved) {
        try { sessionState.bannedSeries = JSON.parse(saved); } catch (e) { }
      }
    }

    function removeEpisode(seriesName, queueIndex, channelIndex, element) {
      if (!on) return;

      // 1. Fade out the EPISODE
      if (element) {
        element.classList.add('banning-anim');
      }

      // 2. Wait for Fade (500ms)
      setTimeout(() => {
        // 3. COLLAPSE THE SLOT (Visual Slide Up)
        let isMerge = false;
        let nextAdContent = null;

        if (element && element.parentElement) {
          element.parentElement.style.display = 'none'; // This causes the list to slide up

          // 4. CHECK FOR MERGE (Now that it's hidden)
          const chKey = `ch${channelIndex}`;
          if (channelStates[chKey] && channelStates[chKey].playlist) {
            const list = channelStates[chKey].playlist;
            if (queueIndex > 0 && queueIndex < list.length - 1) {
              if (list[queueIndex - 1] === "REKLAMEPAUSE" && list[queueIndex + 1] === "REKLAMEPAUSE") {
                isMerge = true;
                // Find the visual element for the underlying bottom ad
                // Since we just hid the current slot, the next visible sibling might be it?
                // Actually, we can rely on DOM structure: parentSlot -> nextElementSibling
                const parentSlot = element.parentElement;
                if (parentSlot) {
                  const nextSlot = parentSlot.nextElementSibling;
                  if (nextSlot) {
                    const nextContent = nextSlot.querySelector('.program-content');
                    if (nextContent && nextContent.textContent.includes("REKLAMER")) {
                      nextAdContent = nextContent;
                    }
                  }
                }
              }
            }
          }
        }

        // 5. IF MERGE: Fade out the bottom ad
        if (isMerge && nextAdContent) {
          // Short delay to let the slide-up settle, then fade
          requestAnimationFrame(() => {
            nextAdContent.classList.add('banning-anim');
          });

          // Wait for 2nd animation (500ms)
          setTimeout(() => {
            performRemoval();
          }, 500);

        } else {
          // No merge, just proceed
          performRemoval();
        }

        function performRemoval() {
          const chKey = `ch${channelIndex}`;
          if (channelStates[chKey] && channelStates[chKey].playlist) {
            const playlist = channelStates[chKey].playlist;
            // Remove matching item at index
            if (playlist[queueIndex] === seriesName) {
              // COOLDOWN LOGIC: Mark this series as "played" so it doesn't pop back into the guide immediately
              const ch = channels[channelIndex];
              const sVids = ch.series ? ch.series[seriesName] : ch.videos;
              if (sVids && sVids.length > 0) {
                // Just pick one and add to history - this triggers the 30-video global cooldown
                addToPlayedHistory(sVids[0]);
              }

              playlist.splice(queueIndex, 1);

              // Refill
              ensureQueue(channelIndex);

              // If we removed the currently playing video, force a fresh load
              if (queueIndex === 0 && channelIndex === current) {
                // CRITICAL: Clear the old video state first
                channelStates[chKey].currentVideo = null;

                // STOP the current player to ensure clean transition
                try {
                  if (player && player.destroy) player.destroy();
                  else if (ytPlayer && ytPlayer.destroy) ytPlayer.destroy();
                } catch (e) {
                  console.log('Error stopping player:', e);
                }

                player = null;
                ytPlayer = null;
                dmPlayer = null;
                playerType = null;
                if (dmUpdateInterval) {
                  clearInterval(dmUpdateInterval);
                  dmUpdateInterval = null;
                }

                // FORCE RECREATE PLAYER DIV
                // The YT API and others might leave the DOM in a weird state (iframe vs div).
                // Nuke it and rebuild to guarantee clean slate for next load.
                const screen = document.querySelector('.screen');
                let playerDiv = document.getElementById('player');
                const label = document.getElementById('label');

                if (playerDiv) playerDiv.remove();

                playerDiv = document.createElement('div');
                playerDiv.id = 'player';

                if (label && screen) {
                  screen.insertBefore(playerDiv, label);
                } else if (screen) {
                  screen.appendChild(playerDiv);
                }

                currentLoadId++; // Invalidate any ongoing loads from the skipped video
                // Now load the next video fresh (which is now at position 0)
                loadChannel(false, false, false, true, true); // forceStart = true
              }
            }

            // Removal Streak Penalty Logic (ONLY if skipping the CURRENT video)
            if (queueIndex === 0) {
              if (!channelStates[chKey].removalStreak) channelStates[chKey].removalStreak = 0;
              channelStates[chKey].removalStreak++;

              if (channelStates[chKey].removalStreak >= 3) {
                // Reset streak
                channelStates[chKey].removalStreak = 0;

                // If this is the active channel, FORCE ADS
                if (channelIndex === current) {
                  console.log("3 Removals in a row - Forcing Ads!");
                  playlist.unshift("REKLAMEPAUSE");
                  renderTVGuide(); // Force render for the new ad

                  playAdsThen(() => {
                    rotateQueue(current);
                    loadChannel(false, false, true, true);
                  });
                  return; // Stop here, renderTVGuide already called
                }
              }
            }
          }
          renderTVGuide();
        }

      }, 500);
    }


    // Deprecated but keeping signature to avoid errors if called
    function toggleBan(seriesName) { }

    // OSD / Label Logic
    function updateOSD(text, sticky = false) {
      if (!on) return;

      label.textContent = text;
      label.style.opacity = 1;
      label.sticky = sticky;
      if (label.timer) clearTimeout(label.timer);

      if (!sticky) {
        label.timer = setTimeout(() => {
          label.style.opacity = 0;
          label.sticky = false;
        }, 4000);
      } else {
        // Sticky items still fade after a while to allow hover to work again
        label.timer = setTimeout(() => {
          label.style.opacity = 0;
          label.sticky = false;
        }, 4000);
      }
    }

    function ensureQueue(channelIndex) {
      const chKey = `ch${channelIndex}`;
      const ch = channels[channelIndex];

      if (!channelStates[chKey]) channelStates[chKey] = {};
      if (!channelStates[chKey].playlist) channelStates[chKey].playlist = [];

      const queue = channelStates[chKey].playlist;
      const allSeries = ch.series ? Object.keys(ch.series) : [];

      // If channel has NO content (e.g. Fox Kids/Jetix), fill with ADS
      if (allSeries.length === 0) {
        while (queue.length < 15) {
          queue.push("REKLAMEPAUSE");
        }
        return;
      }

      // Fill queue up to 15 items 
      let safetyCounter = 0; // Prevent infinite loops
      const history = getPlayedHistory(); // Get global history
      // Increased history buffer to ensure rotation of all series before repeating episodes
      const recentHistory = history.slice(-60);

      while (queue.length < 15 && safetyCounter < 50) {
        safetyCounter++;

        // 1. Filter out Banned Series
        let available = allSeries.filter(s => !sessionState.bannedSeries.includes(s));
        if (available.length === 0) available = allSeries; // Fallback if all strictly banned

        // 2. COOL-DOWN & INVENTORY FILTER
        // We want to skip series where all episodes are either in history (last 60) 
        // OR already waiting in the queue.
        const notOnCooldown = available.filter(seriesName => {
          const sVids = ch.series[seriesName];
          if (!sVids || sVids.length === 0) return false;

          // Count how many times this series is already in the queue
          const inQueueCount = queue.filter(s => s === seriesName).length;

          // Count how many episodes are NOT in the recent history
          const availableEpisodes = sVids.filter(vidId => !recentHistory.includes(vidId));

          // FIX: Small Series Exemption
          // If a series has very few videos (e.g. Hamtaro has 6), the "available > inQueue" logic blocks it forever 
          // if all videos are in history.
          // Rule: If series has <= 10 videos, allow repeating IF it's not already saturating the queue.
          if (sVids.length <= 10) {
            return inQueueCount < Math.max(2, sVids.length); // Allow up to 2 or series length (whichever is greater) in queue
          }

          // A series is ONLY available if it has more available episodes than its current count in the queue
          return availableEpisodes.length > inQueueCount;
        });

        // If we have series that satisfy the 30 rule, restrict to those.
        // Otherwise (user watched EVERYTHING recently?), fallback to allowing repeats.
        if (notOnCooldown.length > 0) {
          available = notOnCooldown;
        }

        // Rule: Max 2 repeats in a row in the queue logic
        // Check last 2 items
        const last1 = queue.length > 0 ? queue[queue.length - 1] : null;
        const last2 = queue.length > 1 ? queue[queue.length - 2] : null;

        let pick = null;

        // Bias: If we played Series X, and previous wasn't Series X (so count is 1), 
        // try to play Series X again with 40% probability (clustering)
        if (last1 && last1 !== "REKLAMEPAUSE" && last1 !== last2 && available.includes(last1)) {
          if (Math.random() < 0.40) {
            pick = last1;
          }
        }

        if (!pick) {
          // Pick random from the filtered list
          pick = available[Math.floor(Math.random() * available.length)];
        }

        if (last1 === pick && last2 === pick && available.length > 1) {
          continue; // Try again
        }
        queue.push(pick);

        // Chance to insert AD BREAK after an episode (but not if last was ad)
        // 25% chance -> Approx every 4 episodes
        // STRICT RULE: Never have more than 2 REKLAMEPAUSE in a row
        // AND: Only on ad-supported channels
        const adChannels = ["Cartoon Network", "Disney Channel", "Fox Kids", "Jetix"];
        if (Math.random() < 0.25 && pick !== "REKLAMEPAUSE" && adChannels.includes(ch.name)) {
          // Count consecutive REKLAMEPAUSE at end of queue
          let consecutiveAds = 0;
          for (let j = queue.length - 1; j >= 0; j--) {
            if (queue[j] === "REKLAMEPAUSE") {
              consecutiveAds++;
            } else {
              break;
            }
          }

          // Only add if we don't already have 2 in a row
          if (consecutiveAds < 2) {
            queue.push("REKLAMEPAUSE");
          }
        }
      }
    }

    function rotateQueue(channelIndex) {
      const chKey = `ch${channelIndex}`;
      if (!channelStates[chKey] || !channelStates[chKey].playlist) return;

      // Shifts the top item out (it has finished playing)
      const old = channelStates[chKey].playlist.shift();

      // Automatically move it to bottom? 
      // Logic says "random shuffle" but user said "when a series has been shown it should disappear from top and go to bottom".
      // Our ensureQueue does random picking. To strictly follow "go to bottom", we might want a round-robin?
      // But "random order" is also requested.
      // `ensureQueue` random refill effectively puts it back in the pool.

      // Refill to keep buffer full
      ensureQueue(channelIndex);
    }

    function playNextInQueue(channelIndex) {
      const chKey = `ch${channelIndex}`;
      ensureQueue(channelIndex);

      const queue = channelStates[chKey].playlist;
      const seriesName = queue[0];

      // Special Case: Continuous Ads
      if (seriesName === "REKLAMEPAUSE") {
        renderTVGuide();
        return "REKLAMEPAUSE";
      }

      // If banned, rotate and try again (skip it)
      if (sessionState.bannedSeries.includes(seriesName)) {
        rotateQueue(channelIndex);
        return playNextInQueue(channelIndex);
      }

      const ch = channels[channelIndex];
      const vids = ch.series ? ch.series[seriesName] : ch.videos;

      if (!vids) return null;

      // GOOD BEHAVIOR: Watching a video resets the removal streak
      channelStates[chKey].removalStreak = 0;

      // UNIQUE SELECTION LOGIC
      // Filter out videos that are already in playedHistory
      const history = getPlayedHistory();

      // STRICT REQUIREMENT: Prevent recently played videos (last 30 UNIQUE plays) from being selected again
      // even if the series is small or recently reset.
      const recentBufferSize = 30;
      const recentlyPlayed = history.slice(-recentBufferSize);

      // First filter: exclude videos in this series' played history AND recently played globally
      let availableVids = vids.filter(vid => !history.includes(vid) && !recentlyPlayed.includes(vid));

      // If no videos available due to series-specific history, we might be at the end of a series cycle.
      if (availableVids.length === 0) {
        // RESET CYCLE: All episodes in this series have been watched at least once!

        // FIX: Small Series Logic
        // If the series is tiny (e.g. 1 video), just play it again.
        if (vids.length < 3) {
          availableVids = vids;
        } else {
          // Smart Selection for Reset:
          // Candidates are videos NOT in the global recent buffer (last 30 unique plays)
          let candidates = vids.filter(v => !recentlyPlayed.includes(v));

          if (candidates.length === 0) {
            // If ALL videos in this series are in the last 30 plays (very small series), 
            // pick the "Least Recently Used" (one that appeared the longest ago in the history).
            candidates = [...vids].sort((a, b) => {
              const idxA = history.lastIndexOf(a);
              const idxB = history.lastIndexOf(b);
              // Smaller index = older/least recent
              return idxA - idxB;
            });
            // Pick the absolute coldest one to maximize the gap
            availableVids = [candidates[0]];
          } else {
            availableVids = candidates;
          }
        }
      }

      const videoId = availableVids[Math.floor(Math.random() * availableVids.length)];

      const wasInHistory = history.includes(videoId);

      // Mark as played
      addToPlayedHistory(videoId);

      // Update State
      playbackState.currentSeries = seriesName;
      // Removed updateOSD(seriesName) call per request

      renderTVGuide();

      return { id: videoId, wasInHistory: wasInHistory };
    }

    function loadChannel(justPoweredOn = false, isChannelSwitch = false, afterAd = false, skipStatic = false, forceStart = false) {
      // Auto-advance (afterAd=true) should always start from beginning, not random seek
      if (afterAd) forceStart = true;

      const loadId = ++currentLoadId; // Capture this load context

      if (isHovering && on) {
        updateOSD(`${current + 1}. ${channels[current].name}`, true);
      }

      const ch = channels[current];
      const chKey = `ch${current}`;

      if (afterAd) {
        rotateQueue(current);
        if (channelStates[chKey]) channelStates[chKey].currentVideo = null;
      }

      // FIRST: Check what's at the top of the queue
      ensureQueue(current);
      const queueTop = channelStates[chKey] && channelStates[chKey].playlist
        ? channelStates[chKey].playlist[0]
        : null;

      // If queue says REKLAMEPAUSE, we MUST play ads (don't reuse old video)
      // If queue says REKLAMEPAUSE, we MUST play ads (don't reuse old video)
      if (queueTop === "REKLAMEPAUSE") {
        // If ads are disabled, skip this item immediately
        if (!adsEnabled) {
          const ch = channels[current];
          const hasContent = ch.series && Object.keys(ch.series).length > 0;

          if (!hasContent) {
            // Ad-only channel with ads disabled -> Stop player and show static
            if (window.ytPlayer && typeof window.ytPlayer.stopVideo === 'function') {
              window.ytPlayer.stopVideo();
            }
            // Update UI to reflect no content
            if (channelStates[chKey]) channelStates[chKey].currentVideo = null;

            showStatic(() => { });
            return;
          }

          // Content channel -> skip ad block
          loadChannel(false, false, true, true); // afterAd=true (rotates queue), skipStatic=true
          return;
        }

        renderTVGuide();
        const startAds = () => {
          playAdsThen(() => {
            loadChannel(false, false, true, true); // skipStatic=true
          });
        };
        if (skipStatic) { startAds(); } else { showStatic(startAds); }
        return;
      }

      // We are playing content now, so ensure ad state is cleared
      // This is critical if we just skipped an ad, otherwise the system thinks we are still playing an ad
      playbackState.isPlayingAd = false;
      playbackState.adSequence = null;
      if (channelStates[chKey] && channelStates[chKey].adBreak) {
        delete channelStates[chKey].adBreak;
      }

      // Check if we already have a video playing on this channel
      let videoId = null;
      let state = channelStates[chKey] ? channelStates[chKey].currentVideo : null;

      // If we have a currentVideo and we're not coming from an ad, reuse it
      let wasInHistory = false;
      if (state && state.id && !afterAd) {
        videoId = state.id;
      } else {
        // Otherwise get the next video from queue
        const result = playNextInQueue(current);
        if (result && typeof result === 'object') {
          videoId = result.id;
          wasInHistory = result.wasInHistory;
        } else {
          videoId = result;
        }
      }

      if (!videoId) return;

      // LIVE SIMULATION LOGIC
      let seekTo = 0;

      // If we are returning to a video that has been running
      if (state && state.id === videoId && !justPoweredOn && !afterAd) {
        const elapsed = (Date.now() - state.startTime) / 1000;

        // If we know the duration, check if video finished
        if (state.duration && state.duration > 0) {
          if (elapsed < state.duration - 5) {
            seekTo = elapsed;
          } else {
            // Video finished while away
            console.log("Video finished while away");
            rotateQueue(current);
            channelStates[chKey].currentVideo = null;
            loadChannel(false, false, false, true); // forceStart false (normal flow)
            return;
          }
        } else {
          // Duration not known yet, but still seek to elapsed time
          seekTo = Math.max(0, elapsed);
        }
      }

      // IFRAME RANDOM START FIX (Since we can't get duration from iframes)
      const isIframe = videoId.startsWith('iframe:') || videoId.startsWith('embed:') || videoId.includes('/embed') || videoId.includes('1drv.ms');
      const isNewVideo = (!state || state.id !== videoId);

      // FORCE START FIX: If we must start from beginning (e.g. after ads), ensure seekTo is 0
      if (forceStart) {
        seekTo = 0;
      }

      if (isIframe && isNewVideo && seekTo === 0) {
        // If we just powered on OR it's a new video we haven't seen before
        // AND not forced start!
        if ((justPoweredOn || !wasInHistory) && !forceStart) {
          console.log("Randomizing start for Iframe (no duration available)");
          seekTo = Math.floor(Math.random() * 600); // Random 0-10 mins
        }
      }

      const loadVideo = () => {
        // Initialize currentVideo if it doesn't exist or is different
        // Only done for NEW videos. Resuming videos keep their existing state object.
        if (!state || state.id !== videoId) {
          channelStates[chKey].currentVideo = {
            id: videoId,
            startTime: Date.now() - (seekTo * 1000), // Adjust startTime by the initial seek offset
            duration: 0
          };
          // Reset channel-specific pending seek
          channelStates[chKey].pendingSeek = null;

          // Update TV guide to show the new video that's playing
          renderTVGuide();
        }

        // If resuming a video, save the seek target specifically for THIS channel
        if (state && state.id === videoId && seekTo > 0) {
          channelStates[chKey].pendingSeek = seekTo;
        } else if (state && state.id === videoId && seekTo === 0) {
          // Should be rare, but if elapsed is 0, we still want to avoid random seek if it's a resume
          // But actually if seekTo is 0 and it's a resume, it means we just started or wrapped?
          // Let's rely on 'isNewVideo' to filter random seeks.
        }

        createPlayer({
          videoId: videoId,
          startAt: seekTo,
          loadId: loadId,
          onReadyCb: (e) => {
            if (loadId !== currentLoadId) return; // Ignore stale load callbacks

            // iOS-specific: Force playback after static (autoplay may fail on iOS)
            if (e.target.playVideo) {
              try {
                e.target.playVideo();
              } catch (err) {
                console.log('Force play error:', err);
              }
            }

            e.target.setVolume(volume);

            // Attempt to unmute on ALL platforms if not manually muted
            if (!muted && volume > 0) {
              setTimeout(() => {
                e.target.unMute();
                console.log('Unmuted in onReady');
              }, shouldStayMuted ? 3000 : 500); // Increased delay for iOS
            } else if (muted) {
              e.target.mute();
            }

            // 1. Save Duration (DM duration might be 0 immediately after load)
            let dur = e.target.getDuration();
            if (dur && channelStates[chKey] && channelStates[chKey].currentVideo) {
              channelStates[chKey].currentVideo.duration = dur;
            }

            // 2. Random Start Logic 
            const isNewVideo = (!state || state.id !== videoId);

            // ONLY Random Seek if it is a NEW video start or power on, AND not a forced start
            // Crucial fix: 'isChannelSwitch' shouldn't trigger random seek if it's NOT a new video (i.e. resuming)
            // AND skip random seek if the video was already in history (meaning it should start from 0:00)
            const shouldRandom = (justPoweredOn || (isNewVideo && seekTo === 0 && !wasInHistory));

            if (shouldRandom && !forceStart) {
              console.log(`Debug Random Start: PowerOn=${justPoweredOn} New=${isNewVideo} seekTo=${seekTo} Force=${forceStart} WasPlayed=${wasInHistory}`);
              playbackState.pendingRandomSeek = true;

              if (dur && dur > 10) {
                const randTime = 2 + Math.random() * (dur - 7);
                e.target.seekTo(randTime, true);
                playbackState.pendingRandomSeek = false;

                // Update StartTime because we shifted the timeline
                if (channelStates[chKey] && channelStates[chKey].currentVideo) {
                  channelStates[chKey].currentVideo.startTime = Date.now() - (randTime * 1000);
                }
              }
            } else if (seekTo > 0) {
              // Strict Resume
              e.target.seekTo(seekTo, true);
            } else if (!isNewVideo && seekTo === 0) {
              // Resuming at 0 (rare but possible)
            }

            // Mark as visited
            channelStates[chKey].visited = true;
          },
          onStateChangeCb: (e) => {
            if (e.data === window.YT.PlayerState.PLAYING) {
              let dur = e.target.getDuration();

              // CRITICAL for Dailymotion: Capture duration if it was missing during onReady
              if (dur && channelStates[chKey] && channelStates[chKey].currentVideo && (!channelStates[chKey].currentVideo.duration || channelStates[chKey].currentVideo.duration === 0)) {
                channelStates[chKey].currentVideo.duration = dur;
              }

              // Handle Pending Resume for THIS CHANNEL
              if (channelStates[chKey].pendingSeek) {
                const resumeTime = channelStates[chKey].pendingSeek;
                channelStates[chKey].pendingSeek = null; // Clear it

                // Force seek via absolute difference check
                const currentT = e.target.getCurrentTime();
                if (Math.abs(currentT - resumeTime) > 3) {
                  console.log(`Channel ${current} forcing resume seek to:`, resumeTime);
                  e.target.seekTo(resumeTime, true);
                }
              }

              // Handle Pending Random Seek
              if (playbackState.pendingRandomSeek) {
                playbackState.pendingRandomSeek = false;
                if (dur > 10) {
                  const randTime = 2 + Math.random() * (dur - 7);
                  e.target.seekTo(randTime, true);
                  if (channelStates[chKey] && channelStates[chKey].currentVideo) {
                    channelStates[chKey].currentVideo.duration = dur;
                    channelStates[chKey].currentVideo.startTime = Date.now() - (randTime * 1000);
                  }
                }
              }
            }
            if (e.data === window.YT.PlayerState.ENDED) {
              if (loadId !== currentLoadId) return;
              if (channelStates[chKey]) channelStates[chKey].currentVideo = null;
              loadChannel(false, false, true, true);
            }
          },
          onError: (e) => {
            console.error("Playback Error in loadChannel:", e);
            playbackState.consecutiveErrorCount++;
            updateOSD(`FEJL - SPRINGER OVER (${playbackState.consecutiveErrorCount})`, true);

            // Mark bad video
            addToPlayedHistory(videoId);

            if (playbackState.consecutiveErrorCount >= 10) {
              updateOSD("FOR MANGE FEJL - STOPPER", true);
              showStatic(() => { });
              return;
            }

            // Skip to next
            setTimeout(() => {
              if (loadId === currentLoadId) {
                if (channelStates[chKey]) channelStates[chKey].currentVideo = null;
                loadChannel(false, false, true, true);
              }
            }, 100);
          },

        });
      };

      if (skipStatic) { loadVideo(); } else {
        // Ensure static also respects loadId if it was delayed
        showStatic(() => {
          if (loadId === currentLoadId) loadVideo();
        });
      }
    }

    // --- Background Playback Fix ---
    let audioContext = null;
    function setupSilentAudio() {
      if (audioContext) return;
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) return;

        audioContext = new AudioContext();
        // Create a silent oscillator
        // Create a silent oscillator
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        gainNode.gain.value = 0.0001; // Extremely low gain
        oscillator.frequency.value = 1; // 1Hz frequency (inaudible)
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.start();
        console.log("Silent audio started for background persistence.");
      } catch (e) {
        console.error("AudioContext setup failed:", e);
      }
    }

    let playbackMonitorInterval = null;

    function startPlaybackMonitor() {
      if (playbackMonitorInterval) return;
      playbackMonitorInterval = setInterval(() => {
        if (!on || !player || !isIOS) return;

        // "Triple-Trigger" check: if TV is on but not playing for > 2s, force a play call sequence
        if (!playbackState.isPlayingAd && !playbackState.isStatic) {
          const now = Date.now();
          const lastActivity = playbackState.lastActivity || now;

          let isStuck = false;
          if (playerType === 'youtube' && ytPlayer && ytPlayer.getPlayerState) {
            const s = ytPlayer.getPlayerState();
            // -1 (unstarted), 3 (buffering), 2 (paused)
            if (s === -1 || s === 3 || s === 2) isStuck = true;
          } else if (playerType === 'dailymotion' && dmPlayer) {
            // 2 (paused), -1 (unstarted/buffering)
            if (dmInternalState === 2 || dmInternalState === -1) isStuck = true;
          } else if (playerType === 'video' && videoElement) {
            if (videoElement.paused) isStuck = true;
          }

          if (isStuck) {
            if (now - lastActivity > 2500) { // Check every 2.5s
              console.log("iOS Triple-Trigger: Player stuck, forcing play sequence...");

              const forcePlay = () => {
                if (player && player.mute) player.mute();
                if (player && player.playVideo) player.playVideo();

                // Explicit Dailymotion/Video fallbacks
                if (playerType === 'dailymotion' && dmPlayer) dmPlayer.play().catch(() => { });
                if (playerType === 'video' && videoElement) videoElement.play().catch(() => { });

                // Re-unmute after a delay to "kick" the audio engine
                setTimeout(() => {
                  if (on && player && player.unMute) player.unMute();
                }, 800);
              };

              forcePlay();
              playbackState.lastActivity = now;
            }
          } else {
            playbackState.lastActivity = now;
          }
        }
      }, 1500); // Check more frequently
    }

    function stopPlaybackMonitor() {
      if (playbackMonitorInterval) {
        clearInterval(playbackMonitorInterval);
        playbackMonitorInterval = null;
      }
    }


    // Handle Page Visibility - Resume playback when returning to tab
    document.addEventListener('visibilitychange', function () {
      if (!document.hidden && on && player) {
        try {
          // Resume audio context if suspended
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
          }
          // Ensure player is playing
          const playerState = player.getPlayerState();
          if (playerState === window.YT.PlayerState.PAUSED || playerState === window.YT.PlayerState.BUFFERING) {
            player.playVideo();
          }
        } catch (e) {
          console.log('Resume error:', e);
        }
      }
    });

    function power() {
      setupSilentAudio();
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }

      playClick();
      if (on) {
        if (player) {
          try {
            // IMMEDIATE STOP: For iframes/Hamtaro, we must kill the DOM element to stop sound.
            // Our custom wrapper defines destroy() which clears the container.
            if (player.destroy) player.destroy();
            else if (player.pauseVideo) player.pauseVideo();

            player.mute(); // fallback
          } catch (e) { }

          // Force container clear if it's an iframe type directly
          if (playerType === 'iframe') {
            const container = document.getElementById('player');
            if (container) container.innerHTML = '';
          }
        }
        saveState();
        stopAutoSave();
        muted = false; muteIcon.style.opacity = 0;
        updateOSD("TV slukket", true);
        showStatic(() => {
          powerOffSound.currentTime = 0;
          powerOffSound.volume = 0.3;
          powerOffSound.play().catch(() => { });
          powerOffVideo.style.display = "block";
          powerOffVideo.currentTime = 0;
          powerOffVideo.play();
          setTimeout(() => {
            powerOffVideo.pause();
            powerOffVideo.style.display = "none";
            if (player) {
              try {
                if (player.destroy) player.destroy();
                else if (playerType === 'youtube' && ytPlayer) ytPlayer.destroy();
              } catch (e) { }
              player = null;
            }
            // Clear player references for both platforms
            ytPlayer = null;
            dmPlayer = null;
            playerType = null;
            // Force container clear as well
            const container = document.getElementById('player');
            if (container) container.innerHTML = '';
            if (dmUpdateInterval) {
              clearInterval(dmUpdateInterval);
              dmUpdateInterval = null;
            }
            on = false;
            stopPlaybackMonitor();
            updateAdLed();
            channelStates = {}; // Clear channel states to ensure fresh playlist on next power on
            renderTVGuide(); // Will render blank because on=false
          }, 1500);
        });
      } else {
        // Power on
        on = true;
        muted = false;
        initializeTVPlayback();
      }
    }

    function initializeTVPlayback() {
      if (isIOS) startPlaybackMonitor();
      // Resume on last used channel (loaded from state)
      // current = Math.floor(Math.random() * channels.length);

      // Random Week Number
      const weekNum = Math.floor(Math.random() * 52) + 1;
      const weekEl = document.getElementById('week-display');
      if (weekEl) weekEl.innerText = `UGE ${weekNum} - 2004`;

      // Apply filters when turning on
      applyFilters();

      // Update LED light when TV turns on
      updateAdLed();

      // Initialize playlists
      channels.forEach((_, idx) => ensureQueue(idx));

      if (window.location.protocol === 'file:') {
        updateOSD("KØR VIA LOCALSERVER FOR VIDEO", true);
      } else {
        updateOSD("Tænder...", false);
      }

      // Update OSD if hovering
      if (isHovering) updateOSD(`${current + 1}. ${channels[current].name}`, true);

      // Render TV Guide with populated playlists
      renderTVGuide();

      // Start with random video at random time like all other channels
      loadChannel(true, false, false, false, false);
    }

    function chUp() {
      if (on) {
        playClick();
        playClick();

        // STOP current playback immediately to ensure channel switch works
        if (player) {
          try {
            if (player.destroy) player.destroy();
            else if (playerType === 'youtube' && ytPlayer) ytPlayer.destroy();
          } catch (e) {
            console.log('Error destroying during channel switch:', e);
          }
          player = null;
          ytPlayer = null;
          dmPlayer = null;
          playerType = null;
          if (dmUpdateInterval) {
            clearInterval(dmUpdateInterval);
            dmUpdateInterval = null;
          }
        }

        saveState();
        current = (current + 1) % channels.length;
        renderTVGuide(); // Update guide to show new channel
        loadChannel(false, true, false);
      }
    }

    function chDown() {
      if (on) {
        playClick();
        playClick();

        // STOP current playback immediately to ensure channel switch works
        if (player) {
          try {
            if (player.destroy) player.destroy();
            else if (playerType === 'youtube' && ytPlayer) ytPlayer.destroy();
          } catch (e) {
            console.log('Error destroying during channel switch:', e);
          }
          player = null;
          ytPlayer = null;
          dmPlayer = null;
          playerType = null;
          if (dmUpdateInterval) {
            clearInterval(dmUpdateInterval);
            dmUpdateInterval = null;
          }
        }

        saveState();
        current = (current - 1 + channels.length) % channels.length;
        renderTVGuide(); // Update guide to show new channel
        loadChannel(false, true, false);
      }
    }

    function volUp() {
      if (on && player) {
        playClick();
        volume = Math.min(100, volume + 10);
        // Unmute when increasing volume from 0
        if (volume > 0) {
          muted = false;
          player.unMute();
        }
        player.setVolume(volume);
        showVolume();
        saveState();
      }
    }

    function volDown() {
      if (on && player) {
        playClick();
        volume = Math.max(0, volume - 10);
        // Mute when volume reaches 0
        if (volume === 0) {
          muted = true;
          player.mute();
        } else {
          muted = false;
          player.unMute();
        }
        player.setVolume(volume);
        showVolume();
        saveState();
      }
    }

    function muteToggle() {
      if (on && player) {
        playClick();
        muted = !muted;

        // If volume is 0, always stay muted
        if (volume === 0) {
          muted = true;
        }

        // Handle different player types - call mute directly on the actual player instance
        if (playerType === 'iframe') {
          showVolume();
          // Iframe players need a reload to apply mute state via URL
          loadChannel(false, false, false, true);
        } else if (playerType === 'youtube' && ytPlayer) {
          // YouTube player - call mute/unmute directly on ytPlayer
          try {
            if (muted || volume === 0) {
              ytPlayer.mute();
            } else {
              ytPlayer.unMute();
            }
          } catch (e) {
            console.error('YouTube mute error:', e);
          }
          showVolume();
        } else if (playerType === 'dailymotion' && dmPlayer) {
          // Dailymotion player
          try {
            dmPlayer.setMuted(muted || volume === 0);
          } catch (e) {
            console.error('Dailymotion mute error:', e);
          }
          showVolume();
        } else if (playerType === 'video' && videoElement) {
          // Direct video element
          videoElement.muted = muted || volume === 0;
          showVolume();
        } else if (player.mute && player.unMute) {
          // Fallback to player wrapper methods
          (muted || volume === 0) ? player.mute() : player.unMute();
          showVolume();
        }
        saveState();
      }
    }

    // TV Guide Toggle
    let guideCollapsed = false;

    // Fumble Antenna Effect
    let isFumbling = false;
    function antennaFumble() {
      if (!on || isFumbling) return;
      isFumbling = true;

      // Random static duration between 300ms and 1500ms
      const duration = 300 + Math.random() * 1200;

      // Show static
      staticVideo.style.display = "block";
      staticVideo.style.opacity = "0.6";
      staticVideo.style.mixBlendMode = "exclusion";
      staticVideo.style.filter = "contrast(1.5) brightness(1.2)";
      staticVideo.currentTime = Math.random() * 10;
      staticVideo.play().catch(() => { });

      // Play static sound at higher volume for effect
      // Play static sound at higher volume for effect
      staticSound.currentTime = 0;
      staticSound.volume = 0.2;
      staticSound.play().catch(() => { });

      // Show OSD
      updateOSD("JUSTERER ANTENNE...", true);

      setTimeout(() => {
        staticVideo.pause();
        staticVideo.style.display = "none";
        staticVideo.style.opacity = "1";
        staticVideo.style.mixBlendMode = "normal";
        staticVideo.style.filter = "none";
        staticSound.pause();
        staticSound.currentTime = 0;
        isFumbling = false;
        // Restore OSD to channel name
        if (on) updateOSD(`${current + 1}. ${channels[current].name}`, true);
      }, duration);
    }

    function toggleGuide() {
      playClick();
      guideCollapsed = !guideCollapsed;
      const layout = document.getElementById('main-layout');
      const guide = document.getElementById('tvGuide');
      const tv = document.getElementById('tv');

      if (guideCollapsed) {
        guide.classList.add('collapsed');
        tv.classList.add('expanded');
        layout.classList.add('guide-collapsed');
      } else {
        guide.classList.remove('collapsed');
        tv.classList.remove('expanded');
        layout.classList.remove('guide-collapsed');
      }

      // Save state
      localStorage.setItem('guideCollapsed', guideCollapsed);
    }

    function loadGuideState() {
      const saved = localStorage.getItem('guideCollapsed');
      if (saved === 'true') {
        guideCollapsed = true;
        const guide = document.getElementById('tvGuide');
        const tv = document.getElementById('tv');
        if (guide) guide.classList.add('collapsed');
        if (tv) tv.classList.add('expanded');
      }
    }


    const tv = document.getElementById("tv");

    // Auto-fade logic vars
    let hoverTimer = null;

    function resetHoverTimer() {
      if (hoverTimer) clearTimeout(hoverTimer);
      // Fade out after 20 seconds of inactivity even if hovering
      hoverTimer = setTimeout(() => {
        label.style.opacity = 0;
      }, 20000);
    }

    tv.addEventListener("mouseenter", () => {
      isHovering = true;
      if (on) {
        updateOSD(`${current + 1}. ${channels[current].name}`, true); // Sticky while hovering
        resetHoverTimer();
      } else {
        updateOSD("TV slukket", true);
        resetHoverTimer();
      }
    });

    tv.addEventListener("mousemove", () => {
      if (isHovering && on && label.style.opacity == 0) {
        // If it faded out but we moved mouse, show it again
        updateOSD(`${current + 1}. ${channels[current].name}`, true);
      }
      resetHoverTimer();
    });

    tv.addEventListener("mouseleave", () => {
      isHovering = false;
      if (hoverTimer) clearTimeout(hoverTimer);
      // Hide immediately
      label.style.opacity = 0;
    });

    // Brightness & Color Logic
    let brightness = 100;
    let saturation = 100;
    const screenEl = document.querySelector('.screen');

    // Slider Click Sound Engine
    let sliderAudioCtx = null;
    let lastSliderSoundTime = 0;

    function playSliderSound() {
      // Throttle
      const now = Date.now();
      if (now - lastSliderSoundTime < 40) return;
      lastSliderSoundTime = now;

      try {
        if (!sliderAudioCtx) sliderAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (sliderAudioCtx.state === 'suspended') sliderAudioCtx.resume();

        const osc = sliderAudioCtx.createOscillator();
        const gain = sliderAudioCtx.createGain();

        // Mechanical "Tick" Sound
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(800, sliderAudioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(300, sliderAudioCtx.currentTime + 0.02);

        gain.gain.setValueAtTime(0.05, sliderAudioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, sliderAudioCtx.currentTime + 0.02);

        osc.connect(gain);
        gain.connect(sliderAudioCtx.destination);

        osc.start();
        osc.stop(sliderAudioCtx.currentTime + 0.03);
      } catch (e) { }
    }

    function setBrightness(val) {
      if (val != brightness) {
        if (on) playSliderSound();
        brightness = val;
        saveState();
      }
      if (on) {
        applyFilters();
        updateOSD(`LYSSTYRKE: ${brightness}`, true);
        resetHoverTimer();
      }
    }

    function setColor(val) {
      if (val != saturation) {
        if (on) playSliderSound();
        saturation = val;
        saveState();
      }
      if (on) {
        applyFilters();
        updateOSD(`FARVE: ${saturation}`, true);
        resetHoverTimer();
      }
    }

    function toggleAds(enabled) {
      if (on) {
        const toggleSound = document.getElementById('toggleSound');
        if (toggleSound) {
          toggleSound.currentTime = 0;
          toggleSound.volume = 0.4;
          toggleSound.play().catch(() => { });
        }
      }
      adsEnabled = enabled;
      saveState();
      updateAdLed();
      if (on) {
        updateOSD(`REKLAMER: ${adsEnabled ? 'TIL' : 'FRA'}`, true);

        // If we are currently playing an ad and user disabled them, skip immediately
        if (!adsEnabled && playbackState.isPlayingAd) {
          loadChannel(false, false, true, true); // afterAd=true (rotates queue), skipStatic=true
        }
      }
      renderTVGuide(); // Refresh guide to show/hide ads
    }

    function updateAdLed() {
      const led = document.getElementById('adLed');
      if (!led) return;
      led.classList.remove('on-green', 'on-red');
      // Only show LED light when TV is on
      if (on) {
        if (adsEnabled) {
          led.classList.add('on-green');
        } else {
          led.classList.add('on-red');
        }
      }
    }

    function applyFilters() {
      screenEl.style.filter = `brightness(${brightness}%) saturate(${saturation}%)`;
    }

    loadBans();
    loadState();
    loadGuideState();
  </script>

</body>

</html>